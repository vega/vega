{"version":3,"file":"vega-parser.min.js","sources":["../src/parsers/autosize.js","../src/parsers/padding.js","../src/parsers/encode/util.js","../src/parsers/marks/roles.js","../src/parsers/encode/defaults.js","../src/parsers/encode/entry.js","../src/parsers/encode.js","../src/parsers/encode/rule.js","../src/parsers/signal.js","../src/util.js","../src/parsers/stream.js","../src/parsers/update.js","../src/parsers/signal-updates.js","../src/transforms.js","../src/parsers/scale.js","../src/parsers/projection.js","../src/parsers/guides/constants.js","../src/parsers/marks/marktypes.js","../src/parsers/guides/guide-group.js","../src/parsers/guides/guide-util.js","../src/parsers/guides/guide-mark.js","../src/parsers/guides/legend-gradient.js","../src/parsers/guides/legend-gradient-discrete.js","../src/parsers/guides/legend-gradient-labels.js","../src/parsers/guides/legend-symbol-groups.js","../src/parsers/guides/legend-title.js","../src/parsers/marks/clip.js","../src/parsers/marks/role.js","../src/parsers/marks/definition.js","../src/parsers/marks/interactive.js","../src/parsers/transform.js","../src/parsers/marks/data.js","../src/DataScope.js","../src/parsers/trigger.js","../src/parsers/mark.js","../src/parsers/marks/facet.js","../src/parsers/marks/subflow.js","../src/parsers/legend.js","../src/parsers/title.js","../src/parsers/data.js","../src/parsers/guides/axis-util.js","../src/parsers/guides/axis-config.js","../src/parsers/guides/axis-domain.js","../src/parsers/guides/axis-grid.js","../src/parsers/guides/axis-labels.js","../src/parsers/guides/axis-title.js","../src/parsers/axis.js","../src/parsers/guides/axis-ticks.js","../src/parsers/scope.js","../src/parsers/view.js","../src/Scope.js","../src/config.js","../src/parse.js"],"sourcesContent":["import {isObject} from 'vega-util';\n\nexport default function(spec) {\n  return isObject(spec) ? spec : {type: spec || 'pad'};\n}\n","import {isObject} from 'vega-util';\n\nconst number = _ => +_ || 0;\n\nconst paddingObject = _ => ({top: _, bottom: _, left: _, right: _});\n\nexport default function(spec) {\n  return !isObject(spec) ? paddingObject(number(spec))\n    : spec.signal ? spec\n    : {\n        top:    number(spec.top),\n        bottom: number(spec.bottom),\n        left:   number(spec.left),\n        right:  number(spec.right)\n      };\n}\n","import {extend, hasOwnProperty, isArray, isObject} from 'vega-util';\n\nexport const encoder = _ => isObject(_) && !isArray(_)\n  ? extend({}, _)\n  : {value: _};\n\nexport function addEncode(object, name, value, set) {\n  if (value != null) {\n    const isEncoder = (\n      (isObject(value) && !isArray(value)) ||\n      (isArray(value) && value.length && isObject(value[0]))\n    );\n\n    // Always assign signal to update, even if the signal is from the enter block\n    if (isEncoder) {\n      object.update[name] = value;\n    } else {\n      object[set || 'enter'][name] = {value: value};\n    }\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nexport function addEncoders(object, enter, update) {\n  for (const name in enter) {\n    addEncode(object, name, enter[name]);\n  }\n  for (const name in update) {\n    addEncode(object, name, update[name], 'update');\n  }\n}\n\nexport function extendEncode(encode, extra, skip) {\n  for (const name in extra) {\n    if (skip && hasOwnProperty(skip, name)) continue;\n    encode[name] = extend(encode[name] || {}, extra[name]);\n  }\n  return encode;\n}\n\nexport function has(key, encode) {\n  return encode && (\n    (encode.enter && encode.enter[key]) ||\n    (encode.update && encode.update[key])\n  );\n}\n","export const MarkRole = 'mark';\nexport const FrameRole = 'frame';\nexport const ScopeRole = 'scope';\n\nexport const AxisRole = 'axis';\nexport const AxisDomainRole = 'axis-domain';\nexport const AxisGridRole = 'axis-grid';\nexport const AxisLabelRole = 'axis-label';\nexport const AxisTickRole = 'axis-tick';\nexport const AxisTitleRole = 'axis-title';\n\nexport const LegendRole = 'legend';\nexport const LegendBandRole = 'legend-band';\nexport const LegendEntryRole = 'legend-entry';\nexport const LegendGradientRole = 'legend-gradient';\nexport const LegendLabelRole = 'legend-label';\nexport const LegendSymbolRole = 'legend-symbol';\nexport const LegendTitleRole = 'legend-title';\n\nexport const TitleRole = 'title';\nexport const TitleTextRole = 'title-text';\nexport const TitleSubtitleRole = 'title-subtitle';\n","import {has} from './util';\nimport {FrameRole, MarkRole} from '../marks/roles';\nimport {array, extend} from 'vega-util';\n\nexport default function(encode, type, role, style, config) {\n  const defaults = {}, enter = {};\n  let update, key, skip, props;\n\n  // if text mark, apply global lineBreak settings (#2370)\n  key = 'lineBreak';\n  if (type === 'text' && config[key] != null && !has(key, encode)) {\n    applyDefault(defaults, key, config[key]);\n  }\n\n  // ignore legend and axis roles\n  if (role == 'legend' || String(role).startsWith('axis')) {\n    role = null;\n  }\n\n  // resolve mark config\n  props = role === FrameRole ? config.group\n    : (role === MarkRole) ? extend({}, config.mark, config[type])\n    : null;\n\n  for (key in props) {\n    // do not apply defaults if relevant fields are defined\n    skip = has(key, encode)\n      || (key === 'fill' || key === 'stroke')\n      && (has('fill', encode) || has('stroke', encode));\n\n    if (!skip) applyDefault(defaults, key, props[key]);\n  }\n\n  // resolve styles, apply with increasing precedence\n  array(style).forEach(name => {\n    const props = config.style && config.style[name];\n    for (const key in props) {\n      if (!has(key, encode)) {\n        applyDefault(defaults, key, props[key]);\n      }\n    }\n  });\n\n  encode = extend({}, encode); // defensive copy\n  for (key in defaults) {\n    props = defaults[key];\n    if (props.signal) {\n      (update = update || {})[key] = props;\n    } else {\n      enter[key] = props;\n    }\n  }\n\n  encode.enter = extend(enter, encode.enter);\n  if (update) encode.update = extend(update, encode.update);\n\n  return encode;\n}\n\nfunction applyDefault(defaults, key, value) {\n  defaults[key] = value && value.signal\n    ? {signal: value.signal}\n    : {value: value};\n}\n","import {error, isObject, isString, peek, splitAccessPath, stringValue} from 'vega-util';\n\nconst scaleRef = scale => isString(scale) ? stringValue(scale)\n  : scale.signal ? `(${scale.signal})`\n  : field(scale);\n\nexport default function entry(enc) {\n  if (enc.gradient != null) {\n    return gradient(enc);\n  }\n\n  let value = enc.signal ? `(${enc.signal})`\n    : enc.color ? color(enc.color)\n    : enc.field != null ? field(enc.field)\n    : enc.value !== undefined ? stringValue(enc.value)\n    : undefined;\n\n  if (enc.scale != null) {\n    value = scale(enc, value);\n  }\n\n  if (value === undefined) {\n    value = null;\n  }\n\n  if (enc.exponent != null) {\n    value = `pow(${value},${property(enc.exponent)})`;\n  }\n\n  if (enc.mult != null) {\n    value += `*${property(enc.mult)}`;\n  }\n\n  if (enc.offset != null) {\n    value += `+${property(enc.offset)}`;\n  }\n\n  if (enc.round) {\n    value = `round(${value})`;\n  }\n\n  return value;\n}\n\nconst _color = (type, x, y, z) =>\n  `(${type}(${[x, y, z].map(entry).join(',')})+'')`;\n\nfunction color(enc) {\n  return (enc.c) ? _color('hcl', enc.h, enc.c, enc.l)\n    : (enc.h || enc.s) ? _color('hsl', enc.h, enc.s, enc.l)\n    : (enc.l || enc.a) ? _color('lab', enc.l, enc.a, enc.b)\n    : (enc.r || enc.g || enc.b) ? _color('rgb', enc.r, enc.g, enc.b)\n    : null;\n}\n\nfunction gradient(enc) {\n  // map undefined to null; expression lang does not allow undefined\n  const args = [enc.start, enc.stop, enc.count]\n    .map(_ => _ == null ? null : stringValue(_));\n\n  // trim null inputs from the end\n  while (args.length && peek(args) == null) args.pop();\n\n  args.unshift(scaleRef(enc.gradient));\n  return `gradient(${args.join(',')})`;\n}\n\nfunction property(property) {\n  return isObject(property) ? '(' + entry(property) + ')' : property;\n}\n\nfunction field(ref) {\n  return resolveField(isObject(ref) ? ref : {datum: ref});\n}\n\nfunction resolveField(ref) {\n  let object, level, field;\n\n  if (ref.signal) {\n    object = 'datum';\n    field = ref.signal;\n  } else if (ref.group || ref.parent) {\n    level = Math.max(1, ref.level || 1);\n    object = 'item';\n\n    while (level-- > 0) {\n      object += '.mark.group';\n    }\n\n    if (ref.parent) {\n      field = ref.parent;\n      object += '.datum';\n    } else {\n      field = ref.group;\n    }\n  } else if (ref.datum) {\n    object = 'datum';\n    field = ref.datum;\n  } else {\n    error('Invalid field reference: ' + stringValue(ref));\n  }\n\n  if (!ref.signal) {\n    field = isString(field)\n      ? splitAccessPath(field).map(stringValue).join('][')\n      : resolveField(field);\n  }\n\n  return object + '[' + field + ']';\n}\n\nfunction scale(enc, value) {\n  const scale = scaleRef(enc.scale);\n\n  if (enc.range != null) {\n    // pull value from scale range\n    value = `lerp(_range(${scale}), ${+enc.range})`;\n  } else {\n    // run value through scale and/or pull scale bandwidth\n    if (value !== undefined) value = `_scale(${scale}, ${value})`;\n\n    if (enc.band) {\n      value = (value ? value + '+' : '')\n        + `_bandwidth(${scale})`\n        + (+enc.band === 1 ? '' : '*' + property(enc.band));\n\n      if (enc.extra) {\n        // include logic to handle extraneous elements\n        value = `(datum.extra ? _scale(${scale}, datum.extra.value) : ${value})`;\n      }\n    }\n\n    if (value == null) value = '0';\n  }\n\n  return value;\n}\n","import applyDefaults from './encode/defaults';\nimport entry from './encode/entry';\nimport rule from './encode/rule';\n\nimport {parseExpression} from 'vega-functions';\nimport {extend, isArray} from 'vega-util';\n\nexport default function(encode, type, role, style, scope, params) {\n  const enc = {};\n  params = params || {};\n  params.encoders = {$encode: enc};\n\n  encode = applyDefaults(encode, type, role, style, scope.config);\n  for (const key in encode) {\n    enc[key] = parseBlock(encode[key], type, params, scope);\n  }\n\n  return params;\n}\n\nfunction parseBlock(block, marktype, params, scope) {\n  const channels = {},\n        fields = {};\n\n  for (const name in block) {\n    if (block[name] != null) { // skip any null entries\n      channels[name] = parse(expr(block[name]), scope, params, fields);\n    }\n  }\n\n  return {\n    $expr:   {marktype, channels},\n    $fields: Object.keys(fields),\n    $output: Object.keys(block)\n  };\n}\n\nfunction expr(enc) {\n  return isArray(enc) ? rule(enc) : entry(enc);\n}\n\nfunction parse(code, scope, params, fields) {\n  const expr = parseExpression(code, scope);\n  expr.$fields.forEach(name => fields[name] = 1);\n  extend(params, expr.$params);\n  return expr.$expr;\n}\n","import entry from './entry';\nimport {peek} from 'vega-util';\n\nexport default function(enc) {\n  let code = '';\n\n  enc.forEach(rule => {\n    const value = entry(rule);\n    code += rule.test ? `(${rule.test})?${value}:` : value;\n  });\n\n  // if no else clause, terminate with null (#1366)\n  if (peek(code) === ':') {\n    code += 'null';\n  }\n\n  return code;\n}\n","import {error, stringValue} from 'vega-util';\n\nconst OUTER = 'outer',\n      OUTER_INVALID = ['value', 'update', 'init', 'react', 'bind'];\n\nfunction outerError(prefix, name) {\n  error(prefix + ' for \"outer\" push: ' + stringValue(name));\n}\n\nexport default function(signal, scope) {\n  const name = signal.name;\n\n  if (signal.push === OUTER) {\n    // signal must already be defined, raise error if not\n    if (!scope.signals[name]) outerError('No prior signal definition', name);\n    // signal push must not use properties reserved for standard definition\n    OUTER_INVALID.forEach(prop => {\n      if (signal[prop] !== undefined) outerError('Invalid property ', prop);\n    });\n  } else {\n    // define a new signal in the current scope\n    const op = scope.addSignal(name, signal.value);\n    if (signal.react === false) op.react = false;\n    if (signal.bind) scope.addBinding(name, signal.bind);\n  }\n}\n","import {isObject} from 'vega-util';\n\nexport function Entry(type, value, params, parent) {\n  this.id = -1;\n  this.type = type;\n  this.value = value;\n  this.params = params;\n  if (parent) this.parent = parent;\n}\n\nexport function entry(type, value, params, parent) {\n  return new Entry(type, value, params, parent);\n}\n\nexport function operator(value, params) {\n  return entry('operator', value, params);\n}\n\n// -----\n\nexport function ref(op) {\n  const ref = {$ref: op.id};\n  // if operator not yet registered, cache ref to resolve later\n  if (op.id < 0) (op.refs = op.refs || []).push(ref);\n  return ref;\n}\n\nexport const tupleidRef = {\n  $tupleid: 1,\n  toString: function() { return ':_tupleid_:'; }\n};\n\nexport function fieldRef(field, name) {\n  return name ? {$field: field, $name: name} : {$field: field};\n}\n\nexport const keyFieldRef = fieldRef('key');\n\nexport function compareRef(fields, orders) {\n  return {$compare: fields, $order: orders};\n}\n\nexport function keyRef(fields, flat) {\n  const ref = {$key: fields};\n  if (flat) ref.$flat = true;\n  return ref;\n}\n\n// -----\n\nexport const Ascending  = 'ascending';\n\nexport const Descending = 'descending';\n\nexport function sortKey(sort) {\n  return !isObject(sort) ? ''\n    : (sort.order === Descending ? '-' : '+')\n      + aggrField(sort.op, sort.field);\n}\n\nexport function aggrField(op, field) {\n  return (op && op.signal ? '$' + op.signal : op || '')\n    + (op && field ? '_' : '')\n    + (field && field.signal ? '$' + field.signal : field || '');\n}\n\n// -----\n\nexport const Scope = 'scope';\n\nexport const View = 'view';\n\nexport function isSignal(_) {\n  return _ && _.signal;\n}\n\nexport function isExpr(_) {\n  return _ && _.expr;\n}\n\nexport function hasSignal(_) {\n  if (isSignal(_)) return true;\n  if (isObject(_)) for (const key in _) {\n    if (hasSignal(_[key])) return true;\n  }\n  return false;\n}\n\nexport function value(specValue, defaultValue) {\n  return specValue != null ? specValue : defaultValue;\n}\n\nexport function deref(v) {\n  return v && v.signal || v;\n}\n","import {Scope, View} from '../util';\nimport {parseExpression} from 'vega-functions';\nimport {error, stringValue} from 'vega-util';\n\nconst Timer = 'timer';\n\nexport default function parseStream(stream, scope) {\n  const method = stream.merge ? mergeStream\n    : stream.stream ? nestedStream\n    : stream.type ? eventStream\n    : error('Invalid stream specification: ' + stringValue(stream));\n\n  return method(stream, scope);\n}\n\nfunction eventSource(source) {\n   return source === Scope ? View : (source || View);\n}\n\nfunction mergeStream(stream, scope) {\n  const list = stream.merge.map(s => parseStream(s, scope)),\n        entry = streamParameters({merge: list}, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction nestedStream(stream, scope) {\n  const id = parseStream(stream.stream, scope),\n        entry = streamParameters({stream: id}, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction eventStream(stream, scope) {\n  let id;\n  if (stream.type === Timer) {\n    id = scope.event(Timer, stream.throttle);\n    stream = {between: stream.between, filter: stream.filter};\n  } else {\n    id = scope.event(eventSource(stream.source), stream.type);\n  }\n\n  const entry = streamParameters({stream: id}, stream, scope);\n  return Object.keys(entry).length === 1\n    ? id\n    : scope.addStream(entry).id;\n}\n\nfunction streamParameters(entry, stream, scope) {\n  let param = stream.between;\n\n  if (param) {\n    if (param.length !== 2) {\n      error('Stream \"between\" parameter must have 2 entries: ' + stringValue(stream));\n    }\n    entry.between = [\n      parseStream(param[0], scope),\n      parseStream(param[1], scope)\n    ];\n  }\n\n  param = stream.filter ? [].concat(stream.filter) : [];\n  if (stream.marktype || stream.markname || stream.markrole) {\n    // add filter for mark type, name and/or role\n    param.push(filterMark(stream.marktype, stream.markname, stream.markrole));\n  }\n  if (stream.source === Scope) {\n    // add filter to limit events from sub-scope only\n    param.push('inScope(event.item)');\n  }\n  if (param.length) {\n    entry.filter = parseExpression('(' + param.join(')&&(') + ')', scope).$expr;\n  }\n\n  if ((param = stream.throttle) != null) {\n    entry.throttle = +param;\n  }\n\n  if ((param = stream.debounce) != null) {\n    entry.debounce = +param;\n  }\n\n  if (stream.consume) {\n    entry.consume = true;\n  }\n\n  return entry;\n}\n\nfunction filterMark(type, name, role) {\n  const item = 'event.item';\n  return item\n    + (type && type !== '*' ? '&&' + item + '.mark.marktype===\\'' + type + '\\'' : '')\n    + (role ? '&&' + item + '.mark.role===\\'' + role + '\\'' : '')\n    + (name ? '&&' + item + '.mark.name===\\'' + name + '\\'' : '');\n}\n","import parseStream from './stream';\nimport {Scope, View} from '../util';\nimport {parseSelector} from 'vega-event-selector';\nimport {parseExpression} from 'vega-functions';\nimport {array, error, extend, isString, stringValue} from 'vega-util';\n\n// bypass expression parser for internal operator references\nconst OP_VALUE_EXPR = {\n  code: '_.$value',\n  ast: {type: 'Identifier', value: 'value'}\n};\n\nexport default function(spec, scope, target) {\n  const encode = spec.encode,\n        entry = {target: target};\n\n  let events = spec.events,\n      update = spec.update,\n      sources = [];\n\n  if (!events) {\n    error('Signal update missing events specification.');\n  }\n\n  // interpret as an event selector string\n  if (isString(events)) {\n    events = parseSelector(events, scope.isSubscope() ? Scope : View);\n  }\n\n  // separate event streams from signal updates\n  events = array(events)\n    .filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1);\n\n  // merge internal operator listeners\n  if (sources.length > 1) {\n    sources = [mergeSources(sources)];\n  }\n\n  // merge event streams, include as source\n  if (events.length) {\n    sources.push(events.length > 1 ? {merge: events} : events[0]);\n  }\n\n  if (encode != null) {\n    if (update) error('Signal encode and update are mutually exclusive.');\n    update = 'encode(item(),' + stringValue(encode) + ')';\n  }\n\n  // resolve update value\n  entry.update = isString(update) ? parseExpression(update, scope)\n    : update.expr != null ? parseExpression(update.expr, scope)\n    : update.value != null ? update.value\n    : update.signal != null ? {\n        $expr:   OP_VALUE_EXPR,\n        $params: {$value: scope.signalRef(update.signal)}\n      }\n    : error('Invalid signal update specification.');\n\n  if (spec.force) {\n    entry.options = {force: true};\n  }\n\n  sources.forEach(source =>\n    scope.addUpdate(extend(streamSource(source, scope), entry))\n  );\n}\n\nfunction streamSource(stream, scope) {\n  return {\n    source: stream.signal ? scope.signalRef(stream.signal)\n          : stream.scale ? scope.scaleRef(stream.scale)\n          : parseStream(stream, scope)\n  };\n}\n\nfunction mergeSources(sources) {\n  return {\n    signal: '['\n      + sources.map(s => s.scale ? 'scale(\"' + s.scale + '\")' : s.signal)\n      + ']'\n  };\n}\n","import parseUpdate from './update';\nimport {parseExpression} from 'vega-functions';\nimport {error} from 'vega-util';\n\nexport default function(signal, scope) {\n  const op = scope.getSignal(signal.name);\n  let expr = signal.update;\n\n  if (signal.init) {\n    if (expr) {\n      error('Signals can not include both init and update expressions.');\n    } else {\n      expr = signal.init;\n      op.initonly = true;\n    }\n  }\n\n  if (expr) {\n    expr = parseExpression(expr, scope);\n    op.update = expr.$expr;\n    op.params = expr.$params;\n  }\n\n  if (signal.on) {\n    signal.on.forEach(_ => parseUpdate(_, scope, op.id));\n  }\n}\n","import {entry} from './util';\n\nconst transform = name => (params, value, parent) =>\n  entry(name, value, params || undefined, parent);\n\nexport const Aggregate = transform('aggregate');\nexport const AxisTicks = transform('axisticks');\nexport const Bound = transform('bound');\nexport const Collect = transform('collect');\nexport const Compare = transform('compare');\nexport const DataJoin = transform('datajoin');\nexport const Encode = transform('encode');\nexport const Expression = transform('expression');\nexport const Extent = transform('extent');\nexport const Facet = transform('facet');\nexport const Field = transform('field');\nexport const Key = transform('key');\nexport const LegendEntries = transform('legendentries');\nexport const Load = transform('load');\nexport const Mark = transform('mark');\nexport const MultiExtent = transform('multiextent');\nexport const MultiValues = transform('multivalues');\nexport const Overlap = transform('overlap');\nexport const Params = transform('params');\nexport const PreFacet = transform('prefacet');\nexport const Projection = transform('projection');\nexport const Proxy = transform('proxy');\nexport const Relay = transform('relay');\nexport const Render = transform('render');\nexport const Scale = transform('scale');\nexport const Sieve = transform('sieve');\nexport const SortItems = transform('sortitems');\nexport const ViewLayout = transform('viewlayout');\nexport const Values = transform('values');\n","import {\n  Aggregate, Collect, MultiExtent, MultiValues, Sieve, Values\n} from '../transforms';\nimport {aggrField, keyFieldRef, ref} from '../util';\n\nimport {isDiscrete, isQuantile, isValidScaleType} from 'vega-scale';\nimport {\n  error, extend, hasOwnProperty, isArray, isObject, isString, stringValue\n} from 'vega-util';\n\nlet FIELD_REF_ID = 0;\n\nconst MULTIDOMAIN_SORT_OPS  = {min: 'min', max: 'max', count: 'sum'};\n\nexport function initScale(spec, scope) {\n  const type = spec.type || 'linear';\n\n  if (!isValidScaleType(type)) {\n    error('Unrecognized scale type: ' + stringValue(type));\n  }\n\n  scope.addScale(spec.name, {\n    type,\n    domain: undefined\n  });\n}\n\nexport function parseScale(spec, scope) {\n  const params = scope.getScale(spec.name).params;\n  let key;\n\n  params.domain = parseScaleDomain(spec.domain, spec, scope);\n\n  if (spec.range != null) {\n    params.range = parseScaleRange(spec, scope, params);\n  }\n\n  if (spec.interpolate != null) {\n    parseScaleInterpolate(spec.interpolate, params);\n  }\n\n  if (spec.nice != null) {\n    params.nice = parseScaleNice(spec.nice);\n  }\n\n  if (spec.bins != null) {\n    params.bins = parseScaleBins(spec.bins, scope);\n  }\n\n  for (key in spec) {\n    if (hasOwnProperty(params, key) || key === 'name') continue;\n    params[key] = parseLiteral(spec[key], scope);\n  }\n}\n\nfunction parseLiteral(v, scope) {\n  return !isObject(v) ? v\n    : v.signal ? scope.signalRef(v.signal)\n    : error('Unsupported object: ' + stringValue(v));\n}\n\nfunction parseArray(v, scope) {\n  return v.signal\n    ? scope.signalRef(v.signal)\n    : v.map(v => parseLiteral(v, scope));\n}\n\nfunction dataLookupError(name) {\n  error('Can not find data set: ' + stringValue(name));\n}\n\n// -- SCALE DOMAIN ----\n\nfunction parseScaleDomain(domain, spec, scope) {\n  if (!domain) {\n    if (spec.domainMin != null || spec.domainMax != null) {\n      error('No scale domain defined for domainMin/domainMax to override.');\n    }\n    return; // default domain\n  }\n\n  return domain.signal ? scope.signalRef(domain.signal)\n    : (isArray(domain) ? explicitDomain\n    : domain.fields ? multipleDomain\n    : singularDomain)(domain, spec, scope);\n}\n\nfunction explicitDomain(domain, spec, scope) {\n  return domain.map(v => parseLiteral(v, scope));\n}\n\nfunction singularDomain(domain, spec, scope) {\n  const data = scope.getData(domain.data);\n  if (!data) dataLookupError(domain.data);\n\n  return isDiscrete(spec.type)\n      ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false))\n      : isQuantile(spec.type) ? data.domainRef(scope, domain.field)\n      : data.extentRef(scope, domain.field);\n}\n\nfunction multipleDomain(domain, spec, scope) {\n  const data = domain.data,\n        fields = domain.fields.reduce((dom, d) => {\n          d = isString(d) ? {data: data, field: d}\n            : (isArray(d) || d.signal) ? fieldRef(d, scope)\n            : d;\n          dom.push(d);\n          return dom;\n        }, []);\n\n  return (isDiscrete(spec.type) ? ordinalMultipleDomain\n    : isQuantile(spec.type) ? quantileMultipleDomain\n    : numericMultipleDomain)(domain, scope, fields);\n}\n\nfunction fieldRef(data, scope) {\n  const name = '_:vega:_' + (FIELD_REF_ID++),\n        coll = Collect({});\n\n  if (isArray(data)) {\n    coll.value = {$ingest: data};\n  } else if (data.signal) {\n    const code = 'setdata(' + stringValue(name) + ',' + data.signal + ')';\n    coll.params.input = scope.signalRef(code);\n  }\n  scope.addDataPipeline(name, [coll, Sieve({})]);\n  return {data: name, field: 'data'};\n}\n\nfunction ordinalMultipleDomain(domain, scope, fields) {\n  const sort = parseSort(domain.sort, true);\n  let a, v;\n\n  // get value counts for each domain field\n  const counts = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.countsRef(scope, f.field, sort);\n  });\n\n  // aggregate the results from each domain field\n  const p = {groupby: keyFieldRef, pulse: counts};\n  if (sort) {\n    a = sort.op || 'count';\n    v = sort.field ? aggrField(a, sort.field) : 'count';\n    p.ops = [MULTIDOMAIN_SORT_OPS[a]];\n    p.fields = [scope.fieldRef(v)];\n    p.as = [v];\n  }\n  a = scope.add(Aggregate(p));\n\n  // collect aggregate output\n  const c = scope.add(Collect({pulse: ref(a)}));\n\n  // extract values for combined domain\n  v = scope.add(Values({\n    field: keyFieldRef,\n    sort:  scope.sortRef(sort),\n    pulse: ref(c)\n  }));\n\n  return ref(v);\n}\n\nfunction parseSort(sort, multidomain) {\n  if (sort) {\n    if (!sort.field && !sort.op) {\n      if (isObject(sort)) sort.field = 'key';\n      else sort = {field: 'key'};\n    } else if (!sort.field && sort.op !== 'count') {\n      error('No field provided for sort aggregate op: ' + sort.op);\n    } else if (multidomain && sort.field) {\n      if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {\n        error('Multiple domain scales can not be sorted using ' + sort.op);\n      }\n    }\n  }\n  return sort;\n}\n\nfunction quantileMultipleDomain(domain, scope, fields) {\n  // get value arrays for each domain field\n  const values = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.domainRef(scope, f.field);\n  });\n\n  // combine value arrays\n  return ref(scope.add(MultiValues({values: values})));\n}\n\nfunction numericMultipleDomain(domain, scope, fields) {\n  // get extents for each domain field\n  const extents = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.extentRef(scope, f.field);\n  });\n\n  // combine extents\n  return ref(scope.add(MultiExtent({extents: extents})));\n}\n\n// -- SCALE BINS -----\n\nfunction parseScaleBins(v, scope) {\n  return v.signal || isArray(v)\n    ? parseArray(v, scope)\n    : scope.objectProperty(v);\n}\n\n// -- SCALE NICE -----\n\nfunction parseScaleNice(nice) {\n  return isObject(nice)\n    ? {\n        interval: parseLiteral(nice.interval),\n        step: parseLiteral(nice.step)\n      }\n    : parseLiteral(nice);\n}\n\n// -- SCALE INTERPOLATION -----\n\nfunction parseScaleInterpolate(interpolate, params) {\n  params.interpolate = parseLiteral(interpolate.type || interpolate);\n  if (interpolate.gamma != null) {\n    params.interpolateGamma = parseLiteral(interpolate.gamma);\n  }\n}\n\n// -- SCALE RANGE -----\n\nfunction parseScaleRange(spec, scope, params) {\n  const config = scope.config.range;\n  let range = spec.range;\n\n  if (range.signal) {\n    return scope.signalRef(range.signal);\n  } else if (isString(range)) {\n    if (config && hasOwnProperty(config, range)) {\n      spec = extend({}, spec, {range: config[range]});\n      return parseScaleRange(spec, scope, params);\n    } else if (range === 'width') {\n      range = [0, {signal: 'width'}];\n    } else if (range === 'height') {\n      range = isDiscrete(spec.type)\n        ? [0, {signal: 'height'}]\n        : [{signal: 'height'}, 0];\n    } else {\n      error('Unrecognized scale range value: ' + stringValue(range));\n    }\n  } else if (range.scheme) {\n    params.scheme = isArray(range.scheme)\n      ? parseArray(range.scheme, scope)\n      : parseLiteral(range.scheme, scope);\n    if (range.extent) params.schemeExtent = parseArray(range.extent, scope);\n    if (range.count) params.schemeCount = parseLiteral(range.count, scope);\n    return;\n  } else if (range.step) {\n    params.rangeStep = parseLiteral(range.step, scope);\n    return;\n  } else if (isDiscrete(spec.type) && !isArray(range)) {\n    return parseScaleDomain(range, spec, scope);\n  } else if (!isArray(range)) {\n    error('Unsupported range type: ' + stringValue(range));\n  }\n\n  return range.map(v => (isArray(v) ? parseArray : parseLiteral)(v, scope));\n}\n","import {error, isArray, isObject, stringValue} from 'vega-util';\n\nexport default function(proj, scope) {\n  const config = scope.config.projection || {},\n        params = {};\n\n  for (const name in proj) {\n    if (name === 'name') continue;\n    params[name] = parseParameter(proj[name], name, scope);\n  }\n\n  // apply projection defaults from config\n  for (const name in config) {\n    if (params[name] == null) {\n      params[name] = parseParameter(config[name], name, scope);\n    }\n  }\n\n  scope.addProjection(proj.name, params);\n}\n\nfunction parseParameter(_, name, scope) {\n  return isArray(_) ? _.map(_ => parseParameter(_, name, scope))\n    : !isObject(_) ? _\n    : _.signal ? scope.signalRef(_.signal)\n    : name === 'fit' ? _\n    : error('Unsupported parameter object: ' + stringValue(_));\n}\n","export const Top = 'top';\nexport const Left = 'left';\nexport const Right = 'right';\nexport const Bottom = 'bottom';\nexport const Center = 'center';\n\nexport const Vertical = 'vertical';\n\nexport const Start = 'start';\nexport const Middle = 'middle';\nexport const End = 'end';\n\nexport const Index  = 'index';\nexport const Label  = 'label';\nexport const Offset = 'offset';\nexport const Perc   = 'perc';\nexport const Perc2  = 'perc2';\nexport const Value  = 'value';\n\nexport const GuideLabelStyle = 'guide-label';\nexport const GuideTitleStyle = 'guide-title';\nexport const GroupTitleStyle = 'group-title';\nexport const GroupSubtitleStyle = 'group-subtitle';\n\nexport const Symbols = 'symbol';\nexport const Gradient = 'gradient';\nexport const Discrete = 'discrete';\n\nexport const Size = 'size';\nexport const Shape = 'shape';\nexport const Fill = 'fill';\nexport const Stroke = 'stroke';\nexport const StrokeWidth = 'strokeWidth';\nexport const StrokeDash = 'strokeDash';\nexport const Opacity = 'opacity';\n\n// Encoding channels supported by legends\n// In priority order of 'canonical' scale\nexport const LegendScales = [\n  Size,\n  Shape,\n  Fill,\n  Stroke,\n  StrokeWidth,\n  StrokeDash,\n  Opacity\n];\n\nexport const Skip = {\n  name: 1,\n  style: 1,\n  interactive: 1\n};\n\nexport const zero = {value: 0};\nexport const one = {value: 1};\n","export const GroupMark = 'group';\nexport const RectMark = 'rect';\nexport const RuleMark = 'rule';\nexport const SymbolMark = 'symbol';\nexport const TextMark = 'text';\n","import {GroupMark} from '../marks/marktypes';\n\nexport default function(mark) {\n  mark.type = GroupMark;\n  mark.interactive = mark.interactive || false;\n  return mark;\n}\n","import {Center, End, Left, Right, Start, Vertical} from './constants';\nimport {value} from '../../util';\nimport {isObject, stringValue} from 'vega-util';\n\nexport function lookup(spec, config) {\n  const _ = (name, dflt) => value(spec[name], value(config[name], dflt));\n\n  _.isVertical = s => Vertical === value(\n    spec.direction,\n    config.direction || (s ? config.symbolDirection : config.gradientDirection)\n  );\n\n  _.gradientLength = () => value(\n    spec.gradientLength,\n    config.gradientLength || config.gradientWidth\n  );\n\n  _.gradientThickness = () => value(\n    spec.gradientThickness,\n    config.gradientThickness || config.gradientHeight\n  );\n\n  _.entryColumns = () => value(\n    spec.columns,\n    value(config.columns, +_.isVertical(true))\n  );\n\n  return _;\n}\n\nexport function getEncoding(name, encode) {\n  const v = encode && (\n    (encode.update && encode.update[name]) ||\n    (encode.enter && encode.enter[name])\n  );\n  return v && v.signal ? v : v ? v.value : null;\n}\n\nexport function getStyle(name, scope, style) {\n  const s = scope.config.style[style];\n  return s && s[name];\n}\n\nexport function anchorExpr(s, e, m) {\n  return `item.anchor === '${Start}' ? ${s} : item.anchor === '${End}' ? ${e} : ${m}`;\n}\n\nexport const alignExpr = anchorExpr(\n  stringValue(Left),\n  stringValue(Right),\n  stringValue(Center)\n);\n\nexport function tickBand(_) {\n  const v = _('tickBand');\n  let offset = _('tickOffset'),\n      band, extra;\n\n  if (!v) {\n    // if no tick band entry, fall back on other properties\n    band = _('bandPosition');\n    extra = _('tickExtra');\n  } else if (v.signal) {\n    // if signal, augment code to interpret values\n    band = {signal: `(${v.signal}) === 'extent' ? 1 : 0.5`};\n    extra = {signal: `(${v.signal}) === 'extent'`};\n    if (!isObject(offset)) {\n      offset = {signal: `(${v.signal}) === 'extent' ? 0 : ${offset}`};\n    }\n  } else if (v === 'extent') {\n    // if constant, simply set values\n    band = 1;\n    extra = true;\n    offset = 0;\n  } else {\n    band = 0.5;\n    extra = false;\n  }\n\n  return {extra, band, offset};\n}\n\nexport function extendOffset(value, offset) {\n  return !offset ? value\n    : !value ? offset\n    : !isObject(value) ? { value, offset }\n    : Object.assign({}, value, { offset: extendOffset(value.offset, offset) });\n}\n","import {Skip} from './constants';\nimport {extendEncode} from '../encode/util';\n\nexport default function(mark, extras) {\n  if (extras) {\n    mark.name = extras.name;\n    mark.style = extras.style || mark.style;\n    mark.interactive = !!extras.interactive;\n    mark.encode = extendEncode(mark.encode, extras, Skip);\n  } else {\n    mark.interactive = false;\n  }\n  return mark;\n}\n","import {one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders, encoder} from '../encode/util';\nimport {RectMark} from '../marks/marktypes';\nimport {LegendGradientRole} from '../marks/roles';\nimport {extend} from 'vega-util';\n\nexport default function(spec, scale, config, userEncode) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = _.gradientThickness(),\n        length = _.gradientLength();\n\n  let enter, start, stop, width, height;\n\n  if (vertical) {\n    start = [0, 1];\n    stop = [0, 0];\n    width = thickness;\n    height = length;\n  } else {\n    start = [0, 0];\n    stop = [1, 0];\n    width = length;\n    height = thickness;\n  }\n\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      x: zero,\n      y: zero,\n      width: encoder(width),\n      height: encoder(height)\n    },\n    update: extend({}, enter, {\n      opacity: one,\n      fill: {gradient: scale, start: start, stop: stop}\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n\n  addEncoders(encode, {\n    stroke:      _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, { // update\n    opacity:     _('gradientOpacity')\n  });\n\n  return guideMark({\n    type: RectMark,\n    role: LegendGradientRole,\n    encode\n  }, userEncode);\n}\n","import {Perc, Perc2, Value, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders, encoder} from '../encode/util';\nimport {RectMark} from '../marks/marktypes';\nimport {LegendBandRole} from '../marks/roles';\nimport {extend} from 'vega-util';\n\nexport default function(spec, scale, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = _.gradientThickness(),\n        length = _.gradientLength();\n\n  let u, v, uu, vv, adjust = '';\n\n  vertical\n    ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-')\n    : (u = 'x', uu = 'x2', v = 'y', vv = 'height');\n\n  const enter = {\n    opacity: zero,\n    fill: {scale: scale, field: Value}\n  };\n  enter[u]  = {signal: adjust + 'datum.' + Perc, mult: length};\n  enter[v]  = zero;\n  enter[uu] = {signal: adjust + 'datum.' + Perc2, mult: length};\n  enter[vv] = encoder(thickness);\n\n  const encode = {\n    enter: enter,\n    update: extend({}, enter, {opacity: one}),\n    exit: {opacity: zero}\n  };\n\n  addEncoders(encode, {\n    stroke:      _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, { // update\n    opacity:     _('gradientOpacity')\n  });\n\n  return guideMark({\n    type: RectMark,\n    role: LegendBandRole,\n    key:  Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n","import {\n  Bottom, Center, GuideLabelStyle, Index, Label, Left, Middle,\n  Perc, Right, Top, Value, one, zero\n} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders, encoder} from '../encode/util';\nimport {TextMark} from '../marks/marktypes';\nimport {LegendLabelRole} from '../marks/roles';\nimport {value} from '../../util';\n\nconst alignExpr = `datum.${Perc}<=0?\"${Left}\":datum.${Perc}>=1?\"${Right}\":\"${Center}\"`,\n      baselineExpr = `datum.${Perc}<=0?\"${Bottom}\":datum.${Perc}>=1?\"${Top}\":\"${Middle}\"`;\n\nexport default function(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = encoder(_.gradientThickness()),\n        length = _.gradientLength();\n\n  let overlap = _('labelOverlap'),\n      enter, update, u, v, adjust = '';\n\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      text: {field: Label}\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n\n  addEncoders(encode, {\n    fill:        _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font:        _('labelFont'),\n    fontSize:    _('labelFontSize'),\n    fontStyle:   _('labelFontStyle'),\n    fontWeight:  _('labelFontWeight'),\n    limit:       value(spec.labelLimit, config.gradientLabelLimit)\n  });\n\n  if (vertical) {\n    enter.align = {value: 'left'};\n    enter.baseline = update.baseline = {signal: baselineExpr};\n    u = 'y'; v = 'x'; adjust = '1-';\n  } else {\n    enter.align = update.align = {signal: alignExpr};\n    enter.baseline = {value: 'top'};\n    u = 'x'; v = 'y';\n  }\n\n  enter[u] = update[u] = {signal: adjust + 'datum.' + Perc, mult: length};\n\n  enter[v] = update[v] = thickness;\n  thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;\n\n  overlap = overlap ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.' + Index\n  } : undefined;\n\n  // type, role, style, key, dataRef, encode, extras\n  return guideMark({\n    type:  TextMark,\n    role:  LegendLabelRole,\n    style: GuideLabelStyle,\n    key:   Value,\n    from: dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n","import {\n  GuideLabelStyle, Index, Label, LegendScales, Offset, Size, Skip,\n  Value, one, zero\n} from './constants';\nimport guideGroup from './guide-group';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders, encoder, extendEncode} from '../encode/util';\nimport {SymbolMark, TextMark} from '../marks/marktypes';\nimport {LegendLabelRole, LegendSymbolRole, ScopeRole} from '../marks/roles';\n\n// userEncode is top-level, includes entries, symbols, labels\nexport default function(spec, config, userEncode, dataRef, columns) {\n  const _ = lookup(spec, config),\n        entries = userEncode.entries,\n        interactive = !!(entries && entries.interactive),\n        name = entries ? entries.name : undefined,\n        height = _('clipHeight'),\n        symbolOffset = _('symbolOffset'),\n        valueRef = {data: 'value'},\n        xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`,\n        yEncode = height ? encoder(height) : {field: Size},\n        index = `datum.${Index}`,\n        ncols = `max(1, ${columns})`;\n\n  let encode, enter, update, nrows, sort;\n\n  yEncode.mult = 0.5;\n\n  // -- LEGEND SYMBOLS --\n  encode = {\n    enter:  enter = {\n      opacity: zero,\n      x: {signal: xSignal, mult: 0.5, offset: symbolOffset},\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n\n  let baseFill = null,\n      baseStroke = null;\n  if (!spec.fill) {\n    baseFill = config.symbolBaseFillColor;\n    baseStroke = config.symbolBaseStrokeColor;\n  }\n\n  addEncoders(encode, {\n    fill:             _('symbolFillColor', baseFill),\n    shape:            _('symbolType'),\n    size:             _('symbolSize'),\n    stroke:           _('symbolStrokeColor', baseStroke),\n    strokeDash:       _('symbolDash'),\n    strokeDashOffset: _('symbolDashOffset'),\n    strokeWidth:      _('symbolStrokeWidth')\n  }, { // update\n    opacity:          _('symbolOpacity')\n  });\n\n  LegendScales.forEach(scale => {\n    if (spec[scale]) {\n      update[scale] = enter[scale] = {scale: spec[scale], field: Value};\n    }\n  });\n\n  const symbols = guideMark({\n    type: SymbolMark,\n    role: LegendSymbolRole,\n    key:  Value,\n    from: valueRef,\n    clip: height ? true : undefined,\n    encode\n  }, userEncode.symbols);\n\n  // -- LEGEND LABELS --\n  const labelOffset = encoder(symbolOffset);\n  labelOffset.offset = _('labelOffset');\n\n  encode = {\n    enter:  enter = {\n      opacity: zero,\n      x: {signal: xSignal, offset: labelOffset},\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      text: {field: Label},\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n\n  addEncoders(encode, {\n    align:       _('labelAlign'),\n    baseline:    _('labelBaseline'),\n    fill:        _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font:        _('labelFont'),\n    fontSize:    _('labelFontSize'),\n    fontStyle:   _('labelFontStyle'),\n    fontWeight:  _('labelFontWeight'),\n    limit:       _('labelLimit')\n  });\n\n  const labels = guideMark({\n    type:  TextMark,\n    role:  LegendLabelRole,\n    style: GuideLabelStyle,\n    key:   Value,\n    from:  valueRef,\n    encode\n  }, userEncode.labels);\n\n  // -- LEGEND ENTRY GROUPS --\n  encode = {\n    enter: {\n      noBound: {value: !height}, // ignore width/height in bounds calc\n      width: zero,\n      height: height ? encoder(height) : zero,\n      opacity: zero\n    },\n    exit: {opacity: zero},\n    update: update = {\n      opacity: one,\n      row: {signal: null},\n      column: {signal: null}\n    }\n  };\n\n  // annotate and sort groups to ensure correct ordering\n  if (_.isVertical(true)) {\n    nrows = `ceil(item.mark.items.length / ${ncols})`;\n    update.row.signal = `${index}%${nrows}`;\n    update.column.signal = `floor(${index} / ${nrows})`;\n    sort = {field: ['row', index]};\n  } else {\n    update.row.signal = `floor(${index} / ${ncols})`;\n    update.column.signal = `${index} % ${ncols}`;\n    sort = {field: index};\n  }\n  // handle zero column case (implies infinite columns)\n  update.column.signal = `(${columns})?${update.column.signal}:${index}`;\n\n  // facet legend entries into sub-groups\n  dataRef = {facet: {data: dataRef, name: 'value', groupby: Index}};\n\n  return guideGroup({\n    role:   ScopeRole,\n    from:   dataRef,\n    encode: extendEncode(encode, entries, Skip),\n    marks:  [symbols, labels],\n    name,\n    interactive,\n    sort\n  });\n}\n\nexport function legendSymbolLayout(spec, config) {\n  const _ = lookup(spec, config);\n\n  // layout parameters for legend entries\n  return {\n    align:   _('gridAlign'),\n    columns: _.entryColumns(),\n    center:  {\n      row: true,\n      column: false\n    },\n    padding: {\n      row:    _('rowPadding'),\n      column: _('columnPadding')\n    }\n  };\n}\n","import {GuideTitleStyle, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {alignExpr, anchorExpr, lookup} from './guide-util';\nimport {addEncoders} from '../encode/util';\nimport {TextMark} from '../marks/marktypes';\nimport {LegendTitleRole} from '../marks/roles';\n\n// expression logic for align, anchor, angle, and baseline calculation\nconst isL = 'item.orient === \"left\"',\n      isR = 'item.orient === \"right\"',\n      isLR = `(${isL} || ${isR})`,\n      isVG = `datum.vgrad && ${isLR}`,\n      baseline = anchorExpr('\"top\"', '\"bottom\"', '\"middle\"'),\n      alignFlip = anchorExpr('\"right\"', '\"left\"', '\"center\"'),\n      exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? \"left\" : ${alignExpr}`,\n      exprAnchor = `item._anchor || (${isLR} ? \"middle\" : \"start\")`,\n      exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`,\n      exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? \"bottom\" : \"top\") : ${baseline}) : \"top\"`;\n\nexport default function(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config);\n\n  const encode = {\n    enter: {opacity: zero},\n    update: {\n      opacity: one,\n      x: {field: {group: 'padding'}},\n      y: {field: {group: 'padding'}}\n    },\n    exit: {opacity: zero}\n  };\n\n  addEncoders(encode, {\n    orient:      _('titleOrient'),\n    _anchor:     _('titleAnchor'),\n    anchor:      {signal: exprAnchor},\n    angle:       {signal: exprAngle},\n    align:       {signal: exprAlign},\n    baseline:    {signal: exprBaseline},\n    text:        spec.title,\n    fill:        _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font:        _('titleFont'),\n    fontSize:    _('titleFontSize'),\n    fontStyle:   _('titleFontStyle'),\n    fontWeight:  _('titleFontWeight'),\n    limit:       _('titleLimit'),\n    lineHeight:  _('titleLineHeight')\n  }, { // require update\n    align:       _('titleAlign'),\n    baseline:    _('titleBaseline')\n  });\n\n  return guideMark({\n    type:  TextMark,\n    role:  LegendTitleRole,\n    style: GuideTitleStyle,\n    from:  dataRef,\n    encode\n  }, userEncode);\n}\n","import {isObject, stringValue} from 'vega-util';\n\nexport default function(clip, scope) {\n  let expr;\n\n  if (isObject(clip)) {\n    if (clip.signal) {\n      expr = clip.signal;\n    } else if (clip.path) {\n      expr = 'pathShape(' + param(clip.path) + ')';\n    } else if (clip.sphere) {\n      expr = 'geoShape(' + param(clip.sphere) + ', {type: \"Sphere\"})';\n    }\n  }\n\n  return expr\n    ? scope.signalRef(expr)\n    : !!clip;\n}\n\nfunction param(value) {\n  return isObject(value) && value.signal\n    ? value.signal\n    : stringValue(value);\n}","import {GroupMark} from './marktypes';\nimport {MarkRole, ScopeRole} from './roles';\n\nexport default function(spec) {\n  const role = spec.role || '';\n  return (!role.indexOf('axis') || !role.indexOf('legend') || !role.indexOf('title'))\n    ? role\n    : spec.type === GroupMark ? ScopeRole : (role || MarkRole);\n}\n","import role from './role';\n\nexport default function(spec) {\n  return {\n    marktype:     spec.type,\n    name:         spec.name || undefined,\n    role:         spec.role || role(spec),\n    zindex:       +spec.zindex || undefined,\n    aria:         spec.aria,\n    description:  spec.description\n  };\n}\n","export default function(spec, scope) {\n  return spec && spec.signal ? scope.signalRef(spec.signal)\n    : spec === false ? false\n    : true;\n}\n","import {Params} from '../transforms';\nimport {entry, fieldRef, isSignal, ref} from '../util';\nimport {definition} from 'vega-dataflow';\nimport {parseExpression} from 'vega-functions';\nimport {error, extend, isArray, isString, stringValue} from 'vega-util';\n\n/**\n * Parse a data transform specification.\n */\nexport default function(spec, scope) {\n  const def = definition(spec.type);\n  if (!def) error('Unrecognized transform type: ' + stringValue(spec.type));\n\n  const t = entry(def.type.toLowerCase(), null, parseParameters(def, spec, scope));\n  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));\n  t.metadata = def.metadata || {};\n\n  return t;\n}\n\n/**\n * Parse all parameters of a data transform.\n */\nfunction parseParameters(def, spec, scope) {\n  const params = {},\n        n = def.params.length;\n\n  for (let i = 0; i < n; ++i) {\n    const pdef = def.params[i];\n    params[pdef.name] = parseParameter(pdef, spec, scope);\n  }\n  return params;\n}\n\n/**\n * Parse a data transform parameter.\n */\nfunction parseParameter(def, spec, scope) {\n  const type = def.type,\n        value = spec[def.name];\n\n  if (type === 'index') {\n    return parseIndexParameter(def, spec, scope);\n  } else if (value === undefined) {\n    if (def.required) {\n      error('Missing required ' + stringValue(spec.type)\n          + ' parameter: ' + stringValue(def.name));\n    }\n    return;\n  } else if (type === 'param') {\n    return parseSubParameters(def, spec, scope);\n  } else if (type === 'projection') {\n    return scope.projectionRef(spec[def.name]);\n  }\n\n  return def.array && !isSignal(value)\n    ? value.map(v => parameterValue(def, v, scope))\n    : parameterValue(def, value, scope);\n}\n\n/**\n * Parse a single parameter value.\n */\nfunction parameterValue(def, value, scope) {\n  const type = def.type;\n\n  if (isSignal(value)) {\n    return isExpr(type) ? error('Expression references can not be signals.')\n         : isField(type) ? scope.fieldRef(value)\n         : isCompare(type) ? scope.compareRef(value)\n         : scope.signalRef(value.signal);\n  } else {\n    const expr = def.expr || isField(type);\n    return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as)\n         : expr && outerField(value) ? fieldRef(value.field, value.as)\n         : isExpr(type) ? parseExpression(value, scope)\n         : isData(type) ? ref(scope.getData(value).values)\n         : isField(type) ? fieldRef(value)\n         : isCompare(type) ? scope.compareRef(value)\n         : value;\n  }\n}\n\n/**\n * Parse parameter for accessing an index of another data set.\n */\nfunction parseIndexParameter(def, spec, scope) {\n  if (!isString(spec.from)) {\n    error('Lookup \"from\" parameter must be a string literal.');\n  }\n  return scope.getData(spec.from).lookupRef(scope, spec.key);\n}\n\n/**\n * Parse a parameter that contains one or more sub-parameter objects.\n */\nfunction parseSubParameters(def, spec, scope) {\n  const value = spec[def.name];\n\n  if (def.array) {\n    if (!isArray(value)) { // signals not allowed!\n      error('Expected an array of sub-parameters. Instead: ' + stringValue(value));\n    }\n    return value.map(v => parseSubParameter(def, v, scope));\n  } else {\n    return parseSubParameter(def, value, scope);\n  }\n}\n\n/**\n * Parse a sub-parameter object.\n */\nfunction parseSubParameter(def, value, scope) {\n  const n =def.params.length;\n  let pdef;\n\n  // loop over defs to find matching key\n  for (let i = 0; i < n; ++i) {\n    pdef = def.params[i];\n    for (const k in pdef.key) {\n      if (pdef.key[k] !== value[k]) { pdef = null; break; }\n    }\n    if (pdef) break;\n  }\n  // raise error if matching key not found\n  if (!pdef) error('Unsupported parameter: ' + stringValue(value));\n\n  // parse params, create Params transform, return ref\n  const params = extend(parseParameters(pdef, value, scope), pdef.key);\n  return ref(scope.add(Params(params)));\n}\n\n// -- Utilities -----\n\nexport const outerExpr = _ => _ && _.expr;\n\nexport const outerField = _ => _ && _.field;\n\nexport const isData = _ => _ === 'data';\n\nexport const isExpr = _ => _ === 'expr';\n\nexport const isField = _ => _ === 'field';\n\nexport const isCompare = _ => _ === 'compare';\n","import parseTransform from '../transform';\nimport {Collect} from '../../transforms';\nimport {ref} from '../../util';\nimport {array, error, extend} from 'vega-util';\n\nexport default function(from, group, scope) {\n  let facet, key, op, dataRef, parent;\n\n  // if no source data, generate singleton datum\n  if (!from) {\n    dataRef = ref(scope.add(Collect(null, [{}])));\n  }\n\n  // if faceted, process facet specification\n  else if (facet = from.facet) {\n    if (!group) error('Only group marks can be faceted.');\n\n    // use pre-faceted source data, if available\n    if (facet.field != null) {\n      dataRef = parent = getDataRef(facet, scope);\n    } else {\n      // generate facet aggregates if no direct data specification\n      if (!from.data) {\n        op = parseTransform(extend({\n          type:    'aggregate',\n          groupby: array(facet.groupby)\n        }, facet.aggregate), scope);\n        op.params.key = scope.keyRef(facet.groupby);\n        op.params.pulse = getDataRef(facet, scope);\n        dataRef = parent = ref(scope.add(op));\n      } else {\n        parent = ref(scope.getData(from.data).aggregate);\n      }\n\n      key = scope.keyRef(facet.groupby, true);\n    }\n  }\n\n  // if not yet defined, get source data reference\n  if (!dataRef) {\n    dataRef = getDataRef(from, scope);\n  }\n\n  return {\n    key: key,\n    pulse: dataRef,\n    parent: parent\n  };\n}\n\nexport function getDataRef(from, scope) {\n  return from.$ref ? from\n    : from.data && from.data.$ref ? from.data\n    : ref(scope.getData(from.data).output);\n}","import {Aggregate, Collect} from './transforms';\nimport {aggrField, entry, keyFieldRef, ref, sortKey} from './util';\nimport {isString} from 'vega-util';\n\nexport default function DataScope(scope, input, output, values, aggr) {\n  this.scope = scope;   // parent scope object\n  this.input = input;   // first operator in pipeline (tuple input)\n  this.output = output; // last operator in pipeline (tuple output)\n  this.values = values; // operator for accessing tuples (but not tuple flow)\n\n  // last aggregate in transform pipeline\n  this.aggregate = aggr;\n\n  // lookup table of field indices\n  this.index = {};\n}\n\nDataScope.fromEntries = function(scope, entries) {\n  const n = entries.length,\n        values = entries[n-1],\n        output = entries[n-2];\n\n  let input = entries[0],\n      aggr = null,\n      i = 1;\n\n  if (input && input.type === 'load') {\n    input = entries[1];\n  }\n\n  // add operator entries to this scope, wire up pulse chain\n  scope.add(entries[0]);\n  for (; i<n; ++i) {\n    entries[i].params.pulse = ref(entries[i-1]);\n    scope.add(entries[i]);\n    if (entries[i].type === 'aggregate') aggr = entries[i];\n  }\n\n  return new DataScope(scope, input, output, values, aggr);\n};\n\nfunction fieldKey(field) {\n  return isString(field) ? field : null;\n}\n\nfunction addSortField(scope, p, sort) {\n  const as = aggrField(sort.op, sort.field);\n  let s;\n\n  if (p.ops) {\n    for (let i = 0, n = p.as.length; i < n; ++i) {\n      if (p.as[i] === as) return;\n    }\n  } else {\n    p.ops = ['count'];\n    p.fields = [null];\n    p.as = ['count'];\n  }\n  if (sort.op) {\n    p.ops.push((s=sort.op.signal) ? scope.signalRef(s) : sort.op);\n    p.fields.push(scope.fieldRef(sort.field));\n    p.as.push(as);\n  }\n}\n\nfunction cache(scope, ds, name, optype, field, counts, index) {\n  const cache = ds[name] || (ds[name] = {}),\n        sort = sortKey(counts);\n\n  let k = fieldKey(field),\n      v, op;\n\n  if (k != null) {\n    scope = ds.scope;\n    k = k + (sort ? '|' + sort : '');\n    v = cache[k];\n  }\n\n  if (!v) {\n    const params = counts\n      ? {field: keyFieldRef, pulse: ds.countsRef(scope, field, counts)}\n      : {field: scope.fieldRef(field), pulse: ref(ds.output)};\n    if (sort) params.sort = scope.sortRef(counts);\n    op = scope.add(entry(optype, undefined, params));\n    if (index) ds.index[field] = op;\n    v = ref(op);\n    if (k != null) cache[k] = v;\n  }\n  return v;\n}\n\nDataScope.prototype = {\n  countsRef(scope, field, sort) {\n    const ds = this,\n          cache = ds.counts || (ds.counts = {}),\n          k = fieldKey(field);\n\n    let v, a, p;\n\n    if (k != null) {\n      scope = ds.scope;\n      v = cache[k];\n    }\n\n    if (!v) {\n      p = {\n        groupby: scope.fieldRef(field, 'key'),\n        pulse: ref(ds.output)\n      };\n      if (sort && sort.field) addSortField(scope, p, sort);\n      a = scope.add(Aggregate(p));\n      v = scope.add(Collect({pulse: ref(a)}));\n      v = {agg: a, ref: ref(v)};\n      if (k != null) cache[k] = v;\n    } else if (sort && sort.field) {\n      addSortField(scope, v.agg.params, sort);\n    }\n\n    return v.ref;\n  },\n\n  tuplesRef() {\n    return ref(this.values);\n  },\n\n  extentRef(scope, field) {\n    return cache(scope, this, 'extent', 'extent', field, false);\n  },\n\n  domainRef(scope, field) {\n    return cache(scope, this, 'domain', 'values', field, false);\n  },\n\n  valuesRef(scope, field, sort) {\n    return cache(scope, this, 'vals', 'values', field, sort || true);\n  },\n\n  lookupRef(scope, field) {\n    return cache(scope, this, 'lookup', 'tupleindex', field, false);\n  },\n\n  indataRef(scope, field) {\n    return cache(scope, this, 'indata', 'tupleindex', field, true, true);\n  }\n};\n","import {operator} from '../util';\nimport {parseExpression} from 'vega-functions';\n\nexport default function(spec, scope, name) {\n  const remove = spec.remove,\n        insert = spec.insert,\n        toggle = spec.toggle,\n        modify = spec.modify,\n        values = spec.values,\n        op = scope.add(operator());\n\n  const update = 'if(' + spec.trigger + ',modify(\"'\n    + name + '\",'\n    + [insert, remove, toggle, modify, values]\n        .map(_ => _ == null ? 'null' : _)\n        .join(',')\n    + '),0)';\n\n  const expr = parseExpression(update, scope);\n  op.update = expr.$expr;\n  op.params = expr.$params;\n}\n","import parseEncode from './encode';\nimport clip from './marks/clip';\nimport definition from './marks/definition';\nimport interactive from './marks/interactive';\nimport parseData from './marks/data';\nimport parseFacet from './marks/facet';\nimport parseSubflow from './marks/subflow';\nimport getRole from './marks/role';\nimport {GroupMark} from './marks/marktypes';\nimport {FrameRole, MarkRole, ScopeRole} from './marks/roles';\nimport parseTransform from './transform';\nimport parseTrigger from './trigger';\nimport DataScope from '../DataScope';\nimport {fieldRef, isSignal, ref} from '../util';\nimport {error} from 'vega-util';\nimport {Bound, Collect, DataJoin, Encode, Mark, Overlap, Render, Sieve, SortItems, ViewLayout} from '../transforms';\n\nexport default function(spec, scope) {\n  const role = getRole(spec),\n        group = spec.type === GroupMark,\n        facet = spec.from && spec.from.facet,\n        overlap = spec.overlap;\n\n  let layout = spec.layout || role === ScopeRole || role === FrameRole,\n      ops, op, store, enc, name, layoutRef, boundRef;\n\n  const nested = role === MarkRole || layout || facet;\n\n  // resolve input data\n  const input = parseData(spec.from, group, scope);\n\n  // data join to map tuples to visual items\n  op = scope.add(DataJoin({\n    key:   input.key || (spec.key ? fieldRef(spec.key) : undefined),\n    pulse: input.pulse,\n    clean: !group\n  }));\n  const joinRef = ref(op);\n\n  // collect visual items\n  op = store = scope.add(Collect({pulse: joinRef}));\n\n  // connect visual items to scenegraph\n  op = scope.add(Mark({\n    markdef:     definition(spec),\n    interactive: interactive(spec.interactive, scope),\n    clip:        clip(spec.clip, scope),\n    context:     {$context: true},\n    groups:      scope.lookup(),\n    parent:      scope.signals.parent ? scope.signalRef('parent') : null,\n    index:       scope.markpath(),\n    pulse:       ref(op)\n  }));\n  const markRef = ref(op);\n\n  // add visual encoders\n  op = enc = scope.add(Encode(parseEncode(\n    spec.encode, spec.type, role, spec.style, scope,\n    {mod: false, pulse: markRef}\n  )));\n\n  // monitor parent marks to propagate changes\n  op.params.parent = scope.encode();\n\n  // add post-encoding transforms, if defined\n  if (spec.transform) {\n    spec.transform.forEach(_ => {\n      const tx = parseTransform(_, scope),\n            md = tx.metadata;\n      if (md.generates || md.changes) {\n        error('Mark transforms should not generate new data.');\n      }\n      if (!md.nomod) enc.params.mod = true; // update encode mod handling\n      tx.params.pulse = ref(op);\n      scope.add(op = tx);\n    });\n  }\n\n  // if item sort specified, perform post-encoding\n  if (spec.sort) {\n    op = scope.add(SortItems({\n      sort:  scope.compareRef(spec.sort),\n      pulse: ref(op)\n    }));\n  }\n\n  const encodeRef = ref(op);\n\n  // add view layout operator if needed\n  if (facet || layout) {\n    layout = scope.add(ViewLayout({\n      layout:   scope.objectProperty(spec.layout),\n      legends:  scope.legends,\n      mark:     markRef,\n      pulse:    encodeRef\n    }));\n    layoutRef = ref(layout);\n  }\n\n  // compute bounding boxes\n  const bound = scope.add(Bound({mark: markRef, pulse: layoutRef || encodeRef}));\n  boundRef = ref(bound);\n\n  // if group mark, recurse to parse nested content\n  if (group) {\n    // juggle layout & bounds to ensure they run *after* any faceting transforms\n    if (nested) { ops = scope.operators; ops.pop(); if (layout) ops.pop(); }\n\n    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);\n    facet ? parseFacet(spec, scope, input)          // explicit facet\n        : nested ? parseSubflow(spec, scope, input) // standard mark group\n        : scope.parse(spec); // guide group, we can avoid nested scopes\n    scope.popState();\n\n    if (nested) { if (layout) ops.push(layout); ops.push(bound); }\n  }\n\n  // if requested, add overlap removal transform\n  if (overlap) {\n    boundRef = parseOverlap(overlap, boundRef, scope);\n  }\n\n  // render / sieve items\n  const render = scope.add(Render({pulse: boundRef})),\n        sieve = scope.add(Sieve({pulse: ref(render)}, undefined, scope.parent()));\n\n  // if mark is named, make accessible as reactive geometry\n  // add trigger updates if defined\n  if (spec.name != null) {\n    name = spec.name;\n    scope.addData(name, new DataScope(scope, store, render, sieve));\n    if (spec.on) spec.on.forEach(on => {\n      if (on.insert || on.remove || on.toggle) {\n        error('Marks only support modify triggers.');\n      }\n      parseTrigger(on, scope, name);\n    });\n  }\n}\n\nfunction parseOverlap(overlap, source, scope) {\n  const method = overlap.method,\n        bound = overlap.bound,\n        sep = overlap.separation;\n\n  const params = {\n    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,\n    method: isSignal(method) ? scope.signalRef(method.signal) : method,\n    pulse:  source\n  };\n\n  if (overlap.order) {\n    params.sort = scope.compareRef({field: overlap.order});\n  }\n\n  if (bound) {\n    const tol = bound.tolerance;\n    params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;\n    params.boundScale = scope.scaleRef(bound.scale);\n    params.boundOrient = bound.orient;\n  }\n\n  return ref(scope.add(Overlap(params)));\n}\n","import {getDataRef} from './data';\nimport DataScope from '../../DataScope';\nimport {Collect, Facet, PreFacet, Sieve} from '../../transforms';\nimport {ref} from '../../util';\nimport {error, stringValue} from 'vega-util';\n\nexport default function(spec, scope, group) {\n  const facet = spec.from.facet,\n        name = facet.name,\n        data = getDataRef(facet, scope);\n  let op;\n\n  if (!facet.name) {\n    error('Facet must have a name: ' + stringValue(facet));\n  }\n  if (!facet.data) {\n    error('Facet must reference a data set: ' + stringValue(facet));\n  }\n\n  if (facet.field) {\n    op = scope.add(PreFacet({\n      field: scope.fieldRef(facet.field),\n      pulse: data\n    }));\n  } else if (facet.groupby) {\n    op = scope.add(Facet({\n      key:   scope.keyRef(facet.groupby),\n      group: ref(scope.proxy(group.parent)),\n      pulse: data\n    }));\n  } else {\n    error('Facet must specify groupby or field: ' + stringValue(facet));\n  }\n\n  // initialize facet subscope\n  const subscope = scope.fork(),\n        source = subscope.add(Collect()),\n        values = subscope.add(Sieve({pulse: ref(source)}));\n  subscope.addData(name, new DataScope(subscope, source, source, values));\n  subscope.addSignal('parent', null);\n\n  // parse faceted subflow\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n","import {PreFacet, Sieve} from '../../transforms';\n\nexport default function(spec, scope, input) {\n  const op = scope.add(PreFacet({pulse: input.pulse})),\n        subscope = scope.fork();\n\n  subscope.add(Sieve());\n  subscope.addSignal('parent', null);\n\n  // parse group mark subflow\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n","import {addEncoders, extendEncode} from './encode/util';\nimport {\n  Discrete, Gradient,\n  GuideLabelStyle, LegendScales, Skip, Symbols\n} from './guides/constants';\nimport guideGroup from './guides/guide-group';\nimport {getEncoding, getStyle, lookup} from './guides/guide-util';\nimport legendGradient from './guides/legend-gradient';\nimport legendGradientDiscrete from './guides/legend-gradient-discrete';\nimport legendGradientLabels from './guides/legend-gradient-labels';\nimport legendSymbolGroups, {legendSymbolLayout} from './guides/legend-symbol-groups';\nimport legendTitle from './guides/legend-title';\nimport parseMark from './mark';\nimport {LegendEntryRole, LegendRole} from './marks/roles';\n\nimport {deref, ref} from '../util';\nimport {Collect, LegendEntries} from '../transforms';\n\nimport {parseExpression} from 'vega-functions';\nimport {isContinuous, isDiscretizing} from 'vega-scale';\nimport {error} from 'vega-util';\n\nexport default function(spec, scope) {\n  const config = scope.config.legend,\n        encode = spec.encode || {},\n        _ = lookup(spec, config),\n        legendEncode = encode.legend || {},\n        name = legendEncode.name || undefined,\n        interactive = legendEncode.interactive,\n        style = legendEncode.style,\n        scales = {};\n\n  let scale = 0, entryLayout, params, children;\n\n  // resolve scales and 'canonical' scale name\n  LegendScales.forEach(s => spec[s]\n    ? (scales[s] = spec[s], scale = scale || spec[s]) : 0\n  );\n  if (!scale) error('Missing valid scale for legend.');\n\n  // resolve legend type (symbol, gradient, or discrete gradient)\n  const type = legendType(spec, scope.scaleType(scale));\n\n  // single-element data source for legend group\n  const datum = {\n    title:  spec.title != null,\n    scales: scales,\n    type:   type,\n    vgrad:  type !== 'symbol' &&  _.isVertical()\n  };\n  const dataRef = ref(scope.add(Collect(null, [datum])));\n\n  // encoding properties for legend entry sub-group\n  const entryEncode = {enter: {x: {value: 0}, y: {value: 0}}};\n\n  // data source for legend values\n  const entryRef = ref(scope.add(LegendEntries(params = {\n    type:    type,\n    scale:   scope.scaleRef(scale),\n    count:   scope.objectProperty(_('tickCount')),\n    limit:   scope.property(_('symbolLimit')),\n    values:  scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  })));\n\n  // continuous gradient legend\n  if (type === Gradient) {\n    children = [\n      legendGradient(spec, scale, config, encode.gradient),\n      legendGradientLabels(spec, config, encode.labels, entryRef)\n    ];\n    // adjust default tick count based on the gradient length\n    params.count = params.count || scope.signalRef(\n      `max(2,2*floor((${deref(_.gradientLength())})/100))`\n    );\n  }\n\n  // discrete gradient legend\n  else if (type === Discrete) {\n    children = [\n      legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef),\n      legendGradientLabels(spec, config, encode.labels, entryRef)\n    ];\n  }\n\n  // symbol legend\n  else {\n    // determine legend symbol group layout\n    entryLayout = legendSymbolLayout(spec, config);\n    children = [\n      legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))\n    ];\n    // pass symbol size information to legend entry generator\n    params.size = sizeExpression(spec, scope, children[0].marks);\n  }\n\n  // generate legend marks\n  children = [\n    guideGroup({\n      role: LegendEntryRole,\n      from: dataRef,\n      encode: entryEncode,\n      marks: children,\n      layout: entryLayout,\n      interactive\n    })\n  ];\n\n  // include legend title if defined\n  if (datum.title) {\n    children.push(legendTitle(spec, config, encode.title, dataRef));\n  }\n\n  // parse legend specification\n  return parseMark(\n    guideGroup({\n      role:        LegendRole,\n      from:        dataRef,\n      encode:      extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),\n      marks:       children,\n      aria:        _('aria'),\n      description: _('description'),\n      zindex:      _('zindex'),\n      name,\n      interactive,\n      style\n    }),\n    scope\n  );\n}\n\nfunction legendType(spec, scaleType) {\n  let type = spec.type || Symbols;\n\n  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {\n    type = isContinuous(scaleType) ? Gradient\n      : isDiscretizing(scaleType) ? Discrete\n      : Symbols;\n  }\n\n  return type !== Gradient ? type\n    : isDiscretizing(scaleType) ? Discrete\n    : Gradient;\n}\n\nfunction scaleCount(spec) {\n  return LegendScales.reduce((count, type) => count + (spec[type] ? 1 : 0), 0);\n}\n\nfunction buildLegendEncode(_, spec, config) {\n  const encode = {enter: {}, update: {}};\n\n  addEncoders(encode, {\n    orient:       _('orient'),\n    offset:       _('offset'),\n    padding:      _('padding'),\n    titlePadding: _('titlePadding'),\n    cornerRadius: _('cornerRadius'),\n    fill:         _('fillColor'),\n    stroke:       _('strokeColor'),\n    strokeWidth:  config.strokeWidth,\n    strokeDash:   config.strokeDash,\n    x:            _('legendX'),\n    y:            _('legendY'),\n\n    // accessibility support\n    format:       spec.format,\n    formatType:   spec.formatType\n  });\n\n  return encode;\n}\n\nfunction sizeExpression(spec, scope, marks) {\n  const size = deref(getChannel('size', spec, marks)),\n        strokeWidth = deref(getChannel('strokeWidth', spec, marks)),\n        fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));\n\n  return parseExpression(\n    `max(ceil(sqrt(${size})+${strokeWidth}),${fontSize})`,\n    scope\n  );\n}\n\nfunction getChannel(name, spec, marks) {\n  return spec[name]\n    ? `scale(\"${spec[name]}\",datum)`\n    : getEncoding(name, marks[0].encode);\n}\n\nfunction getFontSize(encode, scope, style) {\n  return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);\n}\n","import {addEncoders, extendEncode} from './encode/util';\nimport {GroupSubtitleStyle, GroupTitleStyle, Left, Right, Skip} from './guides/constants';\nimport guideGroup from './guides/guide-group';\nimport guideMark from './guides/guide-mark';\nimport {alignExpr, lookup} from './guides/guide-util';\nimport parseMark from './mark';\nimport {TextMark} from './marks/marktypes';\nimport {TitleRole, TitleSubtitleRole, TitleTextRole} from './marks/roles';\nimport {Collect} from '../transforms';\nimport {ref} from '../util';\nimport {extend, isString} from 'vega-util';\n\nconst angleExpr = `item.orient===\"${Left}\"?-90:item.orient===\"${Right}\"?90:0`;\n\nexport default function(spec, scope) {\n  spec = isString(spec) ? {text: spec} : spec;\n\n  const _ = lookup(spec, scope.config.title),\n        encode = spec.encode || {},\n        userEncode = encode.group || {},\n        name = userEncode.name || undefined,\n        interactive = userEncode.interactive,\n        style = userEncode.style,\n        children = [];\n\n  // single-element data source for group title\n  const datum = {},\n        dataRef = ref(scope.add(Collect(null, [datum])));\n\n  // include title text\n  children.push(buildTitle(spec, _, titleEncode(spec), dataRef));\n\n  // include subtitle text\n  if (spec.subtitle) {\n    children.push(buildSubTitle(spec, _, encode.subtitle, dataRef));\n  }\n\n  // parse title specification\n  return parseMark(\n    guideGroup({\n      role:        TitleRole,\n      from:        dataRef,\n      encode:      groupEncode(_, userEncode),\n      marks:       children,\n      aria:        _('aria'),\n      description: _('description'),\n      zindex:      _('zindex'),\n      name,\n      interactive,\n      style\n    }),\n    scope\n  );\n}\n\n// provide backwards-compatibility for title custom encode;\n// the top-level encode block has been *deprecated*.\nfunction titleEncode(spec) {\n  const encode = spec.encode;\n  return (encode && encode.title) || extend({\n    name: spec.name,\n    interactive: spec.interactive,\n    style: spec.style\n  }, encode);\n}\n\nfunction groupEncode(_, userEncode) {\n  const encode = {enter: {}, update: {}};\n\n  addEncoders(encode, {\n    orient:      _('orient'),\n    anchor:      _('anchor'),\n    align:       {signal: alignExpr},\n    angle:       {signal: angleExpr},\n    limit:       _('limit'),\n    frame:       _('frame'),\n    offset:      _('offset') || 0,\n    padding:     _('subtitlePadding')\n  });\n\n  return extendEncode(encode, userEncode, Skip);\n}\n\nfunction buildTitle(spec, _, userEncode, dataRef) {\n  const zero = {value: 0},\n        text = spec.text,\n        encode = {\n          enter: {opacity: zero},\n          update: {opacity: {value: 1}},\n          exit: {opacity: zero}\n        };\n\n  addEncoders(encode, {\n    text:       text,\n    align:      {signal: 'item.mark.group.align'},\n    angle:      {signal: 'item.mark.group.angle'},\n    limit:      {signal: 'item.mark.group.limit'},\n    baseline:   'top',\n    dx:         _('dx'),\n    dy:         _('dy'),\n    fill:       _('color'),\n    font:       _('font'),\n    fontSize:   _('fontSize'),\n    fontStyle:  _('fontStyle'),\n    fontWeight: _('fontWeight'),\n    lineHeight: _('lineHeight')\n  }, { // update\n    align:      _('align'),\n    angle:      _('angle'),\n    baseline:   _('baseline')\n  });\n\n  return guideMark({\n    type: TextMark,\n    role: TitleTextRole,\n    style: GroupTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction buildSubTitle(spec, _, userEncode, dataRef) {\n  const zero = {value: 0},\n        text = spec.subtitle,\n        encode = {\n          enter: {opacity: zero},\n          update: {opacity: {value: 1}},\n          exit: {opacity: zero}\n        };\n\n  addEncoders(encode, {\n    text:       text,\n    align:      {signal: 'item.mark.group.align'},\n    angle:      {signal: 'item.mark.group.angle'},\n    limit:      {signal: 'item.mark.group.limit'},\n    baseline:   'top',\n    dx:         _('dx'),\n    dy:         _('dy'),\n    fill:       _('subtitleColor'),\n    font:       _('subtitleFont'),\n    fontSize:   _('subtitleFontSize'),\n    fontStyle:  _('subtitleFontStyle'),\n    fontWeight: _('subtitleFontWeight'),\n    lineHeight: _('subtitleLineHeight')\n  }, { // update\n    align:      _('align'),\n    angle:      _('angle'),\n    baseline:   _('baseline')\n  });\n\n  return guideMark({\n    type:  TextMark,\n    role:  TitleSubtitleRole,\n    style: GroupSubtitleStyle,\n    from:  dataRef,\n    encode\n  }, userEncode);\n}\n","import parseTransform from './transform';\nimport parseTrigger from './trigger';\nimport {Collect, Load, Relay, Sieve} from '../transforms';\nimport {hasSignal, isSignal, ref} from '../util';\nimport {array} from 'vega-util';\n\nexport default function parseData(data, scope) {\n  const transforms = [];\n\n  if (data.transform) {\n    data.transform.forEach(tx => {\n      transforms.push(parseTransform(tx, scope));\n    });\n  }\n\n  if (data.on) {\n    data.on.forEach(on => {\n      parseTrigger(on, scope, data.name);\n    });\n  }\n\n  scope.addDataPipeline(data.name, analyze(data, scope, transforms));\n}\n\n/**\n * Analyze a data pipeline, add needed operators.\n */\nfunction analyze(data, scope, ops) {\n  const output = [];\n  let source = null,\n      modify = false,\n      generate = false,\n      upstream, i, n, t, m;\n\n  if (data.values) {\n    // hard-wired input data set\n    if (isSignal(data.values) || hasSignal(data.format)) {\n      // if either values is signal or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, ingest upon dataflow init\n      output.push(source = collect({\n        $ingest: data.values,\n        $format: data.format\n      }));\n    }\n  } else if (data.url) {\n    // load data from external source\n    if (hasSignal(data.url) || hasSignal(data.format)) {\n      // if either url or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, request load upon dataflow init\n      output.push(source = collect({\n        $request: data.url,\n        $format: data.format\n      }));\n    }\n  } else if (data.source) {\n    // derives from one or more other data sets\n    source = upstream = array(data.source)\n      .map(d => ref(scope.getData(d).output));\n    output.push(null); // populate later\n  }\n\n  // scan data transforms, add collectors as needed\n  for (i=0, n=ops.length; i<n; ++i) {\n    t = ops[i];\n    m = t.metadata;\n\n    if (!source && !m.source) {\n      output.push(source = collect());\n    }\n    output.push(t);\n\n    if (m.generates) generate = true;\n    if (m.modifies && !generate) modify = true;\n\n    if (m.source) source = t;\n    else if (m.changes) source = null;\n  }\n\n  if (upstream) {\n    n = upstream.length - 1;\n    output[0] = Relay({\n      derive: modify,\n      pulse: n ? upstream : upstream[0]\n    });\n    if (modify || n) {\n      // collect derived and multi-pulse tuples\n      output.splice(1, 0, collect());\n    }\n  }\n\n  if (!source) output.push(collect());\n  output.push(Sieve({}));\n  return output;\n}\n\nfunction collect(values) {\n  const s = Collect({}, values);\n  s.metadata = {source: true};\n  return s;\n}\n\nfunction load(scope, data) {\n  return Load({\n    url:    data.url ? scope.property(data.url) : undefined,\n    async:  data.async ? scope.property(data.async) : undefined,\n    values: data.values ? scope.property(data.values) : undefined,\n    format: scope.objectProperty(data.format)\n  });\n}\n","import {extend, stringValue} from 'vega-util';\nimport {Bottom, Left, Right, Top} from './constants';\nimport {encoder} from '../encode/util';\nimport {isSignal} from '../../util';\n\nconst isX = orient => orient === Bottom || orient === Top;\n\n// get sign coefficient based on axis orient\nexport const getSign = (orient, a, b) => isSignal(orient)\n  ? ifLeftTopExpr(orient.signal, a, b)\n  : orient === Left || orient === Top ? a : b;\n\n// condition on axis x-direction\nexport const ifX = (orient, a, b) => isSignal(orient)\n  ? ifXEnc(orient.signal, a, b)\n  : isX(orient) ? a : b;\n\n// condition on axis y-direction\nexport const ifY = (orient, a, b) => isSignal(orient)\n  ? ifYEnc(orient.signal, a, b)\n  : isX(orient) ? b : a;\n\nexport const ifTop = (orient, a, b) => isSignal(orient)\n  ? ifTopExpr(orient.signal, a, b)\n  : orient === Top ? {value: a} : {value: b};\n\nexport const ifRight = (orient, a, b) => isSignal(orient)\n  ? ifRightExpr(orient.signal, a, b)\n  : orient === Right ? {value: a} : {value: b};\n\nconst ifXEnc = ($orient, a, b) => ifEnc(\n  `${$orient} === '${Top}' || ${$orient} === '${Bottom}'`, a, b\n);\n\nconst ifYEnc = ($orient, a, b) => ifEnc(\n  `${$orient} !== '${Top}' && ${$orient} !== '${Bottom}'`, a, b\n);\n\nconst ifLeftTopExpr = ($orient, a, b) => ifExpr(\n  `${$orient} === '${Left}' || ${$orient} === '${Top}'`, a, b\n);\n\nconst ifTopExpr = ($orient, a, b) => ifExpr(\n  `${$orient} === '${Top}'`, a, b\n);\n\nconst ifRightExpr = ($orient, a, b) => ifExpr(\n  `${$orient} === '${Right}'`, a, b\n);\n\nconst ifEnc = (test, a, b) => {\n  // ensure inputs are encoder objects (or null)\n  a = a != null ? encoder(a) : a;\n  b = b != null ? encoder(b) : b;\n\n  if (isSimple(a) && isSimple(b)) {\n    // if possible generate simple signal expression\n    a = a ? (a.signal || stringValue(a.value)) : null;\n    b = b ? (b.signal || stringValue(b.value)) : null;\n    return {signal: `${test} ? (${a}) : (${b})`};\n  } else {\n    // otherwise generate rule set\n    return [extend({test}, a)].concat(b || []);\n  }\n};\n\nconst isSimple = enc => (\n  enc == null || Object.keys(enc).length === 1\n);\n\nconst ifExpr = (test, a, b) => ({\n  signal: `${test} ? (${toExpr(a)}) : (${toExpr(b)})`\n});\n\nexport const ifOrient = ($orient, t, b, l, r) => ({\n  signal: (l != null ? `${$orient} === '${Left}' ? (${toExpr(l)}) : ` : '')\n        + (b != null ? `${$orient} === '${Bottom}' ? (${toExpr(b)}) : ` : '')\n        + (r != null ? `${$orient} === '${Right}' ? (${toExpr(r)}) : ` : '')\n        + (t != null ? `${$orient} === '${Top}' ? (${toExpr(t)}) : ` : '')\n        + '(null)'\n});\n\nconst toExpr = v => isSignal(v)\n  ? v.signal\n  : v == null ? null : stringValue(v);\n\nexport const mult = (sign, value) => value === 0 ? 0 : isSignal(sign)\n  ? {signal: `(${sign.signal}) * ${value}`}\n  : {value: sign * value};\n\nexport const patch = (value, base) => {\n  const s = value.signal;\n  return s && s.endsWith('(null)')\n    ? {signal: s.slice(0, -6) + base.signal}\n    : value;\n};\n","import {ifOrient, ifX} from './axis-util';\nimport {Bottom, GuideLabelStyle, GuideTitleStyle, Top} from './constants';\nimport {isSignal} from '../../util';\nimport {extend, hasOwnProperty} from 'vega-util';\n\nfunction fallback(prop, config, axisConfig, style) {\n  let styleProp;\n\n  if (config && hasOwnProperty(config, prop)) {\n    return config[prop];\n  }\n  else if (hasOwnProperty(axisConfig, prop)) {\n    return axisConfig[prop];\n  }\n  else if (prop.startsWith('title')) {\n    switch (prop) {\n      case 'titleColor':\n        styleProp = 'fill';\n        break;\n      case 'titleFont':\n      case 'titleFontSize':\n      case 'titleFontWeight':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n    return style[GuideTitleStyle][styleProp];\n  }\n  else if (prop.startsWith('label')) {\n    switch (prop) {\n      case 'labelColor':\n        styleProp = 'fill';\n        break;\n      case 'labelFont':\n      case 'labelFontSize':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n    return style[GuideLabelStyle][styleProp];\n  }\n\n  return null;\n}\n\nfunction keys(objects) {\n  const map = {};\n  for (const obj of objects) {\n    if (!obj) continue;\n    for (const key in obj) map[key] = 1;\n  }\n  return Object.keys(map);\n}\n\nexport default function(spec, scope) {\n  var config = scope.config,\n      style = config.style,\n      axis = config.axis,\n      band = scope.scaleType(spec.scale) === 'band' && config.axisBand,\n      orient = spec.orient,\n      xy, or, key;\n\n  if (isSignal(orient)) {\n    const xyKeys = keys([\n            config.axisX, config.axisY\n          ]),\n          orientKeys = keys([\n            config.axisTop, config.axisBottom,\n            config.axisLeft, config.axisRight\n          ]);\n\n    xy = {};\n    for (key of xyKeys) {\n      xy[key] = ifX(\n        orient,\n        fallback(key, config.axisX, axis, style),\n        fallback(key, config.axisY, axis, style)\n      );\n    }\n\n    or = {};\n    for (key of orientKeys) {\n      or[key] = ifOrient(\n        orient.signal,\n        fallback(key, config.axisTop, axis, style),\n        fallback(key, config.axisBottom, axis, style),\n        fallback(key, config.axisLeft, axis, style),\n        fallback(key, config.axisRight, axis, style)\n      );\n    }\n  } else {\n    xy = (orient === Top || orient === Bottom) ? config.axisX : config.axisY;\n    or = config['axis' + orient[0].toUpperCase() + orient.slice(1)];\n  }\n\n  const result = (xy || or || band)\n    ? extend({}, axis, xy, or, band)\n    : axis;\n\n  return result;\n}\n","import {ifX, ifY} from './axis-util';\nimport {one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders} from '../encode/util';\nimport {RuleMark} from '../marks/marktypes';\nimport {AxisDomainRole} from '../marks/roles';\n\nexport default function(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        orient = spec.orient;\n\n  let enter, update;\n  const encode = {\n    enter: enter = {opacity: zero},\n    update: update = {opacity: one},\n    exit: {opacity: zero}\n  };\n\n  addEncoders(encode, {\n    stroke:           _('domainColor'),\n    strokeCap:        _('domainCap'),\n    strokeDash:       _('domainDash'),\n    strokeDashOffset: _('domainDashOffset'),\n    strokeWidth:      _('domainWidth'),\n    strokeOpacity:    _('domainOpacity')\n  });\n\n  const pos0 = position(spec, 0);\n  const pos1 = position(spec, 1);\n\n  enter.x = update.x = ifX(orient, pos0, zero);\n  enter.x2 = update.x2 = ifX(orient, pos1);\n\n  enter.y = update.y = ifY(orient, pos0, zero);\n  enter.y2 = update.y2 = ifY(orient, pos1);\n\n  return guideMark({\n    type: RuleMark,\n    role: AxisDomainRole,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction position(spec, pos) {\n  return {scale: spec.scale, range: pos};\n}\n","import {getSign, ifX, ifY} from './axis-util';\nimport {Value, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders} from '../encode/util';\nimport {RuleMark} from '../marks/marktypes';\nimport {AxisGridRole} from '../marks/roles';\nimport {isSignal} from '../../util';\nimport {extend, isObject} from 'vega-util';\n\nexport default function(spec, config, userEncode, dataRef, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        vscale = spec.gridScale,\n        sign = getSign(orient, 1, -1),\n        offset = offsetValue(spec.offset, sign);\n\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {opacity: zero},\n    update: update = {opacity: one},\n    exit: exit = {opacity: zero}\n  };\n\n  addEncoders(encode, {\n    stroke:           _('gridColor'),\n    strokeCap:        _('gridCap'),\n    strokeDash:       _('gridDash'),\n    strokeDashOffset: _('gridDashOffset'),\n    strokeOpacity:    _('gridOpacity'),\n    strokeWidth:      _('gridWidth')\n  });\n\n  const tickPos = {\n    scale:  spec.scale,\n    field:  Value,\n    band:   band.band,\n    extra:  band.extra,\n    offset: band.offset,\n    round:  _('tickRound')\n  };\n\n  const sz = ifX(orient, {signal: 'height'}, {signal: 'width'});\n\n  const gridStart = vscale\n    ? {scale: vscale, range: 0, mult: sign, offset: offset}\n    : {value: 0, offset: offset};\n\n  const gridEnd = vscale\n    ? {scale: vscale, range: 1, mult: sign, offset: offset}\n    : extend(sz, {mult: sign, offset: offset});\n\n  enter.x = update.x = ifX(orient, tickPos, gridStart);\n  enter.y = update.y = ifY(orient, tickPos, gridStart);\n  enter.x2 = update.x2 = ifY(orient, gridEnd);\n  enter.y2 = update.y2 = ifX(orient, gridEnd);\n  exit.x = ifX(orient, tickPos);\n  exit.y = ifY(orient, tickPos);\n\n  return guideMark({\n    type: RuleMark,\n    role: AxisGridRole,\n    key:  Value,\n    from: dataRef,\n    encode\n   }, userEncode);\n}\n\nfunction offsetValue(offset, sign)  {\n  if (sign === 1) {\n    // no further adjustment needed, just return offset\n  } else if (!isObject(offset)) {\n    offset = isSignal(sign)\n      ? {signal: `(${sign.signal}) * (${offset || 0})`}\n      : sign * (offset || 0);\n  } else {\n    let entry = offset = extend({}, offset);\n    while (entry.mult != null) {\n      if (!isObject(entry.mult)) {\n        entry.mult = isSignal(sign) // no offset if sign === 1\n          ? {signal: `(${entry.mult}) * (${sign.signal})`}\n          : entry.mult * sign;\n        return offset;\n      } else {\n        entry = entry.mult = extend({}, entry.mult);\n      }\n    }\n    entry.mult = sign;\n  }\n\n  return offset;\n}\n","import {getSign, ifRight, ifTop, ifX, ifY, patch} from './axis-util';\nimport {GuideLabelStyle, Label, Value, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {extendOffset, lookup} from './guide-util';\nimport {addEncoders, encoder} from '../encode/util';\nimport {TextMark} from '../marks/marktypes';\nimport {AxisLabelRole} from '../marks/roles';\nimport {deref} from '../../util';\n\nfunction flushExpr(scale, threshold, a, b, c) {\n  return {\n    signal: 'flush(range(\"' + scale + '\"), '\n      + 'scale(\"' + scale + '\", datum.value), '\n      + threshold + ',' + a + ',' + b + ',' + c + ')'\n  };\n}\n\nexport default function(spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        scale = spec.scale,\n        sign = getSign(orient, -1, 1),\n        flush = deref(_('labelFlush')),\n        flushOffset = deref(_('labelFlushOffset')),\n        labelAlign = _('labelAlign'),\n        labelBaseline = _('labelBaseline');\n\n  let flushOn = flush === 0 || !!flush,\n      update;\n\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n  tickSize.offset = encoder(_('labelPadding') || 0);\n  tickSize.offset.mult = sign;\n\n  const tickPos = {\n    scale:  scale,\n    field:  Value,\n    band:   0.5,\n    offset: extendOffset(band.offset, _('labelOffset'))\n  };\n\n  const align = ifX(orient,\n    flushOn\n      ? flushExpr(scale, flush, '\"left\"', '\"right\"', '\"center\"')\n      : {value: 'center'},\n    ifRight(orient, 'left', 'right')\n  );\n\n  const baseline = ifX(orient,\n    ifTop(orient, 'bottom', 'top'),\n    flushOn\n      ? flushExpr(scale, flush, '\"top\"', '\"bottom\"', '\"middle\"')\n      : {value: 'middle'}\n  );\n\n  const offsetExpr = flushExpr(scale, flush, `-(${flushOffset})`, flushOffset, 0);\n  flushOn = flushOn && flushOffset;\n\n  const enter = {\n    opacity: zero,\n    x: ifX(orient, tickPos, tickSize),\n    y: ifY(orient, tickPos, tickSize)\n  };\n\n  const encode = {\n    enter: enter,\n    update: update = {\n      opacity: one,\n      text: {field: Label},\n      x: enter.x,\n      y: enter.y,\n      align,\n      baseline\n    },\n    exit: {\n      opacity: zero,\n      x: enter.x,\n      y: enter.y\n    }\n  };\n\n  addEncoders(encode, {\n    dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,\n    dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null\n  });\n\n  addEncoders(encode, {\n    angle:       _('labelAngle'),\n    fill:        _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font:        _('labelFont'),\n    fontSize:    _('labelFontSize'),\n    fontWeight:  _('labelFontWeight'),\n    fontStyle:   _('labelFontStyle'),\n    limit:       _('labelLimit'),\n    lineHeight:  _('labelLineHeight')\n  }, {\n    align:       labelAlign,\n    baseline:    labelBaseline\n  });\n\n  const bound   = _('labelBound');\n  let overlap = _('labelOverlap');\n\n  // if overlap method or bound defined, request label overlap removal\n  overlap = overlap || bound ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.index',\n    bound: bound ? {scale, orient, tolerance: bound} : null\n  } : undefined;\n\n  if (update.align !== align) {\n    update.align = patch(update.align, align);\n  }\n  if (update.baseline !== baseline) {\n    update.baseline = patch(update.baseline, baseline);\n  }\n\n  return guideMark({\n    type:  TextMark,\n    role:  AxisLabelRole,\n    style: GuideLabelStyle,\n    key:   Value,\n    from:  dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n","import {getSign, ifTop, ifX, ifY, mult, patch} from './axis-util';\nimport {Bottom, GuideTitleStyle, Top, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {alignExpr, anchorExpr, lookup} from './guide-util';\nimport {addEncoders, encoder, has} from '../encode/util';\nimport {TextMark} from '../marks/marktypes';\nimport {AxisTitleRole} from '../marks/roles';\nimport {extend} from 'vega-util';\n\nexport default function(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        sign = getSign(orient, -1, 1);\n\n  let enter, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      anchor: encoder(_('titleAnchor', null)),\n      align: {signal: alignExpr}\n    },\n    update: update = extend({}, enter, {\n      opacity: one,\n      text: encoder(spec.title)\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n\n  const titlePos = {\n    signal: `lerp(range(\"${spec.scale}\"), ${anchorExpr(0, 1, 0.5)})`\n  };\n\n  update.x = ifX(orient, titlePos);\n  update.y = ifY(orient, titlePos);\n  enter.angle = ifX(orient, zero, mult(sign, 90));\n  enter.baseline = ifX(orient, ifTop(orient, Bottom, Top), {value: Bottom});\n  update.angle = enter.angle;\n  update.baseline = enter.baseline;\n\n  addEncoders(encode, {\n    fill:        _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font:        _('titleFont'),\n    fontSize:    _('titleFontSize'),\n    fontStyle:   _('titleFontStyle'),\n    fontWeight:  _('titleFontWeight'),\n    limit:       _('titleLimit'),\n    lineHeight:  _('titleLineHeight')\n  }, { // require update\n    align:       _('titleAlign'),\n    angle:       _('titleAngle'),\n    baseline:    _('titleBaseline')\n  });\n\n  autoLayout(_, orient, encode, userEncode);\n  encode.update.align = patch(encode.update.align, enter.align);\n  encode.update.angle = patch(encode.update.angle, enter.angle);\n  encode.update.baseline = patch(encode.update.baseline, enter.baseline);\n\n  return guideMark({\n    type:  TextMark,\n    role:  AxisTitleRole,\n    style: GuideTitleStyle,\n    from:  dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction autoLayout(_, orient, encode, userEncode) {\n  const auto = (value, dim) => value != null\n    ? (encode.update[dim] = patch(encoder(value), encode.update[dim]), false)\n    : !has(dim, userEncode) ? true : false;\n\n  const autoY = auto(_('titleX'), 'x'),\n        autoX = auto(_('titleY'), 'y');\n\n  encode.enter.auto = autoX === autoY\n    ? encoder(autoX)\n    : ifX(orient, encoder(autoX), encoder(autoY));\n}\n","import {addEncoders, extendEncode} from './encode/util';\nimport axisConfig from './guides/axis-config';\nimport axisDomain from './guides/axis-domain';\nimport axisGrid from './guides/axis-grid';\nimport axisTicks from './guides/axis-ticks';\nimport axisLabels from './guides/axis-labels';\nimport axisTitle from './guides/axis-title';\nimport {Skip} from './guides/constants';\nimport guideGroup from './guides/guide-group';\nimport {lookup, tickBand} from './guides/guide-util';\nimport {AxisRole} from './marks/roles';\nimport parseMark from './mark';\nimport {AxisTicks, Collect} from '../transforms';\nimport {ref, value} from '../util';\n\nexport default function(spec, scope) {\n  const config = axisConfig(spec, scope),\n        encode = spec.encode || {},\n        axisEncode = encode.axis || {},\n        name = axisEncode.name || undefined,\n        interactive = axisEncode.interactive,\n        style = axisEncode.style,\n        _ = lookup(spec, config),\n        band = tickBand(_);\n\n  // single-element data source for axis group\n  const datum = {\n    scale:  spec.scale,\n    ticks:  !!_('ticks'),\n    labels: !!_('labels'),\n    grid:   !!_('grid'),\n    domain: !!_('domain'),\n    title:  spec.title != null\n  };\n  const dataRef = ref(scope.add(Collect({}, [datum])));\n\n  // data source for axis ticks\n  const ticksRef = ref(scope.add(AxisTicks({\n    scale:   scope.scaleRef(spec.scale),\n    extra:   scope.property(band.extra),\n    count:   scope.objectProperty(spec.tickCount),\n    values:  scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  })));\n\n  // generate axis marks\n  const children = [];\n  let size;\n\n  // include axis gridlines if requested\n  if (datum.grid) {\n    children.push(axisGrid(spec, config, encode.grid, ticksRef, band));\n  }\n\n  // include axis ticks if requested\n  if (datum.ticks) {\n    size = _('tickSize');\n    children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));\n  }\n\n  // include axis labels if requested\n  if (datum.labels) {\n    size = datum.ticks ? size : 0;\n    children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));\n  }\n\n  // include axis domain path if requested\n  if (datum.domain) {\n    children.push(axisDomain(spec, config, encode.domain, dataRef));\n  }\n\n  // include axis title if defined\n  if (datum.title) {\n    children.push(axisTitle(spec, config, encode.title, dataRef));\n  }\n\n  // parse axis specification\n  return parseMark(\n    guideGroup({\n      role:        AxisRole,\n      from:        dataRef,\n      encode:      extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),\n      marks:       children,\n      aria:        _('aria'),\n      description: _('description'),\n      zindex:      _('zindex'),\n      name,\n      interactive,\n      style\n    }),\n    scope\n  );\n}\n\nfunction buildAxisEncode(_, spec) {\n  const encode = {enter: {}, update: {}};\n\n  addEncoders(encode, {\n    orient:       _('orient'),\n    offset:       _('offset') || 0,\n    position:     value(spec.position, 0),\n    titlePadding: _('titlePadding'),\n    minExtent:    _('minExtent'),\n    maxExtent:    _('maxExtent'),\n    range:        {signal: `abs(span(range(\"${spec.scale}\")))`},\n    translate:    _('translate'),\n\n    // accessibility support\n    format:       spec.format,\n    formatType:   spec.formatType\n  });\n\n  return encode;\n}\n","import {getSign, ifX, ifY} from './axis-util';\nimport {Value, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders, encoder} from '../encode/util';\nimport {RuleMark} from '../marks/marktypes';\nimport {AxisTickRole} from '../marks/roles';\n\nexport default function(spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        sign = getSign(orient, -1, 1);\n\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {opacity: zero},\n    update: update = {opacity: one},\n    exit: exit = {opacity: zero}\n  };\n\n  addEncoders(encode, {\n    stroke:           _('tickColor'),\n    strokeCap:        _('tickCap'),\n    strokeDash:       _('tickDash'),\n    strokeDashOffset: _('tickDashOffset'),\n    strokeOpacity:    _('tickOpacity'),\n    strokeWidth:      _('tickWidth')\n  });\n\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n\n  const tickPos = {\n    scale:  spec.scale,\n    field:  Value,\n    band:   band.band,\n    extra:  band.extra,\n    offset: band.offset,\n    round:  _('tickRound')\n  };\n\n  update.y = enter.y = ifX(orient, zero, tickPos);\n  update.y2 = enter.y2 = ifX(orient, tickSize);\n  exit.x = ifX(orient, tickPos);\n\n  update.x = enter.x = ifY(orient, zero, tickPos);\n  update.x2 = enter.x2 = ifY(orient, tickSize);\n  exit.y = ifY(orient, tickPos);\n\n  return guideMark({\n    type: RuleMark,\n    role: AxisTickRole,\n    key:  Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n","import parseSignalUpdates from './signal-updates';\nimport {initScale, parseScale} from './scale';\nimport parseProjection from './projection';\nimport parseLegend from './legend';\nimport parseSignal from './signal';\nimport parseTitle from './title';\nimport parseData from './data';\nimport parseMark from './mark';\nimport parseAxis from './axis';\nimport {array} from 'vega-util';\n\nexport default function(spec, scope, preprocessed) {\n  const signals = array(spec.signals),\n        scales = array(spec.scales);\n\n  // parse signal definitions, if not already preprocessed\n  if (!preprocessed) signals.forEach(_ => parseSignal(_, scope));\n\n  // parse cartographic projection definitions\n  array(spec.projections).forEach(_ => parseProjection(_, scope));\n\n  // initialize scale references\n  scales.forEach(_ => initScale(_, scope));\n\n  // parse data sources\n  array(spec.data).forEach(_ => parseData(_, scope));\n\n  // parse scale definitions\n  scales.forEach(_ => parseScale(_, scope));\n\n  // parse signal updates\n  (preprocessed || signals).forEach(_ => parseSignalUpdates(_, scope));\n\n  // parse axis definitions\n  array(spec.axes).forEach(_ => parseAxis(_, scope));\n\n  // parse mark definitions\n  array(spec.marks).forEach(_ => parseMark(_, scope));\n\n  // parse legend definitions\n  array(spec.legends).forEach(_ => parseLegend(_, scope));\n\n  // parse title, if defined\n  if (spec.title) parseTitle(spec.title, scope);\n\n  // parse collected lambda (anonymous) expressions\n  scope.parseLambdas();\n\n  return scope;\n}\n","import parseAutosize from './autosize';\nimport parsePadding from './padding';\nimport parseEncode from './encode';\nimport parseSignal from './signal';\nimport parseSpec from './scope';\nimport {extendEncode} from './encode/util';\nimport {GroupMark} from './marks/marktypes';\nimport {FrameRole} from './marks/roles';\nimport {operator, ref, value} from '../util';\nimport DataScope from '../DataScope';\nimport {Bound, Collect, Encode, Render, Sieve, ViewLayout} from '../transforms';\nimport {array, extend, hasOwnProperty} from 'vega-util';\n\nconst rootEncode = spec => extendEncode(\n  {\n    enter: {\n      x: {value: 0},\n      y: {value: 0}\n    },\n    update: {\n      width: {signal: 'width'},\n      height: {signal: 'height'}\n    }\n  },\n  spec\n);\n\nexport default function parseView(spec, scope) {\n  const config = scope.config;\n\n  // add scenegraph root\n  const root = ref(scope.root = scope.add(operator()));\n\n  // parse top-level signal definitions\n  const signals = collectSignals(spec, config);\n  signals.forEach(_ => parseSignal(_, scope));\n\n  // assign description, event, legend, and locale configuration\n  scope.description = spec.description || config.description;\n  scope.eventConfig = config.events;\n  scope.legends = scope.objectProperty(config.legend && config.legend.layout);\n  scope.locale = config.locale;\n\n  // store root group item\n  const input = scope.add(Collect());\n\n  // encode root group item\n  const encode = scope.add(Encode(parseEncode(\n    rootEncode(spec.encode), GroupMark, FrameRole,\n    spec.style, scope, {pulse: ref(input)}\n  )));\n\n  // perform view layout\n  const parent = scope.add(ViewLayout({\n    layout:   scope.objectProperty(spec.layout),\n    legends:  scope.legends,\n    autosize: scope.signalRef('autosize'),\n    mark:     root,\n    pulse:    ref(encode)\n  }));\n  scope.operators.pop();\n\n  // parse remainder of specification\n  scope.pushState(ref(encode), ref(parent), null);\n  parseSpec(spec, scope, signals);\n  scope.operators.push(parent);\n\n  // bound / render / sieve root item\n  let op = scope.add(Bound({mark: root, pulse: ref(parent)}));\n  op = scope.add(Render({pulse: ref(op)}));\n  op = scope.add(Sieve({pulse: ref(op)}));\n\n  // track metadata for root item\n  scope.addData('root', new DataScope(scope, input, input, op));\n\n  return scope;\n}\n\nfunction signalObject(name, value) {\n  return value && value.signal\n    ? { name, update: value.signal }\n    : { name, value };\n}\n\n/**\n * Collect top-level signals, merging values as needed. Signals\n * defined in the config signals arrays are added only if that\n * signal is not explicitly defined in the specification.\n * Built-in signals (autosize, background, padding, width, height)\n * receive special treatment. They are initialized using the\n * top-level spec property, or, if undefined in the spec, using\n * the corresponding top-level config property. If this property\n * is a signal reference object, the signal expression maps to the\n * signal 'update' property. If the spec's top-level signal array\n * contains an entry that matches a built-in signal, that entry\n * will be merged with the built-in specification, potentially\n * overwriting existing 'value' or 'update' properties.\n */\nfunction collectSignals(spec, config) {\n  const _ = name => value(spec[name], config[name]),\n        signals = [\n          signalObject('background', _('background')),\n          signalObject('autosize', parseAutosize(_('autosize'))),\n          signalObject('padding', parsePadding(_('padding'))),\n          signalObject('width', _('width') || 0),\n          signalObject('height', _('height') || 0)\n        ],\n        pre = signals.reduce((p, s) => (p[s.name] = s, p), {}),\n        map = {};\n\n  // add spec signal array\n  array(spec.signals).forEach(s => {\n    if (hasOwnProperty(pre, s.name)) {\n      // merge if built-in signal\n      s = extend(pre[s.name], s);\n    } else {\n      // otherwise add to signal list\n      signals.push(s);\n    }\n    map[s.name] = s;\n  });\n\n  // add config signal array\n  array(config.signals).forEach(s => {\n    if (!hasOwnProperty(map, s.name) && !hasOwnProperty(pre, s.name)) {\n      // add to signal list if not already defined\n      signals.push(s);\n    }\n  });\n\n  return signals;\n}\n","import DataScope from './DataScope';\n\nimport {\n  Compare, Expression, Field, Key, Projection, Proxy, Scale, Sieve\n} from './transforms';\n\nimport {\n  Ascending, Entry, aggrField, compareRef, fieldRef, isExpr,\n  isSignal, keyRef, operator, ref\n} from './util';\n\nimport parseScope from './parsers/scope';\nimport {parseExpression} from 'vega-functions';\n\nimport {\n  array, error, extend, hasOwnProperty,\n  isArray, isObject, isString, peek, stringValue\n} from 'vega-util';\n\nexport default function Scope(config, options) {\n  this.config = config || {};\n  this.options = options || {};\n\n  this.bindings = [];\n  this.field = {};\n  this.signals = {};\n  this.lambdas = {};\n  this.scales = {};\n  this.events = {};\n  this.data = {};\n\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this.eventConfig = null;\n  this.locale = null;\n\n  this._id = 0;\n  this._subid = 0;\n  this._nextsub = [0];\n\n  this._parent = [];\n  this._encode = [];\n  this._lookup = [];\n  this._markpath = [];\n}\n\nfunction Subscope(scope) {\n  this.config = scope.config;\n  this.options = scope.options;\n  this.legends = scope.legends;\n\n  this.field = Object.create(scope.field);\n  this.signals = Object.create(scope.signals);\n  this.lambdas = Object.create(scope.lambdas);\n  this.scales = Object.create(scope.scales);\n  this.events = Object.create(scope.events);\n  this.data = Object.create(scope.data);\n\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n\n  this._id = 0;\n  this._subid = ++scope._nextsub[0];\n  this._nextsub = scope._nextsub;\n\n  this._parent = scope._parent.slice();\n  this._encode = scope._encode.slice();\n  this._lookup = scope._lookup.slice();\n  this._markpath = scope._markpath;\n}\n\nScope.prototype = Subscope.prototype = {\n  parse(spec) {\n    return parseScope(spec, this);\n  },\n\n  fork() {\n    return new Subscope(this);\n  },\n\n  isSubscope() {\n    return this._subid > 0;\n  },\n\n  toRuntime() {\n    this.finish();\n    return {\n      description: this.description,\n      operators:   this.operators,\n      streams:     this.streams,\n      updates:     this.updates,\n      bindings:    this.bindings,\n      eventConfig: this.eventConfig,\n      locale:      this.locale\n    };\n  },\n\n  id() {\n    return (this._subid ? this._subid + ':' : 0) + this._id++;\n  },\n\n  add(op) {\n    this.operators.push(op);\n    op.id = this.id();\n    // if pre-registration references exist, resolve them now\n    if (op.refs) {\n      op.refs.forEach(ref => { ref.$ref = op.id; });\n      op.refs = null;\n    }\n    return op;\n  },\n\n  proxy(op) {\n    const vref = op instanceof Entry ? ref(op) : op;\n    return this.add(Proxy({value: vref}));\n  },\n\n  addStream(stream) {\n    this.streams.push(stream);\n    stream.id = this.id();\n    return stream;\n  },\n\n  addUpdate(update) {\n    this.updates.push(update);\n    return update;\n  },\n\n  // Apply metadata\n  finish() {\n    let name, ds;\n\n    // annotate root\n    if (this.root) this.root.root = true;\n\n    // annotate signals\n    for (name in this.signals) {\n      this.signals[name].signal = name;\n    }\n\n    // annotate scales\n    for (name in this.scales) {\n      this.scales[name].scale = name;\n    }\n\n    // annotate data sets\n    function annotate(op, name, type) {\n      let data, list;\n      if (op) {\n        data = op.data || (op.data = {});\n        list = data[name] || (data[name] = []);\n        list.push(type);\n      }\n    }\n    for (name in this.data) {\n      ds = this.data[name];\n      annotate(ds.input,  name, 'input');\n      annotate(ds.output, name, 'output');\n      annotate(ds.values, name, 'values');\n      for (const field in ds.index) {\n        annotate(ds.index[field], name, 'index:' + field);\n      }\n    }\n\n    return this;\n  },\n\n  // ----\n\n  pushState(encode, parent, lookup) {\n    this._encode.push(ref(this.add(Sieve({pulse: encode}))));\n    this._parent.push(parent);\n    this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);\n    this._markpath.push(-1);\n  },\n\n  popState() {\n    this._encode.pop();\n    this._parent.pop();\n    this._lookup.pop();\n    this._markpath.pop();\n  },\n\n  parent() {\n    return peek(this._parent);\n  },\n\n  encode() {\n    return peek(this._encode);\n  },\n\n  lookup() {\n    return peek(this._lookup);\n  },\n\n  markpath() {\n    const p = this._markpath;\n    return ++p[p.length-1];\n  },\n\n  // ----\n\n  fieldRef(field, name) {\n    if (isString(field)) return fieldRef(field, name);\n    if (!field.signal) {\n      error('Unsupported field reference: ' + stringValue(field));\n    }\n\n    const s = field.signal;\n    let f = this.field[s];\n\n    if (!f) {\n      const params = {name: this.signalRef(s)};\n      if (name) params.as = name;\n      this.field[s] = f = ref(this.add(Field(params)));\n    }\n    return f;\n  },\n\n  compareRef(cmp) {\n    let signal = false;\n\n    const check = _ => isSignal(_)\n      ? (signal = true, this.signalRef(_.signal))\n      : isExpr(_) ? (signal = true, this.exprRef(_.expr))\n      : _;\n\n    const fields = array(cmp.field).map(check),\n          orders = array(cmp.order).map(check);\n\n    return signal\n      ? ref(this.add(Compare({fields: fields, orders: orders})))\n      : compareRef(fields, orders);\n  },\n\n  keyRef(fields, flat) {\n    let signal = false;\n\n    const check = _ => isSignal(_)\n      ? (signal = true, ref(sig[_.signal]))\n      : _;\n\n    const sig = this.signals;\n    fields = array(fields).map(check);\n\n    return signal\n      ? ref(this.add(Key({fields: fields, flat: flat})))\n      : keyRef(fields, flat);\n  },\n\n  sortRef(sort) {\n    if (!sort) return sort;\n\n    // including id ensures stable sorting\n    const a = aggrField(sort.op, sort.field),\n         o = sort.order || Ascending;\n\n    return o.signal\n      ? ref(this.add(Compare({\n          fields: a,\n          orders: this.signalRef(o.signal)\n        })))\n      : compareRef(a, o);\n  },\n\n  // ----\n\n  event(source, type) {\n    const key = source + ':' + type;\n    if (!this.events[key]) {\n      const id = this.id();\n      this.streams.push({\n        id: id,\n        source: source,\n        type: type\n      });\n      this.events[key] = id;\n    }\n    return this.events[key];\n  },\n\n  // ----\n\n  hasOwnSignal(name) {\n    return hasOwnProperty(this.signals, name);\n  },\n\n  addSignal(name, value) {\n    if (this.hasOwnSignal(name)) {\n      error('Duplicate signal name: ' + stringValue(name));\n    }\n    const op = value instanceof Entry ? value : this.add(operator(value));\n    return this.signals[name] = op;\n  },\n\n  getSignal(name) {\n    if (!this.signals[name]) {\n      error('Unrecognized signal name: ' + stringValue(name));\n    }\n    return this.signals[name];\n  },\n\n  signalRef(s) {\n    if (this.signals[s]) {\n      return ref(this.signals[s]);\n    } else if (!hasOwnProperty(this.lambdas, s)) {\n      this.lambdas[s] = this.add(operator(null));\n    }\n    return ref(this.lambdas[s]);\n  },\n\n  parseLambdas() {\n    const code = Object.keys(this.lambdas);\n    for (let i=0, n=code.length; i<n; ++i) {\n      const s = code[i],\n            e = parseExpression(s, this),\n            op = this.lambdas[s];\n      op.params = e.$params;\n      op.update = e.$expr;\n    }\n  },\n\n  property(spec) {\n    return spec && spec.signal ? this.signalRef(spec.signal) : spec;\n  },\n\n  objectProperty(spec) {\n    return (!spec || !isObject(spec)) ? spec\n      : this.signalRef(spec.signal || propertyLambda(spec));\n  },\n\n  exprRef(code, name) {\n    const params = {expr: parseExpression(code, this)};\n    if (name) params.expr.$name = name;\n    return ref(this.add(Expression(params)));\n  },\n\n  addBinding(name, bind) {\n    if (!this.bindings) {\n      error('Nested signals do not support binding: ' + stringValue(name));\n    }\n    this.bindings.push(extend({signal: name}, bind));\n  },\n\n  // ----\n\n  addScaleProj(name, transform) {\n    if (hasOwnProperty(this.scales, name)) {\n      error('Duplicate scale or projection name: ' + stringValue(name));\n    }\n    this.scales[name] = this.add(transform);\n  },\n\n  addScale(name, params) {\n    this.addScaleProj(name, Scale(params));\n  },\n\n  addProjection(name, params) {\n    this.addScaleProj(name, Projection(params));\n  },\n\n  getScale(name) {\n    if (!this.scales[name]) {\n      error('Unrecognized scale name: ' + stringValue(name));\n    }\n    return this.scales[name];\n  },\n\n  scaleRef(name) {\n    return ref(this.getScale(name));\n  },\n\n  scaleType(name) {\n    return this.getScale(name).params.type;\n  },\n\n  projectionRef(name) {\n    return this.scaleRef(name);\n  },\n\n  projectionType(name) {\n    return this.scaleType(name);\n  },\n\n  // ----\n\n  addData(name, dataScope) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n    return (this.data[name] = dataScope);\n  },\n\n  getData(name) {\n    if (!this.data[name]) {\n      error('Undefined data set name: ' + stringValue(name));\n    }\n    return this.data[name];\n  },\n\n  addDataPipeline(name, entries) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n    return this.addData(name, DataScope.fromEntries(this, entries));\n  }\n};\n\nfunction propertyLambda(spec) {\n  return (isArray(spec) ? arrayLambda : objectLambda)(spec);\n}\n\nfunction arrayLambda(array) {\n  const n = array.length;\n  let code = '[';\n\n  for (let i = 0; i<n; ++i) {\n    const value = array[i];\n    code += (i > 0 ? ',' : '')\n      + (isObject(value)\n        ? (value.signal || propertyLambda(value))\n        : stringValue(value));\n  }\n  return code + ']';\n}\n\nfunction objectLambda(obj) {\n  let code = '{',\n      i = 0,\n      key, value;\n\n  for (key in obj) {\n    value = obj[key];\n    code += (++i > 1 ? ',' : '')\n      + stringValue(key) + ':'\n      + (isObject(value)\n        ? (value.signal || propertyLambda(value))\n        : stringValue(value));\n  }\n  return code + '}';\n}\n","/**\n * Standard configuration defaults for Vega specification parsing.\n * Users can provide their own (sub-)set of these default values\n * by passing in a config object to the top-level parse method.\n */\nexport default function() {\n  const defaultFont = 'sans-serif',\n        defaultSymbolSize = 30,\n        defaultStrokeWidth = 2,\n        defaultColor = '#4c78a8',\n        black = '#000',\n        gray = '#888',\n        lightGray = '#ddd';\n\n  return {\n    // default visualization description\n    description: 'Vega visualization',\n\n    // default padding around visualization\n    padding: 0,\n\n    // default for automatic sizing; options: 'none', 'pad', 'fit'\n    // or provide an object (e.g., {'type': 'pad', 'resize': true})\n    autosize: 'pad',\n\n    // default view background color\n    // covers the entire view component\n    background: null,\n\n    // default event handling configuration\n    // preventDefault for view-sourced event types except 'wheel'\n    events: {\n      defaults: {allow: ['wheel']}\n    },\n\n    // defaults for top-level group marks\n    // accepts mark properties (fill, stroke, etc)\n    // covers the data rectangle within group width/height\n    group: null,\n\n    // defaults for basic mark types\n    // each subset accepts mark properties (fill, stroke, etc)\n    mark: null,\n    arc: {\n      fill: defaultColor\n    },\n    area: {\n      fill: defaultColor\n    },\n    image: null,\n    line: {\n      stroke: defaultColor,\n      strokeWidth: defaultStrokeWidth\n    },\n    path: {\n      stroke: defaultColor\n    },\n    rect: {\n      fill: defaultColor\n    },\n    rule: {\n      stroke: black\n    },\n    shape: {\n      stroke: defaultColor\n    },\n    symbol: {\n      fill: defaultColor,\n      size: 64\n    },\n    text: {\n      fill: black,\n      font: defaultFont,\n      fontSize: 11\n    },\n    trail: {\n      fill: defaultColor,\n      size: defaultStrokeWidth\n    },\n\n    // style definitions\n    style: {\n      // axis & legend labels\n      'guide-label': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 10\n      },\n      // axis & legend titles\n      'guide-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 11,\n        fontWeight: 'bold'\n      },\n      // headers, including chart title\n      'group-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 13,\n        fontWeight: 'bold'\n      },\n      // chart subtitle\n      'group-subtitle': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 12\n      },\n      // defaults for styled point marks in Vega-Lite\n      point: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'circle'\n      },\n      circle: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth\n      },\n      square: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'square'\n      },\n      // defaults for styled group marks in Vega-Lite\n      cell: {\n        fill: 'transparent',\n        stroke: lightGray\n      },\n      view: {\n        fill: 'transparent'\n      }\n    },\n\n    // defaults for title\n    title: {\n      orient: 'top',\n      anchor: 'middle',\n      offset: 4,\n      subtitlePadding: 3\n    },\n\n    // defaults for axes\n    axis: {\n      minExtent: 0,\n      maxExtent: 200,\n      bandPosition: 0.5,\n      domain: true,\n      domainWidth: 1,\n      domainColor: gray,\n      grid: false,\n      gridWidth: 1,\n      gridColor: lightGray,\n      labels: true,\n      labelAngle: 0,\n      labelLimit: 180,\n      labelOffset: 0,\n      labelPadding: 2,\n      ticks: true,\n      tickColor: gray,\n      tickOffset: 0,\n      tickRound: true,\n      tickSize: 5,\n      tickWidth: 1,\n      titlePadding: 4\n    },\n\n    // correction for centering bias\n    axisBand: {\n      tickOffset: -0.5\n    },\n\n    // defaults for cartographic projection\n    projection: {\n      type: 'mercator'\n    },\n\n    // defaults for legends\n    legend: {\n      orient: 'right',\n      padding: 0,\n      gridAlign: 'each',\n      columnPadding: 10,\n      rowPadding: 2,\n      symbolDirection: 'vertical',\n      gradientDirection: 'vertical',\n      gradientLength: 200,\n      gradientThickness: 16,\n      gradientStrokeColor: lightGray,\n      gradientStrokeWidth: 0,\n      gradientLabelOffset: 2,\n      labelAlign: 'left',\n      labelBaseline: 'middle',\n      labelLimit: 160,\n      labelOffset: 4,\n      labelOverlap: true,\n      symbolLimit: 30,\n      symbolType: 'circle',\n      symbolSize: 100,\n      symbolOffset: 0,\n      symbolStrokeWidth: 1.5,\n      symbolBaseFillColor: 'transparent',\n      symbolBaseStrokeColor: gray,\n      titleLimit: 180,\n      titleOrient: 'top',\n      titlePadding: 5,\n      layout: {\n        offset: 18,\n        direction: 'horizontal',\n        left:   { direction: 'vertical' },\n        right:  { direction: 'vertical' }\n      }\n    },\n\n    // defaults for scale ranges\n    range: {\n      category: {\n        scheme: 'tableau10'\n      },\n      ordinal: {\n        scheme: 'blues'\n      },\n      heatmap: {\n        scheme: 'yellowgreenblue'\n      },\n      ramp: {\n        scheme: 'blues'\n      },\n      diverging: {\n        scheme: 'blueorange',\n        extent: [1, 0]\n      },\n      symbol: [\n        'circle',\n        'square',\n        'triangle-up',\n        'cross',\n        'diamond',\n        'triangle-right',\n        'triangle-down',\n        'triangle-left'\n      ]\n    }\n  };\n}\n","import parseView from './parsers/view';\nimport Scope from './Scope';\nimport defaults from './config';\nimport {error, isObject, mergeConfig} from 'vega-util';\n\nexport default function(spec, config, options) {\n  if (!isObject(spec)) {\n    error('Input Vega specification must be an object.');\n  }\n\n  config = mergeConfig(defaults(), config, spec.config);\n  return parseView(spec, new Scope(config, options)).toRuntime();\n}\n"],"names":["parseAutosize","spec","isObject","type","number","_","paddingObject","top","bottom","left","right","parsePadding","signal","encoder","isArray","extend","value","addEncode","object","name","set","length","update","addEncoders","enter","extendEncode","encode","extra","skip","hasOwnProperty","has","key","MarkRole","FrameRole","ScopeRole","AxisRole","AxisDomainRole","AxisGridRole","AxisLabelRole","AxisTickRole","AxisTitleRole","LegendRole","LegendBandRole","LegendEntryRole","LegendGradientRole","LegendLabelRole","LegendSymbolRole","LegendTitleRole","TitleRole","TitleTextRole","TitleSubtitleRole","applyDefault","defaults","scaleRef","scale","isString","stringValue","field","entry","enc","gradient","args","start","stop","count","map","peek","pop","unshift","join","color","c","_color","h","l","s","a","b","r","g","undefined","range","band","property","exponent","mult","offset","round","x","y","z","ref","resolveField","datum","level","group","parent","Math","max","error","splitAccessPath","parseEncode","role","style","scope","params","encoders","$encode","config","props","String","startsWith","mark","array","forEach","applyDefaults","parseBlock","block","marktype","channels","fields","parse","code","rule","test","$expr","$fields","Object","keys","$output","expr","parseExpression","$params","OUTER","OUTER_INVALID","outerError","prefix","parseSignal","push","signals","prop","op","addSignal","react","bind","addBinding","Entry","this","id","operator","$ref","refs","fieldRef","$field","$name","keyFieldRef","compareRef","orders","$compare","$order","Descending","aggrField","Scope","View","isSignal","hasSignal","specValue","defaultValue","deref","v","Timer","parseStream","stream","merge","mergeStream","nestedStream","eventStream","streamParameters","addStream","source","event","throttle","between","filter","param","concat","markname","markrole","item","filterMark","debounce","consume","OP_VALUE_EXPR","ast","parseUpdate","target","events","sources","parseSelector","isSubscope","mergeSources","$value","signalRef","force","options","addUpdate","streamSource","parseSignalUpdates","getSignal","init","initonly","on","transform","Aggregate","AxisTicks","Bound","Collect","Compare","DataJoin","Encode","Expression","Facet","Field","Key","LegendEntries","Load","Mark","MultiExtent","MultiValues","Overlap","Params","PreFacet","Projection","Proxy","Relay","Render","Scale","Sieve","SortItems","ViewLayout","Values","FIELD_REF_ID","MULTIDOMAIN_SORT_OPS","min","parseScale","getScale","nice","domain","parseScaleDomain","parseScaleRange","interpolate","parseLiteral","gamma","interpolateGamma","parseScaleInterpolate","interval","step","bins","parseArray","objectProperty","parseScaleBins","dataLookupError","explicitDomain","multipleDomain","singularDomain","domainMin","domainMax","data","getData","isDiscrete","valuesRef","parseSort","sort","isQuantile","domainRef","extentRef","reduce","dom","d","coll","$ingest","input","addDataPipeline","ordinalMultipleDomain","quantileMultipleDomain","numericMultipleDomain","counts","f","countsRef","p","groupby","pulse","ops","as","add","sortRef","multidomain","values","extents","scheme","extent","schemeExtent","schemeCount","rangeStep","parseParameter","Top","Left","Right","Bottom","Center","Vertical","Start","End","Index","Label","Offset","Perc","Perc2","Value","GuideLabelStyle","GuideTitleStyle","GroupTitleStyle","GroupSubtitleStyle","Symbols","Gradient","Discrete","Size","LegendScales","Skip","interactive","zero","one","GroupMark","RectMark","RuleMark","SymbolMark","TextMark","guideGroup","lookup","dflt","isVertical","direction","symbolDirection","gradientDirection","gradientLength","gradientWidth","gradientThickness","gradientHeight","entryColumns","columns","getEncoding","anchorExpr","e","m","alignExpr","extendOffset","assign","guideMark","extras","legendGradient","userEncode","vertical","thickness","width","height","opacity","fill","exit","stroke","strokeWidth","legendGradientDiscrete","dataRef","u","uu","vv","adjust","from","baselineExpr","legendGradientLabels","overlap","text","fillOpacity","font","fontSize","fontStyle","fontWeight","limit","labelLimit","gradientLabelLimit","align","baseline","labelOffset","gradientLabelOffset","separation","method","order","legendSymbolGroups","entries","symbolOffset","valueRef","xSignal","yEncode","index","ncols","nrows","baseFill","baseStroke","symbolBaseFillColor","symbolBaseStrokeColor","shape","size","strokeDash","strokeDashOffset","symbols","clip","labels","noBound","row","column","facet","marks","isL","isR","isLR","isVG","exprAlign","exprAnchor","exprAngle","exprBaseline","path","sphere","getRole","indexOf","definition","zindex","aria","description","parseTransform","def","t","toLowerCase","parseParameters","proxy","metadata","n","i","pdef","lookupRef","parseIndexParameter","parseSubParameter","parseSubParameters","projectionRef","parameterValue","required","isExpr","isField","isCompare","outerExpr","exprRef","outerField","isData","k","getDataRef","output","DataScope","aggr","aggregate","fieldKey","addSortField","cache","ds","optype","sortKey","parseTrigger","remove","insert","toggle","modify","trigger","parseMark","store","layoutRef","boundRef","layout","nested","keyRef","parseData","clean","joinRef","markdef","context","$context","groups","markpath","markRef","mod","tx","md","generates","changes","nomod","encodeRef","legends","bound","operators","pushState","subscope","fork","addData","subflow","$subflow","toRuntime","parseFacet","parseSubflow","popState","sep","tol","tolerance","boundTolerance","boundScale","boundOrient","orient","parseOverlap","render","sieve","parseLegend","legend","legendEncode","scales","entryLayout","children","scaleType","scaleCount","isContinuous","isDiscretizing","legendType","title","vgrad","entryRef","minstep","tickMinStep","formatType","formatSpecifier","format","center","padding","legendSymbolLayout","getChannel","getStyle","getFontSize","sizeExpression","_anchor","anchor","angle","lineHeight","legendTitle","buildLegendEncode","titlePadding","cornerRadius","fromEntries","prototype","agg","tuplesRef","indataRef","angleExpr","parseTitle","dx","dy","buildTitle","titleEncode","subtitle","buildSubTitle","groupEncode","frame","transforms","upstream","generate","load","collect","$format","url","$request","modifies","derive","splice","analyze","async","isX","getSign","ifLeftTopExpr","ifX","ifXEnc","ifY","ifYEnc","ifTop","ifTopExpr","ifRight","ifRightExpr","$orient","ifEnc","ifExpr","isSimple","toExpr","ifOrient","sign","patch","base","endsWith","slice","fallback","axisConfig","styleProp","objects","obj","position","pos","axisGrid","vscale","gridScale","offsetValue","strokeCap","strokeOpacity","tickPos","sz","gridStart","gridEnd","x2","y2","flushExpr","threshold","axisTitle","titlePos","auto","dim","autoY","autoX","autoLayout","parseAxis","xy","or","axis","axisBand","xyKeys","axisX","axisY","orientKeys","axisTop","axisBottom","axisLeft","axisRight","toUpperCase","axisEncode","tickBand","ticks","grid","ticksRef","tickCount","tickSize","axisTicks","flush","flushOffset","labelAlign","labelBaseline","flushOn","offsetExpr","axisLabels","pos0","pos1","axisDomain","buildAxisEncode","minExtent","maxExtent","translate","parseScope","preprocessed","projections","proj","projection","addProjection","parseProjection","isValidScaleType","addScale","initScale","axes","parseLambdas","rootEncode","parseView","root","signalObject","pre","collectSignals","eventConfig","locale","autosize","parseSpec","bindings","lambdas","streams","updates","_id","_subid","_nextsub","_parent","_encode","_lookup","_markpath","Subscope","create","propertyLambda","arrayLambda","objectLambda","defaultFont","defaultColor","black","gray","lightGray","background","allow","arc","area","image","line","rect","symbol","trail","point","circle","square","cell","view","subtitlePadding","bandPosition","domainWidth","domainColor","gridWidth","gridColor","labelAngle","labelPadding","tickColor","tickOffset","tickRound","tickWidth","gridAlign","columnPadding","rowPadding","gradientStrokeColor","gradientStrokeWidth","labelOverlap","symbolLimit","symbolType","symbolSize","symbolStrokeWidth","titleLimit","titleOrient","category","ordinal","heatmap","ramp","diverging","finish","vref","annotate","list","cmp","check","flat","sig","$key","$flat","o","hasOwnSignal","addScaleProj","projectionType","dataScope","mergeConfig"],"mappings":"seAEe,SAAAA,EAASC,GACtB,OAAOC,EAAQA,SAACD,GAAQA,EAAO,CAACE,KAAMF,GAAQ,MAChD,CCFA,MAAMG,EAASC,IAAMA,GAAK,EAEpBC,EAAgBD,IAAM,CAACE,IAAKF,EAAGG,OAAQH,EAAGI,KAAMJ,EAAGK,MAAOL,IAEjD,SAAAM,EAASV,GACtB,OAAQC,EAAQA,SAACD,GACbA,EAAKW,OAASX,EACd,CACEM,IAAQH,EAAOH,EAAKM,KACpBC,OAAQJ,EAAOH,EAAKO,QACpBC,KAAQL,EAAOH,EAAKQ,MACpBC,MAAQN,EAAOH,EAAKS,QANDJ,EAAcF,EAAOH,GAQhD,CCbO,MAAMY,EAAUR,GAAKH,WAASG,KAAOS,UAAQT,GAChDU,EAAAA,OAAO,CAAE,EAAEV,GACX,CAACW,MAAOX,GAEL,SAASY,EAAUC,EAAQC,EAAMH,EAAOI,GAC7C,GAAa,MAATJ,EAAe,CAYjB,OAVGd,EAAAA,SAASc,KAAWF,EAAAA,QAAQE,IAC5BF,EAAAA,QAAQE,IAAUA,EAAMK,QAAUnB,EAAQA,SAACc,EAAM,IAKlDE,EAAOI,OAAOH,GAAQH,EAEtBE,EAAOE,GAAO,SAASD,GAAQ,CAACH,MAAOA,GAElC,CACT,CACE,OAAO,CAEX,CAEO,SAASO,EAAYL,EAAQM,EAAOF,GACzC,IAAK,MAAMH,KAAQK,EACjBP,EAAUC,EAAQC,EAAMK,EAAML,IAEhC,IAAK,MAAMA,KAAQG,EACjBL,EAAUC,EAAQC,EAAMG,EAAOH,GAAO,SAE1C,CAEO,SAASM,EAAaC,EAAQC,EAAOC,GAC1C,IAAK,MAAMT,KAAQQ,EACbC,GAAQC,EAAcA,eAACD,EAAMT,KACjCO,EAAOP,GAAQJ,EAAAA,OAAOW,EAAOP,IAAS,GAAIQ,EAAMR,KAElD,OAAOO,CACT,CAEO,SAASI,EAAIC,EAAKL,GACvB,OAAOA,IACJA,EAAOF,OAASE,EAAOF,MAAMO,IAC7BL,EAAOJ,QAAUI,EAAOJ,OAAOS,GAEpC,CC/CaC,MAAAA,EAAW,OACXC,EAAY,QACZC,EAAY,QAEZC,EAAW,OACXC,EAAiB,cACjBC,EAAe,YACfC,EAAgB,aAChBC,EAAe,YACfC,EAAgB,aAEhBC,EAAa,SACbC,EAAiB,cACjBC,EAAkB,eAClBC,EAAqB,kBACrBC,EAAkB,eAClBC,EAAmB,gBACnBC,EAAkB,eAElBC,EAAY,QACZC,EAAgB,aAChBC,EAAoB,iBCsCjC,SAASC,EAAaC,EAAUrB,EAAKf,GACnCoC,EAASrB,GAAOf,GAASA,EAAMJ,OAC3B,CAACA,OAAQI,EAAMJ,QACf,CAACI,MAAOA,EACd,CC7DA,MAAMqC,EAAWC,GAASC,WAASD,GAASE,EAAWA,YAACF,GACpDA,EAAM1C,OAAU,IAAG0C,EAAM1C,UACzB6C,EAAMH,GAEK,SAASI,EAAMC,GAC5B,GAAoB,MAAhBA,EAAIC,SACN,OA+CJ,SAAkBD,GAEhB,MAAME,EAAO,CAACF,EAAIG,MAAOH,EAAII,KAAMJ,EAAIK,OACpCC,KAAI5D,GAAU,MAALA,EAAY,KAAOmD,EAAWA,YAACnD,KAG3C,KAAOwD,EAAKxC,QAAwB,MAAd6C,OAAKL,IAAeA,EAAKM,MAG/C,OADAN,EAAKO,QAAQf,EAASM,EAAIC,WAClB,YAAWC,EAAKQ,KAAK,OAC/B,CAzDWT,CAASD,GAGlB,IAAI3C,EAAQ2C,EAAI/C,OAAU,IAAG+C,EAAI/C,UAC7B+C,EAAIW,MAmCV,SAAeX,GACb,OAAQA,EAAIY,EAAKC,EAAO,MAAOb,EAAIc,EAAGd,EAAIY,EAAGZ,EAAIe,GAC5Cf,EAAIc,GAAKd,EAAIgB,EAAKH,EAAO,MAAOb,EAAIc,EAAGd,EAAIgB,EAAGhB,EAAIe,GAClDf,EAAIe,GAAKf,EAAIiB,EAAKJ,EAAO,MAAOb,EAAIe,EAAGf,EAAIiB,EAAGjB,EAAIkB,GAClDlB,EAAImB,GAAKnB,EAAIoB,GAAKpB,EAAIkB,EAAKL,EAAO,MAAOb,EAAImB,EAAGnB,EAAIoB,EAAGpB,EAAIkB,GAC5D,IACN,CAzCkBP,CAAMX,EAAIW,OACT,MAAbX,EAAIF,MAAgBA,EAAME,EAAIF,YAChBuB,IAAdrB,EAAI3C,MAAsBwC,EAAWA,YAACG,EAAI3C,YAC1CgE,EA0BJ,OAxBiB,MAAbrB,EAAIL,QACNtC,EA6FJ,SAAe2C,EAAK3C,GAClB,MAAMsC,EAAQD,EAASM,EAAIL,OAEV,MAAbK,EAAIsB,MAENjE,EAAS,eAAcsC,QAAYK,EAAIsB,eAGzBD,IAAVhE,IAAqBA,EAAS,UAASsC,MAAUtC,MAEjD2C,EAAIuB,OACNlE,GAASA,EAAQA,EAAQ,IAAM,IAC1B,cAAasC,MACC,IAAbK,EAAIuB,KAAa,GAAK,IAAMC,EAASxB,EAAIuB,OAE3CvB,EAAIhC,QAENX,EAAS,yBAAwBsC,2BAA+BtC,OAIvD,MAATA,IAAeA,EAAQ,MAG7B,OAAOA,CACT,CAtHYsC,CAAMK,EAAK3C,SAGPgE,IAAVhE,IACFA,EAAQ,MAGU,MAAhB2C,EAAIyB,WACNpE,EAAS,OAAMA,KAASmE,EAASxB,EAAIyB,cAGvB,MAAZzB,EAAI0B,OACNrE,GAAU,IAAGmE,EAASxB,EAAI0B,SAGV,MAAd1B,EAAI2B,SACNtE,GAAU,IAAGmE,EAASxB,EAAI2B,WAGxB3B,EAAI4B,QACNvE,EAAS,SAAQA,MAGZA,CACT,CAEA,MAAMwD,EAASA,CAACrE,EAAMqF,EAAGC,EAAGC,IACzB,IAAGvF,KAAQ,CAACqF,EAAGC,EAAGC,GAAGzB,IAAIP,GAAOW,KAAK,YAsBxC,SAASc,EAASA,GAChB,OAAOjF,EAAQA,SAACiF,GAAY,IAAMzB,EAAMyB,GAAY,IAAMA,CAC5D,CAEA,SAAS1B,EAAMkC,GACb,OAAOC,EAAa1F,EAAAA,SAASyF,GAAOA,EAAM,CAACE,MAAOF,GACpD,CAEA,SAASC,EAAaD,GACpB,IAAIzE,EAAQ4E,EAAOrC,EAEnB,GAAIkC,EAAI/E,OACNM,EAAS,QACTuC,EAAQkC,EAAI/E,YACP,GAAI+E,EAAII,OAASJ,EAAIK,OAAQ,CAIlC,IAHAF,EAAQG,KAAKC,IAAI,EAAGP,EAAIG,OAAS,GACjC5E,EAAS,OAEF4E,KAAU,GACf5E,GAAU,cAGRyE,EAAIK,QACNvC,EAAQkC,EAAIK,OACZ9E,GAAU,UAEVuC,EAAQkC,EAAII,KAEhB,MAAWJ,EAAIE,OACb3E,EAAS,QACTuC,EAAQkC,EAAIE,OAEZM,EAAAA,MAAM,4BAA8B3C,cAAYmC,IASlD,OANKA,EAAI/E,SACP6C,EAAQF,EAAAA,SAASE,GACb2C,EAAeA,gBAAC3C,GAAOQ,IAAIT,EAAWA,aAAEa,KAAK,MAC7CuB,EAAanC,IAGZvC,EAAS,IAAMuC,EAAQ,GAChC,CCtGe,SAAA4C,EAAS3E,EAAQvB,EAAMmG,EAAMC,EAAOC,EAAOC,GACxD,MAAM9C,EAAM,CAAA,GACZ8C,EAASA,GAAU,IACZC,SAAW,CAACC,QAAShD,GAE5BjC,EFRa,SAASA,EAAQvB,EAAMmG,EAAMC,EAAOK,GACjD,MAAMxD,EAAW,CAAE,EAAE5B,EAAQ,CAAA,EAC7B,IAAIF,EAAQS,EAAKH,EAAMiF,EAkBvB,IAAK9E,KAfLA,EAAM,YACO,SAAT5B,GAAkC,MAAfyG,EAAO7E,IAAiBD,EAAIC,EAAKL,IACtDyB,EAAaC,EAAUrB,EAAK6E,EAAO7E,KAIzB,UAARuE,GAAoBQ,OAAOR,GAAMS,WAAW,WAC9CT,EAAO,MAITO,EAAQP,IAASrE,EAAY2E,EAAOb,MAC/BO,IAAStE,EAAYjB,EAAMA,OAAC,CAAE,EAAE6F,EAAOI,KAAMJ,EAAOzG,IACrD,KAEQ0G,EAEVjF,EAAOE,EAAIC,EAAKL,KACF,SAARK,GAA0B,WAARA,KAClBD,EAAI,OAAQJ,IAAWI,EAAI,SAAUJ,IAEtCE,GAAMuB,EAAaC,EAAUrB,EAAK8E,EAAM9E,IAc/C,IAAKA,KAVLkF,EAAAA,MAAMV,GAAOW,SAAQ/F,IACnB,MAAM0F,EAAQD,EAAOL,OAASK,EAAOL,MAAMpF,GAC3C,IAAK,MAAMY,KAAO8E,EACX/E,EAAIC,EAAKL,IACZyB,EAAaC,EAAUrB,EAAK8E,EAAM9E,GAEtC,IAGFL,EAASX,EAAMA,OAAC,GAAIW,GACR0B,EACVyD,EAAQzD,EAASrB,GACb8E,EAAMjG,QACPU,EAASA,GAAU,CAAE,GAAES,GAAO8E,EAE/BrF,EAAMO,GAAO8E,EAOjB,OAHAnF,EAAOF,MAAQT,EAAMA,OAACS,EAAOE,EAAOF,OAChCF,IAAQI,EAAOJ,OAASP,EAAMA,OAACO,EAAQI,EAAOJ,SAE3CI,CACT,CE7CWyF,CAAczF,EAAQvB,EAAMmG,EAAMC,EAAOC,EAAMI,QACxD,IAAK,MAAM7E,KAAOL,EAChBiC,EAAI5B,GAAOqF,EAAW1F,EAAOK,GAAM5B,EAAMsG,EAAQD,GAGnD,OAAOC,CACT,CAEA,SAASW,EAAWC,EAAOC,EAAUb,EAAQD,GAC3C,MAAMe,EAAW,CAAE,EACbC,EAAS,CAAA,EAEf,IAAK,MAAMrG,KAAQkG,EACE,MAAfA,EAAMlG,KACRoG,EAASpG,GAAQsG,GAWT9D,EAXoB0D,EAAMlG,GAY/BL,EAAAA,QAAQ6C,GCnCF,SAASA,GACtB,IAAI+D,EAAO,GAYX,OAVA/D,EAAIuD,SAAQS,IACV,MAAM3G,EAAQ0C,EAAMiE,GACpBD,GAAQC,EAAKC,KAAQ,IAAGD,EAAKC,SAAS5G,KAAWA,CAAK,IAIrC,MAAfkD,EAAIA,KAACwD,KACPA,GAAQ,QAGHA,CACT,CDqBwBC,CAAKhE,GAAOD,EAAMC,IAZM6C,EAAOC,EAAQe,IAW/D,IAAc7D,EAPZ,MAAO,CACLkE,MAAS,CAACP,WAAUC,YACpBO,QAASC,OAAOC,KAAKR,GACrBS,QAASF,OAAOC,KAAKX,GAEzB,CAMA,SAASI,EAAMC,EAAMlB,EAAOC,EAAQe,GAClC,MAAMU,EAAOC,EAAAA,gBAAgBT,EAAMlB,GAGnC,OAFA0B,EAAKJ,QAAQZ,SAAQ/F,GAAQqG,EAAOrG,GAAQ,IAC5CJ,EAAAA,OAAO0F,EAAQyB,EAAKE,SACbF,EAAKL,KACd,CE5CA,MAAMQ,EAAQ,QACRC,EAAgB,CAAC,QAAS,SAAU,OAAQ,QAAS,QAE3D,SAASC,EAAWC,EAAQrH,GAC1BgF,EAAAA,MAAMqC,EAAS,sBAAwBhF,EAAAA,YAAYrC,GACrD,CAEe,SAAAsH,EAAS7H,EAAQ4F,GAC9B,MAAMrF,EAAOP,EAAOO,KAEpB,GAAIP,EAAO8H,OAASL,EAEb7B,EAAMmC,QAAQxH,IAAOoH,EAAW,6BAA8BpH,GAEnEmH,EAAcpB,SAAQ0B,SACC5D,IAAjBpE,EAAOgI,IAAqBL,EAAW,oBAAqBK,EAAK,QAElE,CAEL,MAAMC,EAAKrC,EAAMsC,UAAU3H,EAAMP,EAAOI,QACnB,IAAjBJ,EAAOmI,QAAiBF,EAAGE,OAAQ,GACnCnI,EAAOoI,MAAMxC,EAAMyC,WAAW9H,EAAMP,EAAOoI,KACjD,CACF,CCvBO,SAASE,EAAM/I,EAAMa,EAAOyF,EAAQT,GACzCmD,KAAKC,IAAM,EACXD,KAAKhJ,KAAOA,EACZgJ,KAAKnI,MAAQA,EACbmI,KAAK1C,OAASA,EACVT,IAAQmD,KAAKnD,OAASA,EAC5B,CAEO,SAAStC,EAAMvD,EAAMa,EAAOyF,EAAQT,GACzC,OAAO,IAAIkD,EAAM/I,EAAMa,EAAOyF,EAAQT,EACxC,CAEO,SAASqD,EAASrI,EAAOyF,GAC9B,OAAO/C,EAAM,WAAY1C,EAAOyF,EAClC,CAIO,SAASd,EAAIkD,GAClB,MAAMlD,EAAM,CAAC2D,KAAMT,EAAGO,IAGtB,OADIP,EAAGO,GAAK,IAAIP,EAAGU,KAAOV,EAAGU,MAAQ,IAAIb,KAAK/C,GACvCA,CACT,CAOO,SAAS6D,EAAS/F,EAAOtC,GAC9B,OAAOA,EAAO,CAACsI,OAAQhG,EAAOiG,MAAOvI,GAAQ,CAACsI,OAAQhG,EACxD,CAEO,MAAMkG,EAAcH,EAAS,OAE7B,SAASI,GAAWpC,EAAQqC,GACjC,MAAO,CAACC,SAAUtC,EAAQuC,OAAQF,EACpC,CAUO,MAEMG,GAAa,aAQnB,SAASC,GAAUpB,EAAIpF,GAC5B,OAAQoF,GAAMA,EAAGjI,OAAS,IAAMiI,EAAGjI,OAASiI,GAAM,KAC7CA,GAAMpF,EAAQ,IAAM,KACpBA,GAASA,EAAM7C,OAAS,IAAM6C,EAAM7C,OAAS6C,GAAS,GAC7D,CAIO,MAAMyG,GAAQ,QAERC,GAAO,OAEb,SAASC,GAAS/J,GACvB,OAAOA,GAAKA,EAAEO,MAChB,CAMO,SAASyJ,GAAUhK,GACxB,GAAI+J,GAAS/J,GAAI,OAAO,EACxB,GAAIH,EAAQA,SAACG,GAAI,IAAK,MAAM0B,KAAO1B,EACjC,GAAIgK,GAAUhK,EAAE0B,IAAO,OAAO,EAEhC,OAAO,CACT,CAEO,SAASf,GAAMsJ,EAAWC,GAC/B,OAAoB,MAAbD,EAAoBA,EAAYC,CACzC,CAEO,SAASC,GAAMC,GACpB,OAAOA,GAAKA,EAAE7J,QAAU6J,CAC1B,CC1FA,MAAMC,GAAQ,QAEC,SAASC,GAAYC,EAAQpE,GAM1C,OALeoE,EAAOC,MAAQC,GAC1BF,EAAOA,OAASG,GAChBH,EAAOzK,KAAO6K,GACd7E,EAAKA,MAAC,iCAAmC3C,EAAWA,YAACoH,KAE3CA,EAAQpE,EACxB,CAMA,SAASsE,GAAYF,EAAQpE,GAC3B,MACM9C,EAAQuH,GAAiB,CAACJ,MADnBD,EAAOC,MAAM5G,KAAIU,GAAKgG,GAAYhG,EAAG6B,MACJoE,EAAQpE,GACtD,OAAOA,EAAM0E,UAAUxH,GAAO0F,EAChC,CAEA,SAAS2B,GAAaH,EAAQpE,GAC5B,MACM9C,EAAQuH,GAAiB,CAACL,OADrBD,GAAYC,EAAOA,OAAQpE,IACOoE,EAAQpE,GACrD,OAAOA,EAAM0E,UAAUxH,GAAO0F,EAChC,CAEA,SAAS4B,GAAYJ,EAAQpE,GAC3B,IAAI4C,EAjBN,IAAqB+B,EAkBfP,EAAOzK,OAASuK,IAClBtB,EAAK5C,EAAM4E,MAAMV,GAAOE,EAAOS,UAC/BT,EAAS,CAACU,QAASV,EAAOU,QAASC,OAAQX,EAAOW,SAElDnC,EAAK5C,EAAM4E,OAtBMD,EAsBYP,EAAOO,UArBnBjB,GAAQC,GAAQgB,GAAUhB,GAqBES,EAAOzK,MAGtD,MAAMuD,EAAQuH,GAAiB,CAACL,OAAQxB,GAAKwB,EAAQpE,GACrD,OAAqC,IAA9BuB,OAAOC,KAAKtE,GAAOrC,OACtB+H,EACA5C,EAAM0E,UAAUxH,GAAO0F,EAC7B,CAEA,SAAS6B,GAAiBvH,EAAOkH,EAAQpE,GACvC,IAAIgF,EAAQZ,EAAOU,QAqCnB,OAnCIE,IACmB,IAAjBA,EAAMnK,QACR8E,EAAAA,MAAM,mDAAqD3C,cAAYoH,IAEzElH,EAAM4H,QAAU,CACdX,GAAYa,EAAM,GAAIhF,GACtBmE,GAAYa,EAAM,GAAIhF,KAI1BgF,EAAQZ,EAAOW,OAAS,GAAGE,OAAOb,EAAOW,QAAU,IAC/CX,EAAOtD,UAAYsD,EAAOc,UAAYd,EAAOe,WAE/CH,EAAM9C,KAyBV,SAAoBvI,EAAMgB,EAAMmF,GAC9B,MAAMsF,EAAO,aACb,OAAOA,GACFzL,GAAiB,MAATA,EAAe,KAAOyL,EAAO,qBAAwBzL,EAAO,IAAO,KAC3EmG,EAAO,KAAOsF,EAAO,iBAAoBtF,EAAO,IAAO,KACvDnF,EAAO,KAAOyK,EAAO,iBAAoBzK,EAAO,IAAO,GAC9D,CA/Be0K,CAAWjB,EAAOtD,SAAUsD,EAAOc,SAAUd,EAAOe,WAE7Df,EAAOO,SAAWjB,IAEpBsB,EAAM9C,KAAK,uBAET8C,EAAMnK,SACRqC,EAAM6H,OAASpD,kBAAgB,IAAMqD,EAAMnH,KAAK,QAAU,IAAKmC,GAAOqB,OAGvC,OAA5B2D,EAAQZ,EAAOS,YAClB3H,EAAM2H,UAAYG,GAGa,OAA5BA,EAAQZ,EAAOkB,YAClBpI,EAAMoI,UAAYN,GAGhBZ,EAAOmB,UACTrI,EAAMqI,SAAU,GAGXrI,CACT,CC9EA,MAAMsI,GAAgB,CACpBtE,KAAM,WACNuE,IAAK,CAAC9L,KAAM,aAAca,MAAO,UAGpB,SAAAkL,GAASjM,EAAMuG,EAAO2F,GACnC,MAAMzK,EAASzB,EAAKyB,OACdgC,EAAQ,CAACyI,OAAQA,GAEvB,IAAIC,EAASnM,EAAKmM,OACd9K,EAASrB,EAAKqB,OACd+K,EAAU,GAETD,GACHjG,EAAKA,MAAC,+CAIJ5C,EAAAA,SAAS6I,KACXA,EAASE,EAAaA,cAACF,EAAQ5F,EAAM+F,aAAerC,GAAQC,KAI9DiC,EAASnF,EAAKA,MAACmF,GACZb,QAAO5G,GAAKA,EAAE/D,QAAU+D,EAAErB,OAAS+I,EAAQ3D,KAAK/D,GAAI,GAAK,IAGxD0H,EAAQhL,OAAS,IACnBgL,EAAU,CAACG,GAAaH,KAItBD,EAAO/K,QACTgL,EAAQ3D,KAAK0D,EAAO/K,OAAS,EAAI,CAACwJ,MAAOuB,GAAUA,EAAO,IAG9C,MAAV1K,IACEJ,GAAQ6E,QAAM,oDAClB7E,EAAS,iBAAmBkC,EAAAA,YAAY9B,GAAU,KAIpDgC,EAAMpC,OAASiC,WAASjC,GAAU6G,EAAAA,gBAAgB7G,EAAQkF,GACvC,MAAflF,EAAO4G,KAAeC,EAAAA,gBAAgB7G,EAAO4G,KAAM1B,GACnC,MAAhBlF,EAAON,MAAgBM,EAAON,MACb,MAAjBM,EAAOV,OAAiB,CACtBiH,MAASmE,GACT5D,QAAS,CAACqE,OAAQjG,EAAMkG,UAAUpL,EAAOV,UAE3CuF,EAAAA,MAAM,wCAENlG,EAAK0M,QACPjJ,EAAMkJ,QAAU,CAACD,OAAO,IAG1BN,EAAQnF,SAAQiE,GACd3E,EAAMqG,UAAU9L,EAAAA,OAIpB,SAAsB6J,EAAQpE,GAC5B,MAAO,CACL2E,OAAQP,EAAOhK,OAAS4F,EAAMkG,UAAU9B,EAAOhK,QACvCgK,EAAOtH,MAAQkD,EAAMnD,SAASuH,EAAOtH,OACrCqH,GAAYC,EAAQpE,GAEhC,CAV2BsG,CAAa3B,EAAQ3E,GAAQ9C,KAExD,CAUA,SAAS8I,GAAaH,GACpB,MAAO,CACLzL,OAAQ,IACJyL,EAAQpI,KAAIU,GAAKA,EAAErB,MAAQ,UAAYqB,EAAErB,MAAQ,KAAOqB,EAAE/D,SAC1D,IAER,CC7Ee,SAAAmM,GAASnM,EAAQ4F,GAC9B,MAAMqC,EAAKrC,EAAMwG,UAAUpM,EAAOO,MAClC,IAAI+G,EAAOtH,EAAOU,OAEdV,EAAOqM,OACL/E,EACF/B,EAAKA,MAAC,8DAEN+B,EAAOtH,EAAOqM,KACdpE,EAAGqE,UAAW,IAIdhF,IACFA,EAAOC,EAAeA,gBAACD,EAAM1B,GAC7BqC,EAAGvH,OAAS4G,EAAKL,MACjBgB,EAAGpC,OAASyB,EAAKE,SAGfxH,EAAOuM,IACTvM,EAAOuM,GAAGjG,SAAQ7G,GAAK6L,GAAY7L,EAAGmG,EAAOqC,EAAGO,KAEpD,CCxBA,MAAMgE,GAAYjM,GAAQ,CAACsF,EAAQzF,EAAOgF,IACxCtC,EAAMvC,EAAMH,EAAOyF,QAAUzB,EAAWgB,GAE7BqH,GAAYD,GAAU,aACtBE,GAAYF,GAAU,aACtBG,GAAQH,GAAU,SAClBI,GAAUJ,GAAU,WACpBK,GAAUL,GAAU,WACpBM,GAAWN,GAAU,YACrBO,GAASP,GAAU,UACnBQ,GAAaR,GAAU,cAEvBS,GAAQT,GAAU,SAClBU,GAAQV,GAAU,SAClBW,GAAMX,GAAU,OAChBY,GAAgBZ,GAAU,iBAC1Ba,GAAOb,GAAU,QACjBc,GAAOd,GAAU,QACjBe,GAAcf,GAAU,eACxBgB,GAAchB,GAAU,eACxBiB,GAAUjB,GAAU,WACpBkB,GAASlB,GAAU,UACnBmB,GAAWnB,GAAU,YACrBoB,GAAapB,GAAU,cACvBqB,GAAQrB,GAAU,SAClBsB,GAAQtB,GAAU,SAClBuB,GAASvB,GAAU,UACnBwB,GAAQxB,GAAU,SAClByB,GAAQzB,GAAU,SAClB0B,GAAY1B,GAAU,aACtB2B,GAAa3B,GAAU,cACvB4B,GAAS5B,GAAU,UCvBhC,IAAI6B,GAAe,EAEnB,MAAMC,GAAwB,CAACC,IAAK,MAAOjJ,IAAK,MAAOlC,MAAO,OAevD,SAASoL,GAAWnP,EAAMuG,GAC/B,MAAMC,EAASD,EAAM6I,SAASpP,EAAKkB,MAAMsF,OACzC,IAAI1E,EA0LN,IAAwBuN,EAtKtB,IAAKvN,KAlBL0E,EAAO8I,OAASC,GAAiBvP,EAAKsP,OAAQtP,EAAMuG,GAElC,MAAdvG,EAAKgF,QACPwB,EAAOxB,MAAQwK,GAAgBxP,EAAMuG,EAAOC,IAGtB,MAApBxG,EAAKyP,aA6LX,SAA+BA,EAAajJ,GAC1CA,EAAOiJ,YAAcC,GAAaD,EAAYvP,MAAQuP,GAC7B,MAArBA,EAAYE,QACdnJ,EAAOoJ,iBAAmBF,GAAaD,EAAYE,OAEvD,CAjMIE,CAAsB7P,EAAKyP,YAAajJ,GAGzB,MAAbxG,EAAKqP,OACP7I,EAAO6I,MA6KaA,EA7KSrP,EAAKqP,KA8K7BpP,EAAAA,SAASoP,GACZ,CACES,SAAUJ,GAAaL,EAAKS,UAC5BC,KAAML,GAAaL,EAAKU,OAE1BL,GAAaL,KAhLA,MAAbrP,EAAKgQ,OACPxJ,EAAOwJ,KAiKX,SAAwBxF,EAAGjE,GACzB,OAAOiE,EAAE7J,QAAUE,EAAOA,QAAC2J,GACvByF,GAAWzF,EAAGjE,GACdA,EAAM2J,eAAe1F,EAC3B,CArKkB2F,CAAenQ,EAAKgQ,KAAMzJ,IAG9BvG,EACN4B,EAAAA,eAAe4E,EAAQ1E,IAAgB,SAARA,IACnC0E,EAAO1E,GAAO4N,GAAa1P,EAAK8B,GAAMyE,GAE1C,CAEA,SAASmJ,GAAalF,EAAGjE,GACvB,OAAQtG,EAAQA,SAACuK,GACbA,EAAE7J,OAAS4F,EAAMkG,UAAUjC,EAAE7J,QAC7BuF,EAAKA,MAAC,uBAAyB3C,EAAWA,YAACiH,IAFzBA,CAGxB,CAEA,SAASyF,GAAWzF,EAAGjE,GACrB,OAAOiE,EAAE7J,OACL4F,EAAMkG,UAAUjC,EAAE7J,QAClB6J,EAAExG,KAAIwG,GAAKkF,GAAalF,EAAGjE,IACjC,CAEA,SAAS6J,GAAgBlP,GACvBgF,EAAAA,MAAM,0BAA4B3C,cAAYrC,GAChD,CAIA,SAASqO,GAAiBD,EAAQtP,EAAMuG,GACtC,GAAK+I,EAOL,OAAOA,EAAO3O,OAAS4F,EAAMkG,UAAU6C,EAAO3O,SACzCE,UAAQyO,GAAUe,GACnBf,EAAO/H,OAAS+I,GAChBC,IAAgBjB,EAAQtP,EAAMuG,GATV,MAAlBvG,EAAKwQ,WAAuC,MAAlBxQ,EAAKyQ,WACjCvK,EAAKA,MAAC,+DASZ,CAEA,SAASmK,GAAef,EAAQtP,EAAMuG,GACpC,OAAO+I,EAAOtL,KAAIwG,GAAKkF,GAAalF,EAAGjE,IACzC,CAEA,SAASgK,GAAejB,EAAQtP,EAAMuG,GACpC,MAAMmK,EAAOnK,EAAMoK,QAAQrB,EAAOoB,MAGlC,OAFKA,GAAMN,GAAgBd,EAAOoB,MAE3BE,EAAUA,WAAC5Q,EAAKE,MACjBwQ,EAAKG,UAAUtK,EAAO+I,EAAO9L,MAAOsN,GAAUxB,EAAOyB,MAAM,IAC3DC,aAAWhR,EAAKE,MAAQwQ,EAAKO,UAAU1K,EAAO+I,EAAO9L,OACrDkN,EAAKQ,UAAU3K,EAAO+I,EAAO9L,MACrC,CAEA,SAAS8M,GAAehB,EAAQtP,EAAMuG,GACpC,MAAMmK,EAAOpB,EAAOoB,KACdnJ,EAAS+H,EAAO/H,OAAO4J,QAAO,CAACC,EAAKC,KAClCA,EAAI/N,EAAAA,SAAS+N,GAAK,CAACX,KAAMA,EAAMlN,MAAO6N,GACjCxQ,EAAOA,QAACwQ,IAAMA,EAAE1Q,OAW/B,SAAkB+P,EAAMnK,GACtB,MAAMrF,EAAO,WAAc8N,KACrBsC,EAAO/D,GAAQ,CAAA,GAErB,GAAI1M,EAAAA,QAAQ6P,GACVY,EAAKvQ,MAAQ,CAACwQ,QAASb,QAClB,GAAIA,EAAK/P,OAAQ,CACtB,MAAM8G,EAAO,WAAalE,cAAYrC,GAAQ,IAAMwP,EAAK/P,OAAS,IAClE2Q,EAAK9K,OAAOgL,MAAQjL,EAAMkG,UAAUhF,EACtC,CAEA,OADAlB,EAAMkL,gBAAgBvQ,EAAM,CAACoQ,EAAM1C,GAAM,CAAA,KAClC,CAAC8B,KAAMxP,EAAMsC,MAAO,OAC7B,CAvByC+F,CAAS8H,EAAG9K,GACvC8K,EACJD,EAAI3I,KAAK4I,GACFD,IACN,IAET,OAAQR,EAAUA,WAAC5Q,EAAKE,MAAQwR,GAC5BV,EAAAA,WAAWhR,EAAKE,MAAQyR,GACxBC,IAAuBtC,EAAQ/I,EAAOgB,EAC5C,CAgBA,SAASmK,GAAsBpC,EAAQ/I,EAAOgB,GAC5C,MAAMwJ,EAAOD,GAAUxB,EAAOyB,MAAM,GACpC,IAAIpM,EAAG6F,EAGP,MAAMqH,EAAStK,EAAOvD,KAAI8N,IACxB,MAAMpB,EAAOnK,EAAMoK,QAAQmB,EAAEpB,MAE7B,OADKA,GAAMN,GAAgB0B,EAAEpB,MACtBA,EAAKqB,UAAUxL,EAAOuL,EAAEtO,MAAOuN,EAAK,IAIvCiB,EAAI,CAACC,QAASvI,EAAawI,MAAOL,GACpCd,IACFpM,EAAIoM,EAAKnI,IAAM,QACf4B,EAAIuG,EAAKvN,MAAQwG,GAAUrF,EAAGoM,EAAKvN,OAAS,QAC5CwO,EAAEG,IAAM,CAAClD,GAAqBtK,IAC9BqN,EAAEzK,OAAS,CAAChB,EAAMgD,SAASiB,IAC3BwH,EAAEI,GAAK,CAAC5H,IAEV7F,EAAI4B,EAAM8L,IAAIjF,GAAU4E,IAGxB,MAAM1N,EAAIiC,EAAM8L,IAAI9E,GAAQ,CAAC2E,MAAOxM,EAAIf,MASxC,OANA6F,EAAIjE,EAAM8L,IAAItD,GAAO,CACnBvL,MAAOkG,EACPqH,KAAOxK,EAAM+L,QAAQvB,GACrBmB,MAAOxM,EAAIpB,MAGNoB,EAAI8E,EACb,CAEA,SAASsG,GAAUC,EAAMwB,GAavB,OAZIxB,IACGA,EAAKvN,OAAUuN,EAAKnI,GAGbmI,EAAKvN,OAAqB,UAAZuN,EAAKnI,GAEpB2J,GAAexB,EAAKvN,OACzBuN,EAAKnI,KAAOqG,GAAqB8B,EAAKnI,KACxC1C,EAAAA,MAAM,kDAAoD6K,EAAKnI,IAHjE1C,EAAAA,MAAM,4CAA8C6K,EAAKnI,IAHrD3I,EAAAA,SAAS8Q,GAAOA,EAAKvN,MAAQ,MAC5BuN,EAAO,CAACvN,MAAO,QASjBuN,CACT,CAEA,SAASY,GAAuBrC,EAAQ/I,EAAOgB,GAE7C,MAAMiL,EAASjL,EAAOvD,KAAI8N,IACxB,MAAMpB,EAAOnK,EAAMoK,QAAQmB,EAAEpB,MAE7B,OADKA,GAAMN,GAAgB0B,EAAEpB,MACtBA,EAAKO,UAAU1K,EAAOuL,EAAEtO,MAAM,IAIvC,OAAOkC,EAAIa,EAAM8L,IAAIlE,GAAY,CAACqE,OAAQA,KAC5C,CAEA,SAASZ,GAAsBtC,EAAQ/I,EAAOgB,GAE5C,MAAMkL,EAAUlL,EAAOvD,KAAI8N,IACzB,MAAMpB,EAAOnK,EAAMoK,QAAQmB,EAAEpB,MAE7B,OADKA,GAAMN,GAAgB0B,EAAEpB,MACtBA,EAAKQ,UAAU3K,EAAOuL,EAAEtO,MAAM,IAIvC,OAAOkC,EAAIa,EAAM8L,IAAInE,GAAY,CAACuE,QAASA,KAC7C,CAgCA,SAASjD,GAAgBxP,EAAMuG,EAAOC,GACpC,MAAMG,EAASJ,EAAMI,OAAO3B,MAC5B,IAAIA,EAAQhF,EAAKgF,MAEjB,GAAIA,EAAMrE,OACR,OAAO4F,EAAMkG,UAAUzH,EAAMrE,QACxB,GAAI2C,EAAAA,SAAS0B,GAAQ,CAC1B,GAAI2B,GAAU/E,EAAAA,eAAe+E,EAAQ3B,GAEnC,OAAOwK,GADPxP,EAAOc,EAAAA,OAAO,CAAE,EAAEd,EAAM,CAACgF,MAAO2B,EAAO3B,KACVuB,EAAOC,GACjB,UAAVxB,EACTA,EAAQ,CAAC,EAAG,CAACrE,OAAQ,UACF,WAAVqE,EACTA,EAAQ4L,EAAAA,WAAW5Q,EAAKE,MACpB,CAAC,EAAG,CAACS,OAAQ,WACb,CAAC,CAACA,OAAQ,UAAW,GAEzBuF,EAAAA,MAAM,mCAAqC3C,cAAYyB,GAE3D,KAAO,IAAIA,EAAM0N,OAMf,OALAlM,EAAOkM,OAAS7R,EAAOA,QAACmE,EAAM0N,QAC1BzC,GAAWjL,EAAM0N,OAAQnM,GACzBmJ,GAAa1K,EAAM0N,OAAQnM,GAC3BvB,EAAM2N,SAAQnM,EAAOoM,aAAe3C,GAAWjL,EAAM2N,OAAQpM,SAC7DvB,EAAMjB,QAAOyC,EAAOqM,YAAcnD,GAAa1K,EAAMjB,MAAOwC,KAE3D,GAAIvB,EAAM+K,KAEf,YADAvJ,EAAOsM,UAAYpD,GAAa1K,EAAM+K,KAAMxJ,IAEvC,GAAIqK,EAAUA,WAAC5Q,EAAKE,QAAUW,EAAAA,QAAQmE,GAC3C,OAAOuK,GAAiBvK,EAAOhF,EAAMuG,GAC3B1F,UAAQmE,IAClBkB,EAAAA,MAAM,2BAA6B3C,cAAYyB,GACjD,CAEA,OAAOA,EAAMhB,KAAIwG,IAAM3J,EAAAA,QAAQ2J,GAAKyF,GAAaP,IAAclF,EAAGjE,IACpE,CC1PA,SAASwM,GAAe3S,EAAGc,EAAMqF,GAC/B,OAAO1F,EAAOA,QAACT,GAAKA,EAAE4D,KAAI5D,GAAK2S,GAAe3S,EAAGc,EAAMqF,KAClDtG,EAAQA,SAACG,GACVA,EAAEO,OAAS4F,EAAMkG,UAAUrM,EAAEO,QACpB,QAATO,EAAiBd,EACjB8F,EAAAA,MAAM,iCAAmC3C,EAAAA,YAAYnD,IAHtCA,CAIrB,CC3BO,MAAM4S,GAAM,MACNC,GAAO,OACPC,GAAQ,QACRC,GAAS,SACTC,GAAS,SAETC,GAAW,WAEXC,GAAQ,QAERC,GAAM,MAENC,GAAS,QACTC,GAAS,QACTC,GAAS,SACTC,GAAS,OACTC,GAAS,QACTC,GAAS,QAETC,GAAkB,cAClBC,GAAkB,cAClBC,GAAkB,cAClBC,GAAqB,iBAErBC,GAAU,SACVC,GAAW,WACXC,GAAW,WAEXC,GAAO,OAUPC,GAAe,CAC1BD,GAVmB,QACD,OACE,SACK,cACD,aACH,WAcVE,GAAO,CAClBrT,KAAM,EACNoF,MAAO,EACPkO,YAAa,GAGFC,GAAO,CAAC1T,MAAO,GACf2T,GAAM,CAAC3T,MAAO,GCvDd4T,GAAY,QACZC,GAAW,OACXC,GAAW,OACXC,GAAa,SACbC,GAAW,OCFT,SAAAC,GAASjO,GAGtB,OAFAA,EAAK7G,KAAOyU,GACZ5N,EAAKyN,YAAczN,EAAKyN,cAAe,EAChCzN,CACT,CCFO,SAASkO,GAAOjV,EAAM2G,GAC3B,MAAMvG,EAAIA,CAACc,EAAMgU,IAASnU,GAAMf,EAAKkB,GAAOH,GAAM4F,EAAOzF,GAAOgU,IAsBhE,OApBA9U,EAAE+U,WAAazQ,GAAK2O,KAAatS,GAC/Bf,EAAKoV,UACLzO,EAAOyO,YAAc1Q,EAAIiC,EAAO0O,gBAAkB1O,EAAO2O,oBAG3DlV,EAAEmV,eAAiB,IAAMxU,GACvBf,EAAKuV,eACL5O,EAAO4O,gBAAkB5O,EAAO6O,eAGlCpV,EAAEqV,kBAAoB,IAAM1U,GAC1Bf,EAAKyV,kBACL9O,EAAO8O,mBAAqB9O,EAAO+O,gBAGrCtV,EAAEuV,aAAe,IAAM5U,GACrBf,EAAK4V,QACL7U,GAAM4F,EAAOiP,SAAUxV,EAAE+U,YAAW,KAG/B/U,CACT,CAEO,SAASyV,GAAY3U,EAAMO,GAChC,MAAM+I,EAAI/I,IACPA,EAAOJ,QAAUI,EAAOJ,OAAOH,IAC/BO,EAAOF,OAASE,EAAOF,MAAML,IAEhC,OAAOsJ,GAAKA,EAAE7J,OAAS6J,EAAIA,EAAIA,EAAEzJ,MAAQ,IAC3C,CAOO,SAAS+U,GAAWpR,EAAGqR,EAAGC,GAC/B,MAAQ,oBAAmB1C,SAAY5O,wBAAwB6O,SAAUwC,OAAOC,GAClF,CAEO,MAAMC,GAAYH,GACvBvS,EAAWA,YAAC0P,IACZ1P,cAAY2P,IACZ3P,EAAAA,YAAY6P,KAgCP,SAAS8C,GAAanV,EAAOsE,GAClC,OAAQA,EACHtE,EACAd,EAAAA,SAASc,GACV+G,OAAOqO,OAAO,CAAE,EAAEpV,EAAO,CAAEsE,OAAQ6Q,GAAanV,EAAMsE,OAAQA,KAD3C,CAAEtE,QAAOsE,UADnBA,EADItE,CAInB,CCpFe,SAAAqV,GAASrP,EAAMsP,GAS5B,OARIA,GACFtP,EAAK7F,KAAOmV,EAAOnV,KACnB6F,EAAKT,MAAQ+P,EAAO/P,OAASS,EAAKT,MAClCS,EAAKyN,cAAgB6B,EAAO7B,YAC5BzN,EAAKtF,OAASD,EAAauF,EAAKtF,OAAQ4U,EAAQ9B,KAEhDxN,EAAKyN,aAAc,EAEdzN,CACT,CCLe,SAAAuP,GAAStW,EAAMqD,EAAOsD,EAAQ4P,GAC3C,MAAMnW,EAAI6U,GAAOjV,EAAM2G,GACjB6P,EAAWpW,EAAE+U,aACbsB,EAAYrW,EAAEqV,oBACdrU,EAAShB,EAAEmV,iBAEjB,IAAIhU,EAAOsC,EAAOC,EAAM4S,EAAOC,EAE3BH,GACF3S,EAAQ,CAAC,EAAG,GACZC,EAAO,CAAC,EAAG,GACX4S,EAAQD,EACRE,EAASvV,IAETyC,EAAQ,CAAC,EAAG,GACZC,EAAO,CAAC,EAAG,GACX4S,EAAQtV,EACRuV,EAASF,GAGX,MAAMhV,EAAS,CACbF,MAAOA,EAAQ,CACbqV,QAASnC,GACTlP,EAAGkP,GACHjP,EAAGiP,GACHiC,MAAO9V,EAAQ8V,GACfC,OAAQ/V,EAAQ+V,IAElBtV,OAAQP,EAAAA,OAAO,CAAE,EAAES,EAAO,CACxBqV,QAASlC,GACTmC,KAAM,CAAClT,SAAUN,EAAOQ,MAAOA,EAAOC,KAAMA,KAE9CgT,KAAM,CACJF,QAASnC,KAWb,OAPAnT,EAAYG,EAAQ,CAClBsV,OAAa3W,EAAE,uBACf4W,YAAa5W,EAAE,wBACd,CACDwW,QAAaxW,EAAE,qBAGVgW,GAAU,CACflW,KAAM0U,GACNvO,KAAM1D,EACNlB,UACC8U,EACL,CCjDe,SAAAU,GAASjX,EAAMqD,EAAOsD,EAAQ4P,EAAYW,GACvD,MAAM9W,EAAI6U,GAAOjV,EAAM2G,GACjB6P,EAAWpW,EAAE+U,aACbsB,EAAYrW,EAAEqV,oBACdrU,EAAShB,EAAEmV,iBAEjB,IAAI4B,EAAG3M,EAAG4M,EAAIC,EAAIC,EAAS,GAE3Bd,GACKW,EAAI,IAAKC,EAAK,KAAM5M,EAAI,IAAK6M,EAAK,QAASC,EAAS,OACpDH,EAAI,IAAKC,EAAK,KAAM5M,EAAI,IAAK6M,EAAK,UAEvC,MAAM9V,EAAQ,CACZqV,QAASnC,GACToC,KAAM,CAACxT,MAAOA,EAAOG,MAAOqQ,KAE9BtS,EAAM4V,GAAM,CAACxW,OAAQ2W,EAAS,SAAW3D,GAAMvO,KAAMhE,GACrDG,EAAMiJ,GAAMiK,GACZlT,EAAM6V,GAAM,CAACzW,OAAQ2W,EAAS,SAAW1D,GAAOxO,KAAMhE,GACtDG,EAAM8V,GAAMzW,EAAQ6V,GAEpB,MAAMhV,EAAS,CACbF,MAAOA,EACPF,OAAQP,EAAAA,OAAO,CAAE,EAAES,EAAO,CAACqV,QAASlC,KACpCoC,KAAM,CAACF,QAASnC,KAUlB,OAPAnT,EAAYG,EAAQ,CAClBsV,OAAa3W,EAAE,uBACf4W,YAAa5W,EAAE,wBACd,CACDwW,QAAaxW,EAAE,qBAGVgW,GAAU,CACflW,KAAM0U,GACNvO,KAAM5D,EACNX,IAAM+R,GACN0D,KAAML,EACNzV,UACC8U,EACL,CCtCA,MAAMN,GAAa,SAAQtC,UAAYV,aAAeU,UAAYT,QAAWE,MACvEoE,GAAgB,SAAQ7D,UAAYR,aAAiBQ,UAAYX,eAExD,SAAAyE,GAASzX,EAAM2G,EAAQ4P,EAAYW,GAChD,MAAM9W,EAAI6U,GAAOjV,EAAM2G,GACjB6P,EAAWpW,EAAE+U,aACbsB,EAAY7V,EAAQR,EAAEqV,qBACtBrU,EAAShB,EAAEmV,iBAEjB,IACIhU,EAAOF,EAAQ8V,EAAG3M,EADlBkN,EAAUtX,EAAE,gBACSkX,EAAS,GAElC,MAAM7V,EAAS,CACbF,MAAOA,EAAQ,CACbqV,QAASnC,IAEXpT,OAAQA,EAAS,CACfuV,QAASlC,GACTiD,KAAM,CAACnU,MAAOiQ,KAEhBqD,KAAM,CACJF,QAASnC,KAoCb,OAhCAnT,EAAYG,EAAQ,CAClBoV,KAAazW,EAAE,cACfwX,YAAaxX,EAAE,gBACfyX,KAAazX,EAAE,aACf0X,SAAa1X,EAAE,iBACf2X,UAAa3X,EAAE,kBACf4X,WAAa5X,EAAE,mBACf6X,MAAalX,GAAMf,EAAKkY,WAAYvR,EAAOwR,sBAGzC3B,GACFjV,EAAM6W,MAAQ,CAACrX,MAAO,QACtBQ,EAAM8W,SAAWhX,EAAOgX,SAAW,CAAC1X,OAAQ6W,IAC5CL,EAAI,IAAK3M,EAAI,IAAK8M,EAAS,OAE3B/V,EAAM6W,MAAQ/W,EAAO+W,MAAQ,CAACzX,OAAQsV,IACtC1U,EAAM8W,SAAW,CAACtX,MAAO,OACzBoW,EAAI,IAAK3M,EAAI,KAGfjJ,EAAM4V,GAAK9V,EAAO8V,GAAK,CAACxW,OAAQ2W,EAAS,SAAW3D,GAAMvO,KAAMhE,GAEhEG,EAAMiJ,GAAKnJ,EAAOmJ,GAAKiM,EACvBA,EAAUpR,OAAStE,GAAMf,EAAKsY,YAAa3R,EAAO4R,sBAAwB,EAE1Eb,EAAUA,EAAU,CAClBc,WAAYpY,EAAE,mBACdqY,OAAQf,EACRgB,MAAO,SAAWlF,SAChBzO,EAGGqR,GAAU,CACflW,KAAO6U,GACP1O,KAAOzD,EACP0D,MAAOwN,GACPhS,IAAO+R,GACP0D,KAAML,EACNzV,SACAiW,WACCnB,EACL,CCjEe,SAAAoC,GAAS3Y,EAAM2G,EAAQ4P,EAAYW,EAAStB,GACzD,MAAMxV,EAAI6U,GAAOjV,EAAM2G,GACjBiS,EAAUrC,EAAWqC,QACrBpE,KAAiBoE,IAAWA,EAAQpE,aACpCtT,EAAO0X,EAAUA,EAAQ1X,UAAO6D,EAChC4R,EAASvW,EAAE,cACXyY,EAAezY,EAAE,gBACjB0Y,EAAW,CAACpI,KAAM,SAClBqI,EAAW,IAAGnD,cAAoBlC,cAAkBW,KACpD2E,EAAUrC,EAAS/V,EAAQ+V,GAAU,CAACnT,MAAO6Q,IAC7C4E,EAAS,SAAQzF,KACjB0F,EAAS,UAAStD,KAExB,IAAInU,EAAQF,EAAOF,EAAQ8X,EAAOpI,EAElCiI,EAAQ5T,KAAO,GAGf3D,EAAS,CACPF,MAAQA,EAAQ,CACdqV,QAASnC,GACTlP,EAAG,CAAC5E,OAAQoY,EAAS3T,KAAM,GAAKC,OAAQwT,GACxCrT,EAAGwT,GAEL3X,OAAQA,EAAS,CACfuV,QAASlC,GACTnP,EAAGhE,EAAMgE,EACTC,EAAGjE,EAAMiE,GAEXsR,KAAM,CACJF,QAASnC,KAIb,IAAI2E,EAAW,KACXC,EAAa,KACZrZ,EAAK6W,OACRuC,EAAWzS,EAAO2S,oBAClBD,EAAa1S,EAAO4S,uBAGtBjY,EAAYG,EAAQ,CAClBoV,KAAkBzW,EAAE,kBAAmBgZ,GACvCI,MAAkBpZ,EAAE,cACpBqZ,KAAkBrZ,EAAE,cACpB2W,OAAkB3W,EAAE,oBAAqBiZ,GACzCK,WAAkBtZ,EAAE,cACpBuZ,iBAAkBvZ,EAAE,oBACpB4W,YAAkB5W,EAAE,sBACnB,CACDwW,QAAkBxW,EAAE,mBAGtBkU,GAAarN,SAAQ5D,IACfrD,EAAKqD,KACPhC,EAAOgC,GAAS9B,EAAM8B,GAAS,CAACA,MAAOrD,EAAKqD,GAAQG,MAAOqQ,IAC7D,IAGF,MAAM+F,EAAUxD,GAAU,CACxBlW,KAAM4U,GACNzO,KAAMxD,EACNf,IAAM+R,GACN0D,KAAMuB,EACNe,OAAMlD,QAAgB5R,EACtBtD,UACC8U,EAAWqD,SAGRtB,EAAc1X,EAAQiY,GAC5BP,EAAYjT,OAASjF,EAAE,eAEvBqB,EAAS,CACPF,MAAQA,EAAQ,CACdqV,QAASnC,GACTlP,EAAG,CAAC5E,OAAQoY,EAAS1T,OAAQiT,GAC7B9S,EAAGwT,GAEL3X,OAAQA,EAAS,CACfuV,QAASlC,GACTiD,KAAM,CAACnU,MAAOiQ,IACdlO,EAAGhE,EAAMgE,EACTC,EAAGjE,EAAMiE,GAEXsR,KAAM,CACJF,QAASnC,KAIbnT,EAAYG,EAAQ,CAClB2W,MAAahY,EAAE,cACfiY,SAAajY,EAAE,iBACfyW,KAAazW,EAAE,cACfwX,YAAaxX,EAAE,gBACfyX,KAAazX,EAAE,aACf0X,SAAa1X,EAAE,iBACf2X,UAAa3X,EAAE,kBACf4X,WAAa5X,EAAE,mBACf6X,MAAa7X,EAAE,gBAGjB,MAAM0Z,EAAS1D,GAAU,CACvBlW,KAAO6U,GACP1O,KAAOzD,EACP0D,MAAOwN,GACPhS,IAAO+R,GACP0D,KAAOuB,EACPrX,UACC8U,EAAWuD,QAmCd,OAhCArY,EAAS,CACPF,MAAO,CACLwY,QAAS,CAAChZ,OAAQ4V,GAClBD,MAAOjC,GACPkC,OAAQA,EAAS/V,EAAQ+V,GAAUlC,GACnCmC,QAASnC,IAEXqC,KAAM,CAACF,QAASnC,IAChBpT,OAAQA,EAAS,CACfuV,QAASlC,GACTsF,IAAK,CAACrZ,OAAQ,MACdsZ,OAAQ,CAACtZ,OAAQ,QAKjBP,EAAE+U,YAAW,IACfgE,EAAS,iCAAgCD,KACzC7X,EAAO2Y,IAAIrZ,OAAU,GAAEsY,KAASE,IAChC9X,EAAO4Y,OAAOtZ,OAAU,SAAQsY,OAAWE,KAC3CpI,EAAO,CAACvN,MAAO,CAAC,MAAOyV,MAEvB5X,EAAO2Y,IAAIrZ,OAAU,SAAQsY,OAAWC,KACxC7X,EAAO4Y,OAAOtZ,OAAU,GAAEsY,OAAWC,IACrCnI,EAAO,CAACvN,MAAOyV,IAGjB5X,EAAO4Y,OAAOtZ,OAAU,IAAGiV,MAAYvU,EAAO4Y,OAAOtZ,UAAUsY,IAKxDjE,GAAW,CAChB3O,KAAQpE,EACRsV,KAJFL,EAAU,CAACgD,MAAO,CAACxJ,KAAMwG,EAAShW,KAAM,QAAS+Q,QAASuB,KAKxD/R,OAAQD,EAAaC,EAAQmX,EAASrE,IACtC4F,MAAQ,CAACP,EAASE,GAClB5Y,OACAsT,cACAzD,QAEJ,CC5JA,MAAMqJ,GAAM,yBACNC,GAAM,0BACNC,GAAQ,IAAGF,SAAUC,MACrBE,GAAQ,kBAAiBD,KACzBjC,GAAWvC,GAAW,QAAS,WAAY,YAE3C0E,GAAa,kBAAiBH,SADlBvE,GAAW,UAAW,SAAU,mBACawE,0BAA4BF,mBAAoBnE,KACzGwE,GAAc,oBAAmBH,2BACjCI,GAAa,GAAEH,SAAWH,qBAC1BO,GAAgB,GAAEL,wBAA0BD,4BAA6BhC,cCfhE,SAAAwB,GAASA,EAAMtT,GAC5B,IAAI0B,EAYJ,OAVIhI,EAAAA,SAAS4Z,KACPA,EAAKlZ,OACPsH,EAAO4R,EAAKlZ,OACHkZ,EAAKe,KACd3S,EAAO,aAAesD,GAAMsO,EAAKe,MAAQ,IAChCf,EAAKgB,SACd5S,EAAO,YAAcsD,GAAMsO,EAAKgB,QAAU,wBAIvC5S,EACH1B,EAAMkG,UAAUxE,KACd4R,CACR,CAEA,SAAStO,GAAMxK,GACb,OAAOd,EAAQA,SAACc,IAAUA,EAAMJ,OAC5BI,EAAMJ,OACN4C,cAAYxC,EAClB,CCrBe,SAAA+Z,GAAS9a,GACtB,MAAMqG,EAAOrG,EAAKqG,MAAQ,GAC1B,OAASA,EAAK0U,QAAQ,SAAY1U,EAAK0U,QAAQ,WAAc1U,EAAK0U,QAAQ,SAEtE/a,EAAKE,OAASyU,GAAY1S,EAAaoE,GAAQtE,EAD/CsE,CAEN,CCNe,SAAA2U,GAAShb,GACtB,MAAO,CACLqH,SAAcrH,EAAKE,KACnBgB,KAAclB,EAAKkB,WAAQ6D,EAC3BsB,KAAcrG,EAAKqG,MAAQA,GAAKrG,GAChCib,QAAejb,EAAKib,aAAUlW,EAC9BmW,KAAclb,EAAKkb,KACnBC,YAAcnb,EAAKmb,YAEvB,CCXe,SAAA3G,GAASxU,EAAMuG,GAC5B,OAAOvG,GAAQA,EAAKW,OAAS4F,EAAMkG,UAAUzM,EAAKW,SACrC,IAATX,CAEN,CCKe,SAAAob,GAASpb,EAAMuG,GAC5B,MAAM8U,EAAML,EAAAA,WAAWhb,EAAKE,MACvBmb,GAAKnV,QAAM,gCAAkC3C,EAAAA,YAAYvD,EAAKE,OAEnE,MAAMob,EAAI7X,EAAM4X,EAAInb,KAAKqb,cAAe,KAAMC,GAAgBH,EAAKrb,EAAMuG,IAIzE,OAHIvG,EAAKW,QAAQ4F,EAAMsC,UAAU7I,EAAKW,OAAQ4F,EAAMkV,MAAMH,IAC1DA,EAAEI,SAAWL,EAAIK,UAAY,CAAA,EAEtBJ,CACT,CAKA,SAASE,GAAgBH,EAAKrb,EAAMuG,GAClC,MAAMC,EAAS,CAAE,EACXmV,EAAIN,EAAI7U,OAAOpF,OAErB,IAAK,IAAIwa,EAAI,EAAGA,EAAID,IAAKC,EAAG,CAC1B,MAAMC,EAAOR,EAAI7U,OAAOoV,GACxBpV,EAAOqV,EAAK3a,MAAQ6R,GAAe8I,EAAM7b,EAAMuG,EACjD,CACA,OAAOC,CACT,CAKA,SAASuM,GAAesI,EAAKrb,EAAMuG,GACjC,MAAMrG,EAAOmb,EAAInb,KACXa,EAAQf,EAAKqb,EAAIna,MAEvB,MAAa,UAAThB,EA6CN,SAA6Bmb,EAAKrb,EAAMuG,GACjCjD,EAAQA,SAACtD,EAAKuX,OACjBrR,EAAKA,MAAC,qDAER,OAAOK,EAAMoK,QAAQ3Q,EAAKuX,MAAMuE,UAAUvV,EAAOvG,EAAK8B,IACxD,CAjDWia,CAAoBV,EAAKrb,EAAMuG,QACnBxB,IAAVhE,EAMS,UAATb,EA+Cb,SAA4Bmb,EAAKrb,EAAMuG,GACrC,MAAMxF,EAAQf,EAAKqb,EAAIna,MAEvB,OAAIma,EAAIrU,OACDnG,EAAAA,QAAQE,IACXmF,EAAAA,MAAM,iDAAmD3C,cAAYxC,IAEhEA,EAAMiD,KAAIwG,GAAKwR,GAAkBX,EAAK7Q,EAAGjE,MAEzCyV,GAAkBX,EAAKta,EAAOwF,EAEzC,CAzDW0V,CAAmBZ,EAAKrb,EAAMuG,GACnB,eAATrG,EACFqG,EAAM2V,cAAclc,EAAKqb,EAAIna,OAG/Bma,EAAIrU,QAAUmD,GAASpJ,GAC1BA,EAAMiD,KAAIwG,GAAK2R,GAAed,EAAK7Q,EAAGjE,KACtC4V,GAAed,EAAKta,EAAOwF,QAbzB8U,EAAIe,UACNlW,EAAAA,MAAM,oBAAsB3C,cAAYvD,EAAKE,MACvC,eAAiBqD,cAAY8X,EAAIna,OAY7C,CAKA,SAASib,GAAed,EAAKta,EAAOwF,GAClC,MAAMrG,EAAOmb,EAAInb,KAEjB,GAAIiK,GAASpJ,GACX,OAAOsb,GAAOnc,GAAQgG,QAAM,6CACrBoW,GAAQpc,GAAQqG,EAAMgD,SAASxI,GAC/Bwb,GAAUrc,GAAQqG,EAAMoD,WAAW5I,GACnCwF,EAAMkG,UAAU1L,EAAMJ,QACxB,CACL,MAAMsH,EAAOoT,EAAIpT,MAAQqU,GAAQpc,GACjC,OAAO+H,GAAQuU,GAAUzb,GAASwF,EAAMkW,QAAQ1b,EAAMkH,KAAMlH,EAAMqR,IAC3DnK,GAAQyU,GAAW3b,GAASwI,EAASxI,EAAMyC,MAAOzC,EAAMqR,IACxDiK,GAAOnc,GAAQgI,EAAAA,gBAAgBnH,EAAOwF,GACtCoW,GAAOzc,GAAQwF,EAAIa,EAAMoK,QAAQ5P,GAAOyR,QACxC8J,GAAQpc,GAAQqJ,EAASxI,GACzBwb,GAAUrc,GAAQqG,EAAMoD,WAAW5I,GACnCA,CACT,CACF,CA+BA,SAASib,GAAkBX,EAAKta,EAAOwF,GACrC,MAAMoV,EAAGN,EAAI7U,OAAOpF,OACpB,IAAIya,EAGJ,IAAK,IAAID,EAAI,EAAGA,EAAID,IAAKC,EAAG,CAC1BC,EAAOR,EAAI7U,OAAOoV,GAClB,IAAK,MAAMgB,KAAKf,EAAK/Z,IACnB,GAAI+Z,EAAK/Z,IAAI8a,KAAO7b,EAAM6b,GAAI,CAAEf,EAAO,KAAM,KAAO,CAEtD,GAAIA,EAAM,KACZ,CAEKA,GAAM3V,EAAKA,MAAC,0BAA4B3C,EAAWA,YAACxC,IAGzD,MAAMyF,EAAS1F,SAAO0a,GAAgBK,EAAM9a,EAAOwF,GAAQsV,EAAK/Z,KAChE,OAAO4D,EAAIa,EAAM8L,IAAIhE,GAAO7H,IAC9B,CAIO,MAAMgW,GAAYpc,GAAKA,GAAKA,EAAE6H,KAExByU,GAAatc,GAAKA,GAAKA,EAAEoD,MAEzBmZ,GAASvc,GAAW,SAANA,EAEdic,GAASjc,GAAW,SAANA,EAEdkc,GAAUlc,GAAW,UAANA,EAEfmc,GAAYnc,GAAW,YAANA,EC9FvB,SAASyc,GAAWtF,EAAMhR,GAC/B,OAAOgR,EAAKlO,KAAOkO,EACfA,EAAK7G,MAAQ6G,EAAK7G,KAAKrH,KAAOkO,EAAK7G,KACnChL,EAAIa,EAAMoK,QAAQ4G,EAAK7G,MAAMoM,OACnC,CClDe,SAASC,GAAUxW,EAAOiL,EAAOsL,EAAQtK,EAAQwK,GAC9D9T,KAAK3C,MAAQA,EACb2C,KAAKsI,MAAQA,EACbtI,KAAK4T,OAASA,EACd5T,KAAKsJ,OAASA,EAGdtJ,KAAK+T,UAAYD,EAGjB9T,KAAK+P,MAAQ,EACf,CA0BA,SAASiE,GAAS1Z,GAChB,OAAOF,WAASE,GAASA,EAAQ,IACnC,CAEA,SAAS2Z,GAAa5W,EAAOyL,EAAGjB,GAC9B,MAAMqB,EAAKpI,GAAU+G,EAAKnI,GAAImI,EAAKvN,OACnC,IAAIkB,EAEJ,GAAIsN,EAAEG,KACJ,IAAK,IAAIyJ,EAAI,EAAGD,EAAI3J,EAAEI,GAAGhR,OAAQwa,EAAID,IAAKC,EACxC,GAAI5J,EAAEI,GAAGwJ,KAAOxJ,EAAI,YAGtBJ,EAAEG,IAAM,CAAC,SACTH,EAAEzK,OAAS,CAAC,MACZyK,EAAEI,GAAK,CAAC,SAENrB,EAAKnI,KACPoJ,EAAEG,IAAI1J,MAAM/D,EAAEqM,EAAKnI,GAAGjI,QAAU4F,EAAMkG,UAAU/H,GAAKqM,EAAKnI,IAC1DoJ,EAAEzK,OAAOkB,KAAKlC,EAAMgD,SAASwH,EAAKvN,QAClCwO,EAAEI,GAAG3J,KAAK2J,GAEd,CAEA,SAASgL,GAAM7W,EAAO8W,EAAInc,EAAMoc,EAAQ9Z,EAAOqO,EAAQoH,GACrD,MAAMmE,EAAQC,EAAGnc,KAAUmc,EAAGnc,GAAQ,IAChC6P,EvBbD,SAAiBA,GACtB,OAAQ9Q,EAAQA,SAAC8Q,IACZA,EAAK2H,QAAU3O,GAAa,IAAM,KACjCC,GAAU+G,EAAKnI,GAAImI,EAAKvN,OAFL,EAG3B,CuBSe+Z,CAAQ1L,GAErB,IACIrH,EAAG5B,EADHgU,EAAIM,GAAS1Z,GASjB,GANS,MAALoZ,IACFrW,EAAQ8W,EAAG9W,MACXqW,GAAS7L,EAAO,IAAMA,EAAO,GAC7BvG,EAAI4S,EAAMR,KAGPpS,EAAG,CACN,MAAMhE,EAASqL,EACX,CAACrO,MAAOkG,EAAawI,MAAOmL,EAAGtL,UAAUxL,EAAO/C,EAAOqO,IACvD,CAACrO,MAAO+C,EAAMgD,SAAS/F,GAAQ0O,MAAOxM,EAAI2X,EAAGP,SAC7C/L,IAAMvK,EAAOuK,KAAOxK,EAAM+L,QAAQT,IACtCjJ,EAAKrC,EAAM8L,IAAI5O,EAAM6Z,OAAQvY,EAAWyB,IACpCyS,IAAOoE,EAAGpE,MAAMzV,GAASoF,GAC7B4B,EAAI9E,EAAIkD,GACC,MAALgU,IAAWQ,EAAMR,GAAKpS,EAC5B,CACA,OAAOA,CACT,CCtFe,SAAAgT,GAASxd,EAAMuG,EAAOrF,GACnC,MAAMuc,EAASzd,EAAKyd,OACdC,EAAS1d,EAAK0d,OACdC,EAAS3d,EAAK2d,OACdC,EAAS5d,EAAK4d,OACdpL,EAASxS,EAAKwS,OACd5J,EAAKrC,EAAM8L,IAAIjJ,KAEf/H,EAAS,MAAQrB,EAAK6d,QAAU,YAClC3c,EAAO,KACP,CAACwc,EAAQD,EAAQE,EAAQC,EAAQpL,GAC9BxO,KAAI5D,GAAU,MAALA,EAAY,OAASA,IAC9BgE,KAAK,KACR,OAEE6D,EAAOC,EAAAA,gBAAgB7G,EAAQkF,GACrCqC,EAAGvH,OAAS4G,EAAKL,MACjBgB,EAAGpC,OAASyB,EAAKE,OACnB,CCJe,SAAA2V,GAAS9d,EAAMuG,GAC5B,MAAMF,EAAOyU,GAAQ9a,GACf8F,EAAQ9F,EAAKE,OAASyU,GACtBuF,EAAQla,EAAKuX,MAAQvX,EAAKuX,KAAK2C,MAC/BxC,EAAU1X,EAAK0X,QAErB,IACIvF,EAAKvJ,EAAImV,EAAOra,EAAKxC,EAAM8c,EAAWC,EADtCC,EAASle,EAAKke,QAAU7X,IAASpE,GAAaoE,IAASrE,EAG3D,MAAMmc,EAAS9X,IAAStE,GAAYmc,GAAUhE,EAGxC1I,EHxBO,SAAS+F,EAAMzR,EAAOS,GACnC,IAAI2T,EAAOpY,EAAK8G,EAAIsO,EAASnR,EAqC7B,OAlCKwR,GAKI2C,EAAQ3C,EAAK2C,SACfpU,GAAOI,QAAM,oCAGC,MAAfgU,EAAM1W,MACR0T,EAAUnR,EAAS8W,GAAW3C,EAAO3T,IAGhCgR,EAAK7G,KASR3K,EAASL,EAAIa,EAAMoK,QAAQ4G,EAAK7G,MAAMuM,YARtCrU,EAAKwS,GAAeta,SAAO,CACzBZ,KAAS,YACT+R,QAASjL,EAAAA,MAAMkT,EAAMjI,UACpBiI,EAAM+C,WAAY1W,GACrBqC,EAAGpC,OAAO1E,IAAMyE,EAAM6X,OAAOlE,EAAMjI,SACnCrJ,EAAGpC,OAAO0L,MAAQ2K,GAAW3C,EAAO3T,GACpC2Q,EAAUnR,EAASL,EAAIa,EAAM8L,IAAIzJ,KAKnC9G,EAAMyE,EAAM6X,OAAOlE,EAAMjI,SAAS,KAxBpCiF,EAAUxR,EAAIa,EAAM8L,IAAI9E,GAAQ,KAAM,CAAC,CAAA,MA6BpC2J,IACHA,EAAU2F,GAAWtF,EAAMhR,IAGtB,CACLzE,IAAKA,EACLoQ,MAAOgF,EACPnR,OAAQA,EAEZ,CGnBgBsY,CAAUre,EAAKuX,KAAMzR,EAAOS,GAG1CqC,EAAKrC,EAAM8L,IAAI5E,GAAS,CACtB3L,IAAO0P,EAAM1P,MAAQ9B,EAAK8B,IAAMyH,EAASvJ,EAAK8B,UAAOiD,GACrDmN,MAAOV,EAAMU,MACboM,OAAQxY,KAEV,MAAMyY,EAAU7Y,EAAIkD,GAGpBA,EAAKmV,EAAQxX,EAAM8L,IAAI9E,GAAQ,CAAC2E,MAAOqM,KAGvC3V,EAAKrC,EAAM8L,IAAIpE,GAAK,CAClBuQ,QAAaxD,GAAWhb,GACxBwU,YAAaA,GAAYxU,EAAKwU,YAAajO,GAC3CsT,KAAaA,GAAK7Z,EAAK6Z,KAAMtT,GAC7BkY,QAAa,CAACC,UAAU,GACxBC,OAAapY,EAAM0O,SACnBlP,OAAaQ,EAAMmC,QAAQ3C,OAASQ,EAAMkG,UAAU,UAAY,KAChEwM,MAAa1S,EAAMqY,WACnB1M,MAAaxM,EAAIkD,MAEnB,MAAMiW,EAAUnZ,EAAIkD,GAGpBA,EAAKlF,EAAM6C,EAAM8L,IAAI3E,GAAOtH,EAC1BpG,EAAKyB,OAAQzB,EAAKE,KAAMmG,EAAMrG,EAAKsG,MAAOC,EAC1C,CAACuY,KAAK,EAAO5M,MAAO2M,MAItBjW,EAAGpC,OAAOT,OAASQ,EAAM9E,SAGrBzB,EAAKmN,WACPnN,EAAKmN,UAAUlG,SAAQ7G,IACrB,MAAM2e,EAAK3D,GAAehb,EAAGmG,GACvByY,EAAKD,EAAGrD,UACVsD,EAAGC,WAAaD,EAAGE,UACrBhZ,EAAKA,MAAC,iDAEH8Y,EAAGG,QAAOzb,EAAI8C,OAAOsY,KAAM,GAChCC,EAAGvY,OAAO0L,MAAQxM,EAAIkD,GACtBrC,EAAM8L,IAAIzJ,EAAKmW,EAAG,IAKlB/e,EAAK+Q,OACPnI,EAAKrC,EAAM8L,IAAIxD,GAAU,CACvBkC,KAAOxK,EAAMoD,WAAW3J,EAAK+Q,MAC7BmB,MAAOxM,EAAIkD,OAIf,MAAMwW,EAAY1Z,EAAIkD,IAGlBsR,GAASgE,KACXA,EAAS3X,EAAM8L,IAAIvD,GAAW,CAC5BoP,OAAU3X,EAAM2J,eAAelQ,EAAKke,QACpCmB,QAAU9Y,EAAM8Y,QAChBtY,KAAU8X,EACV3M,MAAUkN,KAEZpB,EAAYtY,EAAIwY,IAIlB,MAAMoB,EAAQ/Y,EAAM8L,IAAI/E,GAAM,CAACvG,KAAM8X,EAAS3M,MAAO8L,GAAaoB,KAClEnB,EAAWvY,EAAI4Z,GAGXxZ,IAEEqY,IAAUhM,EAAM5L,EAAMgZ,UAAWpN,EAAIjO,MAAWga,GAAQ/L,EAAIjO,OAEhEqC,EAAMiZ,UAAUJ,EAAWpB,GAAaC,EAAUM,GAClDrE,ECvGW,SAASla,EAAMuG,EAAOT,GACnC,MAAMoU,EAAQla,EAAKuX,KAAK2C,MAClBhZ,EAAOgZ,EAAMhZ,KACbwP,EAAOmM,GAAW3C,EAAO3T,GAC/B,IAAIqC,EAECsR,EAAMhZ,MACTgF,EAAAA,MAAM,2BAA6B3C,cAAY2W,IAE5CA,EAAMxJ,MACTxK,EAAAA,MAAM,oCAAsC3C,cAAY2W,IAGtDA,EAAM1W,MACRoF,EAAKrC,EAAM8L,IAAI/D,GAAS,CACtB9K,MAAO+C,EAAMgD,SAAS2Q,EAAM1W,OAC5B0O,MAAOxB,KAEAwJ,EAAMjI,QACfrJ,EAAKrC,EAAM8L,IAAIzE,GAAM,CACnB9L,IAAOyE,EAAM6X,OAAOlE,EAAMjI,SAC1BnM,MAAOJ,EAAIa,EAAMkV,MAAM3V,EAAMC,SAC7BmM,MAAOxB,KAGTxK,EAAAA,MAAM,wCAA0C3C,cAAY2W,IAI9D,MAAMuF,EAAWlZ,EAAMmZ,OACjBxU,EAASuU,EAASpN,IAAI9E,MACtBiF,EAASiN,EAASpN,IAAIzD,GAAM,CAACsD,MAAOxM,EAAIwF,MAC9CuU,EAASE,QAAQze,EAAM,IAAI6b,GAAU0C,EAAUvU,EAAQA,EAAQsH,IAC/DiN,EAAS5W,UAAU,SAAU,MAG7BD,EAAGpC,OAAOoZ,QAAU,CAClBC,SAAUJ,EAASjY,MAAMxH,GAAM8f,YAEnC,CDgEYC,CAAW/f,EAAMuG,EAAOiL,GAC1B2M,EE5GK,SAASne,EAAMuG,EAAOiL,GACnC,MAAM5I,EAAKrC,EAAM8L,IAAI/D,GAAS,CAAC4D,MAAOV,EAAMU,SACtCuN,EAAWlZ,EAAMmZ,OAEvBD,EAASpN,IAAIzD,MACb6Q,EAAS5W,UAAU,SAAU,MAG7BD,EAAGpC,OAAOoZ,QAAU,CAClBC,SAAUJ,EAASjY,MAAMxH,GAAM8f,YAEnC,CFiGmBE,CAAahgB,EAAMuG,EAAOiL,GACnCjL,EAAMiB,MAAMxH,GAClBuG,EAAM0Z,WAEF9B,IAAcD,GAAQ/L,EAAI1J,KAAKyV,GAAS/L,EAAI1J,KAAK6W,KAInD5H,IACFuG,EAqBJ,SAAsBvG,EAASxM,EAAQ3E,GACrC,MAAMkS,EAASf,EAAQe,OACjB6G,EAAQ5H,EAAQ4H,MAChBY,EAAMxI,EAAQc,WAEdhS,EAAS,CACbgS,WAAYrO,GAAS+V,GAAO3Z,EAAMkG,UAAUyT,EAAIvf,QAAUuf,EAC1DzH,OAAQtO,GAASsO,GAAUlS,EAAMkG,UAAUgM,EAAO9X,QAAU8X,EAC5DvG,MAAQhH,GAGNwM,EAAQgB,QACVlS,EAAOuK,KAAOxK,EAAMoD,WAAW,CAACnG,MAAOkU,EAAQgB,SAGjD,GAAI4G,EAAO,CACT,MAAMa,EAAMb,EAAMc,UAClB5Z,EAAO6Z,eAAiBlW,GAASgW,GAAO5Z,EAAMkG,UAAU0T,EAAIxf,SAAWwf,EACvE3Z,EAAO8Z,WAAa/Z,EAAMnD,SAASkc,EAAMjc,OACzCmD,EAAO+Z,YAAcjB,EAAMkB,MAC7B,CAEA,OAAO9a,EAAIa,EAAM8L,IAAIjE,GAAQ5H,IAC/B,CA5Ceia,CAAa/I,EAASuG,EAAU1X,IAI7C,MAAMma,EAASna,EAAM8L,IAAI3D,GAAO,CAACwD,MAAO+L,KAClC0C,EAAQpa,EAAM8L,IAAIzD,GAAM,CAACsD,MAAOxM,EAAIgb,SAAU3b,EAAWwB,EAAMR,WAIpD,MAAb/F,EAAKkB,OACPA,EAAOlB,EAAKkB,KACZqF,EAAMoZ,QAAQze,EAAM,IAAI6b,GAAUxW,EAAOwX,EAAO2C,EAAQC,IACpD3gB,EAAKkN,IAAIlN,EAAKkN,GAAGjG,SAAQiG,KACvBA,EAAGwQ,QAAUxQ,EAAGuQ,QAAUvQ,EAAGyQ,SAC/BzX,EAAKA,MAAC,uCAERsX,GAAatQ,EAAI3G,EAAOrF,EAAK,IAGnC,CGpHe,SAAA0f,GAAS5gB,EAAMuG,GAC5B,MAAMI,EAASJ,EAAMI,OAAOka,OACtBpf,EAASzB,EAAKyB,QAAU,CAAE,EAC1BrB,EAAI6U,GAAOjV,EAAM2G,GACjBma,EAAerf,EAAOof,QAAU,CAAE,EAClC3f,EAAO4f,EAAa5f,WAAQ6D,EAC5ByP,EAAcsM,EAAatM,YAC3BlO,EAAQwa,EAAaxa,MACrBya,EAAS,CAAA,EAEf,IAAeC,EAAaxa,EAAQya,EAAhC5d,EAAQ,EAGZiR,GAAarN,SAAQvC,GAAK1E,EAAK0E,IAC1Bqc,EAAOrc,GAAK1E,EAAK0E,GAAIrB,EAAQA,GAASrD,EAAK0E,IAAM,IAEjDrB,GAAO6C,QAAM,mCAGlB,MAAMhG,EA4FR,SAAoBF,EAAMkhB,GACxB,IAAIhhB,EAAOF,EAAKE,MAAQgU,GAEnBlU,EAAKE,MAA6B,IAWzC,SAAoBF,GAClB,OAAOsU,GAAanD,QAAO,CAACpN,EAAO7D,IAAS6D,GAAS/D,EAAKE,GAAQ,EAAI,IAAI,EAC5E,CAboBihB,CAAWnhB,KAAgBA,EAAK6W,OAAQ7W,EAAK+W,SAC7D7W,EAAOkhB,EAAAA,aAAaF,GAAa/M,GAC7BkN,EAAAA,eAAeH,GAAa9M,GAC5BF,IAGN,OAAOhU,IAASiU,GAAWjU,EACvBmhB,EAAcA,eAACH,GAAa9M,GAC5BD,EACN,CAxGemN,CAAWthB,EAAMuG,EAAM2a,UAAU7d,IAGxCuC,EAAQ,CACZ2b,MAAsB,MAAdvhB,EAAKuhB,MACbR,OAAQA,EACR7gB,KAAQA,EACRshB,MAAiB,WAATthB,GAAsBE,EAAE+U,cAE5B+B,EAAUxR,EAAIa,EAAM8L,IAAI9E,GAAQ,KAAM,CAAC3H,MAMvC6b,EAAW/b,EAAIa,EAAM8L,IAAItE,GAAcvH,EAAS,CACpDtG,KAASA,EACTmD,MAASkD,EAAMnD,SAASC,GACxBU,MAASwC,EAAM2J,eAAe9P,EAAE,cAChC6X,MAAS1R,EAAMrB,SAAS9E,EAAE,gBAC1BoS,OAASjM,EAAM2J,eAAelQ,EAAKwS,QACnCkP,QAASnb,EAAMrB,SAASlF,EAAK2hB,aAC7BC,WAAYrb,EAAMrB,SAASlF,EAAK4hB,YAChCC,gBAAiBtb,EAAMrB,SAASlF,EAAK8hB,YAoDvC,OAhDI5hB,IAASiU,IACX8M,EAAW,CACT3K,GAAetW,EAAMqD,EAAOsD,EAAQlF,EAAOkC,UAC3C8T,GAAqBzX,EAAM2G,EAAQlF,EAAOqY,OAAQ2H,IAGpDjb,EAAOzC,MAAQyC,EAAOzC,OAASwC,EAAMkG,UAClC,kBAAiBlC,GAAMnK,EAAEmV,6BAKrBrV,IAASkU,GAChB6M,EAAW,CACThK,GAAuBjX,EAAMqD,EAAOsD,EAAQlF,EAAOkC,SAAU8d,GAC7DhK,GAAqBzX,EAAM2G,EAAQlF,EAAOqY,OAAQ2H,KAOpDT,Eb4EG,SAA4BhhB,EAAM2G,GACvC,MAAMvG,EAAI6U,GAAOjV,EAAM2G,GAGvB,MAAO,CACLyR,MAAShY,EAAE,aACXwV,QAASxV,EAAEuV,eACXoM,OAAS,CACP/H,KAAK,EACLC,QAAQ,GAEV+H,QAAS,CACPhI,IAAQ5Z,EAAE,cACV6Z,OAAQ7Z,EAAE,kBAGhB,Ca5FkB6hB,CAAmBjiB,EAAM2G,GACvCsa,EAAW,CACTtI,GAAmB3Y,EAAM2G,EAAQlF,EAAQggB,EAAUlX,GAAMyW,EAAYpL,WAGvEpP,EAAOiT,KAgFX,SAAwBzZ,EAAMuG,EAAO4T,GACnC,MAAMV,EAAOlP,GAAM2X,GAAW,OAAQliB,EAAMma,IACtCnD,EAAczM,GAAM2X,GAAW,cAAeliB,EAAMma,IACpDrC,EAAWvN,GAcnB,SAAqB9I,EAAQ8E,EAAOD,GAClC,OAAOuP,GAAY,WAAYpU,IlB3J1B,SAAkBP,EAAMqF,EAAOD,GACpC,MAAM5B,EAAI6B,EAAMI,OAAOL,MAAMA,GAC7B,OAAO5B,GAAKA,EAAExD,EAChB,CkBwJ4CihB,CAAS,WAAY5b,EAAOD,EACxE,CAhByB8b,CAAYjI,EAAM,GAAG1Y,OAAQ8E,EAAOuN,KAE3D,OAAO5L,kBACJ,iBAAgBuR,MAASzC,MAAgBc,KAC1CvR,EAEJ,CAzFkB8b,CAAeriB,EAAMuG,EAAO0a,EAAS,GAAG9G,QAIxD8G,EAAW,CACTjM,GAAW,CACT3O,KAAM3D,EACN6U,KAAML,EACNzV,OAlDgB,CAACF,MAAO,CAACgE,EAAG,CAACxE,MAAO,GAAIyE,EAAG,CAACzE,MAAO,KAmDnDoZ,MAAO8G,EACP/C,OAAQ8C,EACRxM,iBAKA5O,EAAM2b,OACRN,EAASxY,KZ7FE,SAASzI,EAAM2G,EAAQ4P,EAAYW,GAChD,MAAM9W,EAAI6U,GAAOjV,EAAM2G,GAEjBlF,EAAS,CACbF,MAAO,CAACqV,QAASnC,IACjBpT,OAAQ,CACNuV,QAASlC,GACTnP,EAAG,CAAC/B,MAAO,CAACsC,MAAO,YACnBN,EAAG,CAAChC,MAAO,CAACsC,MAAO,aAErBgR,KAAM,CAACF,QAASnC,KAwBlB,OArBAnT,EAAYG,EAAQ,CAClB+e,OAAapgB,EAAE,eACfkiB,QAAaliB,EAAE,eACfmiB,OAAa,CAAC5hB,OAAQ8Z,IACtB+H,MAAa,CAAC7hB,OAAQ+Z,IACtBtC,MAAa,CAACzX,OAAQ6Z,IACtBnC,SAAa,CAAC1X,OAAQga,IACtBhD,KAAa3X,EAAKuhB,MAClB1K,KAAazW,EAAE,cACfwX,YAAaxX,EAAE,gBACfyX,KAAazX,EAAE,aACf0X,SAAa1X,EAAE,iBACf2X,UAAa3X,EAAE,kBACf4X,WAAa5X,EAAE,mBACf6X,MAAa7X,EAAE,cACfqiB,WAAariB,EAAE,oBACd,CACDgY,MAAahY,EAAE,cACfiY,SAAajY,EAAE,mBAGVgW,GAAU,CACflW,KAAO6U,GACP1O,KAAOvD,EACPwD,MAAOyN,GACPwD,KAAOL,EACPzV,UACC8U,EACL,CYoDkBmM,CAAY1iB,EAAM2G,EAAQlF,EAAO8f,MAAOrK,IAIjD4G,GACL9I,GAAW,CACT3O,KAAa7D,EACb+U,KAAaL,EACbzV,OAAaD,EAAamhB,GAAkBviB,EAAGJ,EAAM2G,GAASma,EAAcvM,IAC5E4F,MAAa8G,EACb/F,KAAa9a,EAAE,QACf+a,YAAa/a,EAAE,eACf6a,OAAa7a,EAAE,UACfc,OACAsT,cACAlO,UAEFC,EAEJ,CAoBA,SAASoc,GAAkBviB,EAAGJ,EAAM2G,GAClC,MAAMlF,EAAS,CAACF,MAAO,CAAE,EAAEF,OAAQ,CAAC,GAoBpC,OAlBAC,EAAYG,EAAQ,CAClB+e,OAAcpgB,EAAE,UAChBiF,OAAcjF,EAAE,UAChB4hB,QAAc5hB,EAAE,WAChBwiB,aAAcxiB,EAAE,gBAChByiB,aAAcziB,EAAE,gBAChByW,KAAczW,EAAE,aAChB2W,OAAc3W,EAAE,eAChB4W,YAAcrQ,EAAOqQ,YACrB0C,WAAc/S,EAAO+S,WACrBnU,EAAcnF,EAAE,WAChBoF,EAAcpF,EAAE,WAGhB0hB,OAAc9hB,EAAK8hB,OACnBF,WAAc5hB,EAAK4hB,aAGdngB,CACT,CAaA,SAASygB,GAAWhhB,EAAMlB,EAAMma,GAC9B,OAAOna,EAAKkB,GACP,UAASlB,EAAKkB,aACf2U,GAAY3U,EAAMiZ,EAAM,GAAG1Y,OACjC,CL7KAsb,GAAU+F,YAAc,SAASvc,EAAOqS,GACtC,MAAM+C,EAAI/C,EAAQxX,OACZoR,EAASoG,EAAQ+C,EAAE,GACnBmB,EAASlE,EAAQ+C,EAAE,GAEzB,IAAInK,EAAQoH,EAAQ,GAChBoE,EAAO,KACPpB,EAAI,EAQR,IANIpK,GAAwB,SAAfA,EAAMtR,OACjBsR,EAAQoH,EAAQ,IAIlBrS,EAAM8L,IAAIuG,EAAQ,IACXgD,EAAED,IAAKC,EACZhD,EAAQgD,GAAGpV,OAAO0L,MAAQxM,EAAIkT,EAAQgD,EAAE,IACxCrV,EAAM8L,IAAIuG,EAAQgD,IACM,cAApBhD,EAAQgD,GAAG1b,OAAsB8c,EAAOpE,EAAQgD,IAGtD,OAAO,IAAImB,GAAUxW,EAAOiL,EAAOsL,EAAQtK,EAAQwK,EACrD,EAoDAD,GAAUgG,UAAY,CACpBhR,UAAUxL,EAAO/C,EAAOuN,GACtB,MAAMsM,EAAKnU,KACLkU,EAAQC,EAAGxL,SAAWwL,EAAGxL,OAAS,CAAA,GAClC+K,EAAIM,GAAS1Z,GAEnB,IAAIgH,EAAG7F,EAAGqN,EAqBV,OAnBS,MAAL4K,IACFrW,EAAQ8W,EAAG9W,MACXiE,EAAI4S,EAAMR,IAGPpS,EAUMuG,GAAQA,EAAKvN,OACtB2Z,GAAa5W,EAAOiE,EAAEwY,IAAIxc,OAAQuK,IAVlCiB,EAAI,CACFC,QAAS1L,EAAMgD,SAAS/F,EAAO,OAC/B0O,MAAOxM,EAAI2X,EAAGP,SAEZ/L,GAAQA,EAAKvN,OAAO2Z,GAAa5W,EAAOyL,EAAGjB,GAC/CpM,EAAI4B,EAAM8L,IAAIjF,GAAU4E,IACxBxH,EAAIjE,EAAM8L,IAAI9E,GAAQ,CAAC2E,MAAOxM,EAAIf,MAClC6F,EAAI,CAACwY,IAAKre,EAAGe,IAAKA,EAAI8E,IACb,MAALoS,IAAWQ,EAAMR,GAAKpS,IAKrBA,EAAE9E,GACV,EAEDud,YACE,OAAOvd,EAAIwD,KAAKsJ,OACjB,EAEDtB,UAAU3K,EAAO/C,GACf,OAAO4Z,GAAM7W,EAAO2C,KAAM,SAAU,SAAU1F,GAAO,EACtD,EAEDyN,UAAU1K,EAAO/C,GACf,OAAO4Z,GAAM7W,EAAO2C,KAAM,SAAU,SAAU1F,GAAO,EACtD,EAEDqN,UAAUtK,EAAO/C,EAAOuN,GACtB,OAAOqM,GAAM7W,EAAO2C,KAAM,OAAQ,SAAU1F,EAAOuN,IAAQ,EAC5D,EAED+K,UAAUvV,EAAO/C,GACf,OAAO4Z,GAAM7W,EAAO2C,KAAM,SAAU,aAAc1F,GAAO,EAC1D,EAED0f,UAAU3c,EAAO/C,GACf,OAAO4Z,GAAM7W,EAAO2C,KAAM,SAAU,aAAc1F,GAAO,GAAM,EACjE,GMnIF,MAAM2f,GAAa,kBAAiBlQ,0BAA4BC,WAEjD,SAAAkQ,GAASpjB,EAAMuG,GAG5B,MAAMnG,EAAI6U,GAFVjV,EAAOsD,EAAAA,SAAStD,GAAQ,CAAC2X,KAAM3X,GAAQA,EAEhBuG,EAAMI,OAAO4a,OAC9B9f,EAASzB,EAAKyB,QAAU,CAAE,EAC1B8U,EAAa9U,EAAOqE,OAAS,CAAE,EAC/B5E,EAAOqV,EAAWrV,WAAQ6D,EAC1ByP,EAAc+B,EAAW/B,YACzBlO,EAAQiQ,EAAWjQ,MACnB2a,EAAW,GAIX/J,EAAUxR,EAAIa,EAAM8L,IAAI9E,GAAQ,KAAM,CAD9B,CAAE,MAYhB,OARA0T,EAASxY,KAqDX,SAAoBzI,EAAMI,EAAGmW,EAAYW,GACvC,MAAMzC,EAAO,CAAC1T,MAAO,GACf4W,EAAO3X,EAAK2X,KACZlW,EAAS,CACPF,MAAO,CAACqV,QAASnC,GACjBpT,OAAQ,CAACuV,QAAS,CAAC7V,MAAO,IAC1B+V,KAAM,CAACF,QAASnC,IAuBxB,OApBAnT,EAAYG,EAAQ,CAClBkW,KAAYA,EACZS,MAAY,CAACzX,OAAQ,yBACrB6hB,MAAY,CAAC7hB,OAAQ,yBACrBsX,MAAY,CAACtX,OAAQ,yBACrB0X,SAAY,MACZgL,GAAYjjB,EAAE,MACdkjB,GAAYljB,EAAE,MACdyW,KAAYzW,EAAE,SACdyX,KAAYzX,EAAE,QACd0X,SAAY1X,EAAE,YACd2X,UAAY3X,EAAE,aACd4X,WAAY5X,EAAE,cACdqiB,WAAYriB,EAAE,eACb,CACDgY,MAAYhY,EAAE,SACdoiB,MAAYpiB,EAAE,SACdiY,SAAYjY,EAAE,cAGTgW,GAAU,CACflW,KAAM6U,GACN1O,KAAMrD,EACNsD,MAAO0N,GACPuD,KAAML,EACNzV,UACC8U,EACL,CAzFgBgN,CAAWvjB,EAAMI,EA2BjC,SAAqBJ,GACnB,MAAMyB,EAASzB,EAAKyB,OACpB,OAAQA,GAAUA,EAAO8f,OAAUzgB,SAAO,CACxCI,KAAMlB,EAAKkB,KACXsT,YAAaxU,EAAKwU,YAClBlO,MAAOtG,EAAKsG,OACX7E,EACL,CAlCoC+hB,CAAYxjB,GAAOkX,IAGjDlX,EAAKyjB,UACPxC,EAASxY,KAuFb,SAAuBzI,EAAMI,EAAGmW,EAAYW,GAC1C,MAAMzC,EAAO,CAAC1T,MAAO,GACf4W,EAAO3X,EAAKyjB,SACZhiB,EAAS,CACPF,MAAO,CAACqV,QAASnC,GACjBpT,OAAQ,CAACuV,QAAS,CAAC7V,MAAO,IAC1B+V,KAAM,CAACF,QAASnC,IAuBxB,OApBAnT,EAAYG,EAAQ,CAClBkW,KAAYA,EACZS,MAAY,CAACzX,OAAQ,yBACrB6hB,MAAY,CAAC7hB,OAAQ,yBACrBsX,MAAY,CAACtX,OAAQ,yBACrB0X,SAAY,MACZgL,GAAYjjB,EAAE,MACdkjB,GAAYljB,EAAE,MACdyW,KAAYzW,EAAE,iBACdyX,KAAYzX,EAAE,gBACd0X,SAAY1X,EAAE,oBACd2X,UAAY3X,EAAE,qBACd4X,WAAY5X,EAAE,sBACdqiB,WAAYriB,EAAE,uBACb,CACDgY,MAAYhY,EAAE,SACdoiB,MAAYpiB,EAAE,SACdiY,SAAYjY,EAAE,cAGTgW,GAAU,CACflW,KAAO6U,GACP1O,KAAOpD,EACPqD,MAAO2N,GACPsD,KAAOL,EACPzV,UACC8U,EACL,CA3HkBmN,CAAc1jB,EAAMI,EAAGqB,EAAOgiB,SAAUvM,IAIjD4G,GACL9I,GAAW,CACT3O,KAAatD,EACbwU,KAAaL,EACbzV,OAAakiB,GAAYvjB,EAAGmW,GAC5B4D,MAAa8G,EACb/F,KAAa9a,EAAE,QACf+a,YAAa/a,EAAE,eACf6a,OAAa7a,EAAE,UACfc,OACAsT,cACAlO,UAEFC,EAEJ,CAaA,SAASod,GAAYvjB,EAAGmW,GACtB,MAAM9U,EAAS,CAACF,MAAO,CAAE,EAAEF,OAAQ,CAAC,GAapC,OAXAC,EAAYG,EAAQ,CAClB+e,OAAapgB,EAAE,UACfmiB,OAAaniB,EAAE,UACfgY,MAAa,CAACzX,OAAQsV,IACtBuM,MAAa,CAAC7hB,OAAQwiB,IACtBlL,MAAa7X,EAAE,SACfwjB,MAAaxjB,EAAE,SACfiF,OAAajF,EAAE,WAAa,EAC5B4hB,QAAa5hB,EAAE,qBAGVoB,EAAaC,EAAQ8U,EAAYhC,GAC1C,CC3Ee,SAAS8J,GAAU3N,EAAMnK,GACtC,MAAMsd,EAAa,GAEfnT,EAAKvD,WACPuD,EAAKvD,UAAUlG,SAAQ8X,IACrB8E,EAAWpb,KAAK2S,GAAe2D,EAAIxY,GAAO,IAI1CmK,EAAKxD,IACPwD,EAAKxD,GAAGjG,SAAQiG,IACdsQ,GAAatQ,EAAI3G,EAAOmK,EAAKxP,KAAK,IAItCqF,EAAMkL,gBAAgBf,EAAKxP,KAM7B,SAAiBwP,EAAMnK,EAAO4L,GAC5B,MAAM2K,EAAS,GACf,IAGIgH,EAAUlI,EAAGD,EAAGL,EAAGtF,EAHnB9K,EAAS,KACT0S,GAAS,EACTmG,GAAW,EAGXrT,EAAK8B,OAEHrI,GAASuG,EAAK8B,SAAWpI,GAAUsG,EAAKoR,SAE1ChF,EAAOrU,KAAKub,GAAKzd,EAAOmK,IACxBoM,EAAOrU,KAAKyC,EAAS+Y,OAGrBnH,EAAOrU,KAAKyC,EAAS+Y,GAAQ,CAC3B1S,QAASb,EAAK8B,OACd0R,QAASxT,EAAKoR,UAGTpR,EAAKyT,IAEV/Z,GAAUsG,EAAKyT,MAAQ/Z,GAAUsG,EAAKoR,SAExChF,EAAOrU,KAAKub,GAAKzd,EAAOmK,IACxBoM,EAAOrU,KAAKyC,EAAS+Y,OAGrBnH,EAAOrU,KAAKyC,EAAS+Y,GAAQ,CAC3BG,SAAU1T,EAAKyT,IACfD,QAASxT,EAAKoR,UAGTpR,EAAKxF,SAEdA,EAAS4Y,EAAW9c,EAAAA,MAAM0J,EAAKxF,QAC5BlH,KAAIqN,GAAK3L,EAAIa,EAAMoK,QAAQU,GAAGyL,UACjCA,EAAOrU,KAAK,OAId,IAAKmT,EAAE,EAAGD,EAAExJ,EAAI/Q,OAAQwa,EAAED,IAAKC,EAC7BN,EAAInJ,EAAIyJ,GACR5F,EAAIsF,EAAEI,SAEDxQ,GAAW8K,EAAE9K,QAChB4R,EAAOrU,KAAKyC,EAAS+Y,MAEvBnH,EAAOrU,KAAK6S,GAERtF,EAAEiJ,YAAW8E,GAAW,GACxB/N,EAAEqO,WAAaN,IAAUnG,GAAS,GAElC5H,EAAE9K,OAAQA,EAASoQ,EACdtF,EAAEkJ,UAAShU,EAAS,MAG3B4Y,IACFnI,EAAImI,EAAS1iB,OAAS,EACtB0b,EAAO,GAAKrO,GAAM,CAChB6V,OAAQ1G,EACR1L,MAAOyJ,EAAImI,EAAWA,EAAS,MAE7BlG,GAAUjC,IAEZmB,EAAOyH,OAAO,EAAG,EAAGN,OAInB/Y,GAAQ4R,EAAOrU,KAAKwb,MAEzB,OADAnH,EAAOrU,KAAKmG,GAAM,CAAA,IACXkO,CACT,CA9EmC0H,CAAQ9T,EAAMnK,EAAOsd,GACxD,CA+EA,SAASI,GAAQzR,GACf,MAAM9N,EAAI6I,GAAQ,CAAE,EAAEiF,GAEtB,OADA9N,EAAEgX,SAAW,CAACxQ,QAAQ,GACfxG,CACT,CAEA,SAASsf,GAAKzd,EAAOmK,GACnB,OAAO1C,GAAK,CACVmW,IAAQzT,EAAKyT,IAAM5d,EAAMrB,SAASwL,EAAKyT,UAAOpf,EAC9C0f,MAAQ/T,EAAK+T,MAAQle,EAAMrB,SAASwL,EAAK+T,YAAS1f,EAClDyN,OAAQ9B,EAAK8B,OAASjM,EAAMrB,SAASwL,EAAK8B,aAAUzN,EACpD+c,OAAQvb,EAAM2J,eAAeQ,EAAKoR,SAEtC,CC7GA,MAAM4C,GAAMlE,GAAUA,IAAWrN,IAAUqN,IAAWxN,GAGzC2R,GAAUA,CAACnE,EAAQ7b,EAAGC,IAAMuF,GAASqW,GAC9CoE,GAAcpE,EAAO7f,OAAQgE,EAAGC,GAChC4b,IAAWvN,IAAQuN,IAAWxN,GAAMrO,EAAIC,EAG/BigB,GAAMA,CAACrE,EAAQ7b,EAAGC,IAAMuF,GAASqW,GAC1CsE,GAAOtE,EAAO7f,OAAQgE,EAAGC,GACzB8f,GAAIlE,GAAU7b,EAAIC,EAGTmgB,GAAMA,CAACvE,EAAQ7b,EAAGC,IAAMuF,GAASqW,GAC1CwE,GAAOxE,EAAO7f,OAAQgE,EAAGC,GACzB8f,GAAIlE,GAAU5b,EAAID,EAETsgB,GAAQA,CAACzE,EAAQ7b,EAAGC,IAAMuF,GAASqW,GAC5C0E,GAAU1E,EAAO7f,OAAQgE,EAAGC,GAC5B4b,IAAWxN,GAAM,CAACjS,MAAO4D,GAAK,CAAC5D,MAAO6D,GAE7BugB,GAAUA,CAAC3E,EAAQ7b,EAAGC,IAAMuF,GAASqW,GAC9C4E,GAAY5E,EAAO7f,OAAQgE,EAAGC,GAC9B4b,IAAWtN,GAAQ,CAACnS,MAAO4D,GAAK,CAAC5D,MAAO6D,GAEtCkgB,GAASA,CAACO,EAAS1gB,EAAGC,IAAM0gB,GAC/B,GAAED,UAAgBrS,UAAWqS,UAAgBlS,MAAWxO,EAAGC,GAGxDogB,GAASA,CAACK,EAAS1gB,EAAGC,IAAM0gB,GAC/B,GAAED,UAAgBrS,UAAWqS,UAAgBlS,MAAWxO,EAAGC,GAGxDggB,GAAgBA,CAACS,EAAS1gB,EAAGC,IAAM2gB,GACtC,GAAEF,UAAgBpS,UAAYoS,UAAgBrS,MAAQrO,EAAGC,GAGtDsgB,GAAYA,CAACG,EAAS1gB,EAAGC,IAAM2gB,GAClC,GAAEF,UAAgBrS,MAAQrO,EAAGC,GAG1BwgB,GAAcA,CAACC,EAAS1gB,EAAGC,IAAM2gB,GACpC,GAAEF,UAAgBnS,MAAUvO,EAAGC,GAG5B0gB,GAAQA,CAAC3d,EAAMhD,EAAGC,KAEtBD,EAAS,MAALA,EAAY/D,EAAQ+D,GAAKA,EAC7BC,EAAS,MAALA,EAAYhE,EAAQgE,GAAKA,EAEzB4gB,GAAS7gB,IAAM6gB,GAAS5gB,GAInB,CAACjE,OAAS,GAAEgH,QAFnBhD,EAAIA,EAAKA,EAAEhE,QAAU4C,EAAWA,YAACoB,EAAE5D,OAAU,YAC7C6D,EAAIA,EAAKA,EAAEjE,QAAU4C,EAAWA,YAACqB,EAAE7D,OAAU,SAItC,CAACD,EAAAA,OAAO,CAAC6G,QAAOhD,IAAI6G,OAAO5G,GAAK,KAIrC4gB,GAAW9hB,GACR,MAAPA,GAA2C,IAA5BoE,OAAOC,KAAKrE,GAAKtC,OAG5BmkB,GAASA,CAAC5d,EAAMhD,EAAGC,KAAO,CAC9BjE,OAAS,GAAEgH,QAAW8d,GAAO9gB,UAAU8gB,GAAO7gB,QAGnC8gB,GAAWA,CAACL,EAAS/J,EAAG1W,EAAGH,EAAGI,KAAO,CAChDlE,QAAc,MAAL8D,EAAa,GAAE4gB,UAAgBpS,UAAYwS,GAAOhhB,SAAW,KACxD,MAALG,EAAa,GAAEygB,UAAgBlS,UAAcsS,GAAO7gB,SAAW,KAC1D,MAALC,EAAa,GAAEwgB,UAAgBnS,UAAauS,GAAO5gB,SAAW,KACzD,MAALyW,EAAa,GAAE+J,UAAgBrS,UAAWyS,GAAOnK,SAAW,IAC7D,WAGJmK,GAASjb,GAAKL,GAASK,GACzBA,EAAE7J,OACG,MAAL6J,EAAY,KAAOjH,EAAWA,YAACiH,GAEtBpF,GAAOA,CAACugB,EAAM5kB,IAAoB,IAAVA,EAAc,EAAIoJ,GAASwb,GAC5D,CAAChlB,OAAS,IAAGglB,EAAKhlB,aAAaI,KAC/B,CAACA,MAAO4kB,EAAO5kB,GAEN6kB,GAAQA,CAAC7kB,EAAO8kB,KAC3B,MAAMnhB,EAAI3D,EAAMJ,OAChB,OAAO+D,GAAKA,EAAEohB,SAAS,UACnB,CAACnlB,OAAQ+D,EAAEqhB,MAAM,GAAI,GAAKF,EAAKllB,QAC/BI,CAAK,ECzFX,SAASilB,GAASrd,EAAMhC,EAAQsf,EAAY3f,GAC1C,IAAI4f,EAEJ,GAAIvf,GAAU/E,EAAAA,eAAe+E,EAAQgC,GACnC,OAAOhC,EAAOgC,GAEX,GAAI/G,EAAcA,eAACqkB,EAAYtd,GAClC,OAAOsd,EAAWtd,GAEf,GAAIA,EAAK7B,WAAW,SAAU,CACjC,OAAQ6B,GACN,IAAK,aACHud,EAAY,OACZ,MACF,IAAK,YACL,IAAK,gBACL,IAAK,kBACHA,EAAYvd,EAAK,GAAG4S,cAAgB5S,EAAKod,MAAM,GAEnD,OAAOzf,EAAMyN,IAAiBmS,EAC/B,CACI,GAAIvd,EAAK7B,WAAW,SAAU,CACjC,OAAQ6B,GACN,IAAK,aACHud,EAAY,OACZ,MACF,IAAK,YACL,IAAK,gBACHA,EAAYvd,EAAK,GAAG4S,cAAgB5S,EAAKod,MAAM,GAEnD,OAAOzf,EAAMwN,IAAiBoS,EAChC,CAEA,OAAO,IACT,CAEA,SAASne,GAAKoe,GACZ,MAAMniB,EAAM,CAAA,EACZ,IAAK,MAAMoiB,KAAOD,EAChB,GAAKC,EACL,IAAK,MAAMtkB,KAAOskB,EAAKpiB,EAAIlC,GAAO,EAEpC,OAAOgG,OAAOC,KAAK/D,EACrB,CCHA,SAASqiB,GAASrmB,EAAMsmB,GACtB,MAAO,CAACjjB,MAAOrD,EAAKqD,MAAO2B,MAAOshB,EACpC,CCrCe,SAAAC,GAASvmB,EAAM2G,EAAQ4P,EAAYW,EAASjS,GACzD,MAAM7E,EAAI6U,GAAOjV,EAAM2G,GACjB6Z,EAASxgB,EAAKwgB,OACdgG,EAASxmB,EAAKymB,UACdd,EAAOhB,GAAQnE,EAAQ,GAAI,GAC3Bnb,EAqDR,SAAqBA,EAAQsgB,GAC3B,GAAa,IAATA,QAEG,GAAK1lB,EAAAA,SAASoF,GAId,CACL,IAAI5B,EAAQ4B,EAASvE,EAAMA,OAAC,CAAE,EAAEuE,GAChC,KAAqB,MAAd5B,EAAM2B,MAAc,CACzB,IAAKnF,EAAQA,SAACwD,EAAM2B,MAIlB,OAHA3B,EAAM2B,KAAO+E,GAASwb,GAClB,CAAChlB,OAAS,IAAG8C,EAAM2B,YAAYugB,EAAKhlB,WACpC8C,EAAM2B,KAAOugB,EACVtgB,EAEP5B,EAAQA,EAAM2B,KAAOtE,EAAAA,OAAO,CAAA,EAAI2C,EAAM2B,KAE1C,CACA3B,EAAM2B,KAAOugB,CACf,MAhBEtgB,EAAS8E,GAASwb,GACd,CAAChlB,OAAS,IAAGglB,EAAKhlB,cAAc0E,GAAU,MAC1CsgB,GAAQtgB,GAAU,GAgBxB,OAAOA,CACT,CA5EiBqhB,CAAY1mB,EAAKqF,OAAQsgB,GAExC,IAAIpkB,EAAOuV,EAAMzV,EACjB,MAAMI,EAAS,CACbF,MAAOA,EAAQ,CAACqV,QAASnC,IACzBpT,OAAQA,EAAS,CAACuV,QAASlC,IAC3BoC,KAAMA,EAAO,CAACF,QAASnC,KAGzBnT,EAAYG,EAAQ,CAClBsV,OAAkB3W,EAAE,aACpBumB,UAAkBvmB,EAAE,WACpBsZ,WAAkBtZ,EAAE,YACpBuZ,iBAAkBvZ,EAAE,kBACpBwmB,cAAkBxmB,EAAE,eACpB4W,YAAkB5W,EAAE,eAGtB,MAAMymB,EAAU,CACdxjB,MAAQrD,EAAKqD,MACbG,MAAQqQ,GACR5O,KAAQA,EAAKA,KACbvD,MAAQuD,EAAKvD,MACb2D,OAAQJ,EAAKI,OACbC,MAAQlF,EAAE,cAGN0mB,EAAKjC,GAAIrE,EAAQ,CAAC7f,OAAQ,UAAW,CAACA,OAAQ,UAE9ComB,EAAYP,EACd,CAACnjB,MAAOmjB,EAAQxhB,MAAO,EAAGI,KAAMugB,EAAMtgB,OAAQA,GAC9C,CAACtE,MAAO,EAAGsE,OAAQA,GAEjB2hB,EAAUR,EACZ,CAACnjB,MAAOmjB,EAAQxhB,MAAO,EAAGI,KAAMugB,EAAMtgB,OAAQA,GAC9CvE,EAAAA,OAAOgmB,EAAI,CAAC1hB,KAAMugB,EAAMtgB,OAAQA,IASpC,OAPA9D,EAAMgE,EAAIlE,EAAOkE,EAAIsf,GAAIrE,EAAQqG,EAASE,GAC1CxlB,EAAMiE,EAAInE,EAAOmE,EAAIuf,GAAIvE,EAAQqG,EAASE,GAC1CxlB,EAAM0lB,GAAK5lB,EAAO4lB,GAAKlC,GAAIvE,EAAQwG,GACnCzlB,EAAM2lB,GAAK7lB,EAAO6lB,GAAKrC,GAAIrE,EAAQwG,GACnClQ,EAAKvR,EAAIsf,GAAIrE,EAAQqG,GACrB/P,EAAKtR,EAAIuf,GAAIvE,EAAQqG,GAEdzQ,GAAU,CACflW,KAAM2U,GACNxO,KAAMjE,EACNN,IAAM+R,GACN0D,KAAML,EACNzV,UACE8U,EACN,CCzDA,SAAS4Q,GAAU9jB,EAAO+jB,EAAWziB,EAAGC,EAAGN,GACzC,MAAO,CACL3D,OAAQ,gBAAkB0C,EAAlB,cACQA,EAAQ,oBACpB+jB,EAAY,IAAMziB,EAAI,IAAMC,EAAI,IAAMN,EAAI,IAElD,CCNe,SAAA+iB,GAASrnB,EAAM2G,EAAQ4P,EAAYW,GAChD,MAAM9W,EAAI6U,GAAOjV,EAAM2G,GACjB6Z,EAASxgB,EAAKwgB,OACdmF,EAAOhB,GAAQnE,GAAS,EAAG,GAEjC,IAAIjf,EAAOF,EACX,MAAMI,EAAS,CACbF,MAAOA,EAAQ,CACbqV,QAASnC,GACT8N,OAAQ3hB,EAAQR,EAAE,cAAe,OACjCgY,MAAO,CAACzX,OAAQsV,KAElB5U,OAAQA,EAASP,SAAO,CAAA,EAAIS,EAAO,CACjCqV,QAASlC,GACTiD,KAAM/W,EAAQZ,EAAKuhB,SAErBzK,KAAM,CACJF,QAASnC,KAIP6S,EAAW,CACf3mB,OAAS,eAAcX,EAAKqD,YAAYyS,GAAW,EAAG,EAAG,QA8B3D,OA3BAzU,EAAOkE,EAAIsf,GAAIrE,EAAQ8G,GACvBjmB,EAAOmE,EAAIuf,GAAIvE,EAAQ8G,GACvB/lB,EAAMihB,MAAQqC,GAAIrE,EAAQ/L,GAAMrP,GAAKugB,EAAM,KAC3CpkB,EAAM8W,SAAWwM,GAAIrE,EAAQyE,GAAMzE,EAAQrN,GAAQH,IAAM,CAACjS,MAAOoS,KACjE9R,EAAOmhB,MAAQjhB,EAAMihB,MACrBnhB,EAAOgX,SAAW9W,EAAM8W,SAExB/W,EAAYG,EAAQ,CAClBoV,KAAazW,EAAE,cACfwX,YAAaxX,EAAE,gBACfyX,KAAazX,EAAE,aACf0X,SAAa1X,EAAE,iBACf2X,UAAa3X,EAAE,kBACf4X,WAAa5X,EAAE,mBACf6X,MAAa7X,EAAE,cACfqiB,WAAariB,EAAE,oBACd,CACDgY,MAAahY,EAAE,cACfoiB,MAAapiB,EAAE,cACfiY,SAAajY,EAAE,mBAiBnB,SAAoBA,EAAGogB,EAAQ/e,EAAQ8U,GACrC,MAAMgR,EAAOA,CAACxmB,EAAOymB,IAAiB,MAATzmB,GACxBU,EAAOJ,OAAOmmB,GAAO5B,GAAMhlB,EAAQG,GAAQU,EAAOJ,OAAOmmB,KAAO,IAChE3lB,EAAI2lB,EAAKjR,GAERkR,EAAQF,EAAKnnB,EAAE,UAAW,KAC1BsnB,EAAQH,EAAKnnB,EAAE,UAAW,KAEhCqB,EAAOF,MAAMgmB,KAAOG,IAAUD,EAC1B7mB,EAAQ8mB,GACR7C,GAAIrE,EAAQ5f,EAAQ8mB,GAAQ9mB,EAAQ6mB,GAC1C,CAzBEE,CAAWvnB,EAAGogB,EAAQ/e,EAAQ8U,GAC9B9U,EAAOJ,OAAO+W,MAAQwN,GAAMnkB,EAAOJ,OAAO+W,MAAO7W,EAAM6W,OACvD3W,EAAOJ,OAAOmhB,MAAQoD,GAAMnkB,EAAOJ,OAAOmhB,MAAOjhB,EAAMihB,OACvD/gB,EAAOJ,OAAOgX,SAAWuN,GAAMnkB,EAAOJ,OAAOgX,SAAU9W,EAAM8W,UAEtDjC,GAAU,CACflW,KAAO6U,GACP1O,KAAO9D,EACP+D,MAAOyN,GACPwD,KAAOL,EACPzV,UACC8U,EACL,CCrDe,SAAAqR,GAAS5nB,EAAMuG,GAC5B,MAAMI,ELkCO,SAAS3G,EAAMuG,GAC5B,IAKIshB,EAAIC,EAAIhmB,EALR6E,EAASJ,EAAMI,OACfL,EAAQK,EAAOL,MACfyhB,EAAOphB,EAAOohB,KACd9iB,EAAuC,SAAhCsB,EAAM2a,UAAUlhB,EAAKqD,QAAqBsD,EAAOqhB,SACxDxH,EAASxgB,EAAKwgB,OAGlB,GAAIrW,GAASqW,GAAS,CACpB,MAAMyH,EAASlgB,GAAK,CACZpB,EAAOuhB,MAAOvhB,EAAOwhB,QAEvBC,EAAargB,GAAK,CAChBpB,EAAO0hB,QAAS1hB,EAAO2hB,WACvB3hB,EAAO4hB,SAAU5hB,EAAO6hB,YAIhC,IAAK1mB,KADL+lB,EAAK,CAAA,EACOI,GACVJ,EAAG/lB,GAAO+iB,GACRrE,EACAwF,GAASlkB,EAAK6E,EAAOuhB,MAAOH,EAAMzhB,GAClC0f,GAASlkB,EAAK6E,EAAOwhB,MAAOJ,EAAMzhB,IAKtC,IAAKxE,KADLgmB,EAAK,CAAA,EACOM,GACVN,EAAGhmB,GAAO4jB,GACRlF,EAAO7f,OACPqlB,GAASlkB,EAAK6E,EAAO0hB,QAASN,EAAMzhB,GACpC0f,GAASlkB,EAAK6E,EAAO2hB,WAAYP,EAAMzhB,GACvC0f,GAASlkB,EAAK6E,EAAO4hB,SAAUR,EAAMzhB,GACrC0f,GAASlkB,EAAK6E,EAAO6hB,UAAWT,EAAMzhB,GAG5C,MACEuhB,EAAMrH,IAAWxN,IAAOwN,IAAWrN,GAAUxM,EAAOuhB,MAAQvhB,EAAOwhB,MACnEL,EAAKnhB,EAAO,OAAS6Z,EAAO,GAAGiI,cAAgBjI,EAAOuF,MAAM,IAO9D,OAJgB8B,GAAMC,GAAM7iB,EACxBnE,EAAMA,OAAC,GAAIinB,EAAMF,EAAIC,EAAI7iB,GACzB8iB,CAGN,CKhFiB9B,CAAWjmB,EAAMuG,GAC1B9E,EAASzB,EAAKyB,QAAU,CAAE,EAC1BinB,EAAajnB,EAAOsmB,MAAQ,CAAE,EAC9B7mB,EAAOwnB,EAAWxnB,WAAQ6D,EAC1ByP,EAAckU,EAAWlU,YACzBlO,EAAQoiB,EAAWpiB,MACnBlG,EAAI6U,GAAOjV,EAAM2G,GACjB1B,E3B8BD,SAAkB7E,GACvB,MAAMoK,EAAIpK,EAAE,YACZ,IACI6E,EAAMvD,EADN2D,EAASjF,EAAE,cAwBf,OArBKoK,EAIMA,EAAE7J,QAEXsE,EAAO,CAACtE,OAAS,IAAG6J,EAAE7J,kCACtBe,EAAQ,CAACf,OAAS,IAAG6J,EAAE7J,wBAClBV,EAAAA,SAASoF,KACZA,EAAS,CAAC1E,OAAS,IAAG6J,EAAE7J,8BAA8B0E,OAEzC,WAANmF,GAETvF,EAAO,EACPvD,GAAQ,EACR2D,EAAS,IAETJ,EAAO,GACPvD,GAAQ,IAhBRuD,EAAO7E,EAAE,gBACTsB,EAAQtB,EAAE,cAkBL,CAACsB,QAAOuD,OAAMI,SACvB,C2BzDesjB,CAASvoB,GAGhBwF,EAAQ,CACZvC,MAAQrD,EAAKqD,MACbulB,QAAUxoB,EAAE,SACZ0Z,SAAU1Z,EAAE,UACZyoB,OAAUzoB,EAAE,QACZkP,SAAUlP,EAAE,UACZmhB,MAAsB,MAAdvhB,EAAKuhB,OAETrK,EAAUxR,EAAIa,EAAM8L,IAAI9E,GAAQ,CAAA,EAAI,CAAC3H,MAGrCkjB,EAAWpjB,EAAIa,EAAM8L,IAAIhF,GAAU,CACvChK,MAASkD,EAAMnD,SAASpD,EAAKqD,OAC7B3B,MAAS6E,EAAMrB,SAASD,EAAKvD,OAC7BqC,MAASwC,EAAM2J,eAAelQ,EAAK+oB,WACnCvW,OAASjM,EAAM2J,eAAelQ,EAAKwS,QACnCkP,QAASnb,EAAMrB,SAASlF,EAAK2hB,aAC7BC,WAAYrb,EAAMrB,SAASlF,EAAK4hB,YAChCC,gBAAiBtb,EAAMrB,SAASlF,EAAK8hB,YAIjCb,EAAW,GACjB,IAAIxH,EA8BJ,OA3BI7T,EAAMijB,MACR5H,EAASxY,KAAK8d,GAASvmB,EAAM2G,EAAQlF,EAAOonB,KAAMC,EAAU7jB,IAI1DW,EAAMgjB,QACRnP,EAAOrZ,EAAE,YACT6gB,EAASxY,KCnDE,SAASzI,EAAM2G,EAAQ4P,EAAYW,EAASuC,EAAMxU,GAC/D,MAAM7E,EAAI6U,GAAOjV,EAAM2G,GACjB6Z,EAASxgB,EAAKwgB,OACdmF,EAAOhB,GAAQnE,GAAS,EAAG,GAEjC,IAAIjf,EAAOuV,EAAMzV,EACjB,MAAMI,EAAS,CACbF,MAAOA,EAAQ,CAACqV,QAASnC,IACzBpT,OAAQA,EAAS,CAACuV,QAASlC,IAC3BoC,KAAMA,EAAO,CAACF,QAASnC,KAGzBnT,EAAYG,EAAQ,CAClBsV,OAAkB3W,EAAE,aACpBumB,UAAkBvmB,EAAE,WACpBsZ,WAAkBtZ,EAAE,YACpBuZ,iBAAkBvZ,EAAE,kBACpBwmB,cAAkBxmB,EAAE,eACpB4W,YAAkB5W,EAAE,eAGtB,MAAM4oB,EAAWpoB,EAAQ6Y,GACzBuP,EAAS5jB,KAAOugB,EAEhB,MAAMkB,EAAU,CACdxjB,MAAQrD,EAAKqD,MACbG,MAAQqQ,GACR5O,KAAQA,EAAKA,KACbvD,MAAQuD,EAAKvD,MACb2D,OAAQJ,EAAKI,OACbC,MAAQlF,EAAE,cAWZ,OARAiB,EAAOmE,EAAIjE,EAAMiE,EAAIqf,GAAIrE,EAAQ/L,GAAMoS,GACvCxlB,EAAO6lB,GAAK3lB,EAAM2lB,GAAKrC,GAAIrE,EAAQwI,GACnClS,EAAKvR,EAAIsf,GAAIrE,EAAQqG,GAErBxlB,EAAOkE,EAAIhE,EAAMgE,EAAIwf,GAAIvE,EAAQ/L,GAAMoS,GACvCxlB,EAAO4lB,GAAK1lB,EAAM0lB,GAAKlC,GAAIvE,EAAQwI,GACnClS,EAAKtR,EAAIuf,GAAIvE,EAAQqG,GAEdzQ,GAAU,CACflW,KAAM2U,GACNxO,KAAM/D,EACNR,IAAM+R,GACN0D,KAAML,EACNzV,UACC8U,EACL,CDGkB0S,CAAUjpB,EAAM2G,EAAQlF,EAAOmnB,MAAOE,EAAUrP,EAAMxU,KAIlEW,EAAMkU,SACRL,EAAO7T,EAAMgjB,MAAQnP,EAAO,EAC5BwH,EAASxY,KFhDE,SAASzI,EAAM2G,EAAQ4P,EAAYW,EAASuC,EAAMxU,GAC/D,MAAM7E,EAAI6U,GAAOjV,EAAM2G,GACjB6Z,EAASxgB,EAAKwgB,OACdnd,EAAQrD,EAAKqD,MACbsiB,EAAOhB,GAAQnE,GAAS,EAAG,GAC3B0I,EAAQ3e,GAAMnK,EAAE,eAChB+oB,EAAc5e,GAAMnK,EAAE,qBACtBgpB,EAAahpB,EAAE,cACfipB,EAAgBjpB,EAAE,iBAExB,IACIiB,EADAioB,EAAoB,IAAVJ,KAAiBA,EAG/B,MAAMF,EAAWpoB,EAAQ6Y,GACzBuP,EAAS5jB,KAAOugB,EAChBqD,EAAS3jB,OAASzE,EAAQR,EAAE,iBAAmB,GAC/C4oB,EAAS3jB,OAAOD,KAAOugB,EAEvB,MAAMkB,EAAU,CACdxjB,MAAQA,EACRG,MAAQqQ,GACR5O,KAAQ,GACRI,OAAQ6Q,GAAajR,EAAKI,OAAQjF,EAAE,iBAGhCgY,EAAQyM,GAAIrE,EAChB8I,EACInC,GAAU9jB,EAAO6lB,EAAO,SAAU,UAAW,YAC7C,CAACnoB,MAAO,UACZokB,GAAQ3E,EAAQ,OAAQ,UAGpBnI,EAAWwM,GAAIrE,EACnByE,GAAMzE,EAAQ,SAAU,OACxB8I,EACInC,GAAU9jB,EAAO6lB,EAAO,QAAS,WAAY,YAC7C,CAACnoB,MAAO,WAGRwoB,EAAapC,GAAU9jB,EAAO6lB,EAAQ,KAAIC,KAAgBA,EAAa,GAC7EG,EAAUA,GAAWH,EAErB,MAAM5nB,EAAQ,CACZqV,QAASnC,GACTlP,EAAGsf,GAAIrE,EAAQqG,EAASmC,GACxBxjB,EAAGuf,GAAIvE,EAAQqG,EAASmC,IAGpBvnB,EAAS,CACbF,MAAOA,EACPF,OAAQA,EAAS,CACfuV,QAASlC,GACTiD,KAAM,CAACnU,MAAOiQ,IACdlO,EAAGhE,EAAMgE,EACTC,EAAGjE,EAAMiE,EACT4S,QACAC,YAEFvB,KAAM,CACJF,QAASnC,GACTlP,EAAGhE,EAAMgE,EACTC,EAAGjE,EAAMiE,IAIblE,EAAYG,EAAQ,CAClB4hB,IAAK+F,GAAcE,EAAUzE,GAAIrE,EAAQ+I,GAAc,KACvDjG,IAAK+F,GAAiBC,EAAUvE,GAAIvE,EAAQ+I,GAAc,OAG5DjoB,EAAYG,EAAQ,CAClB+gB,MAAapiB,EAAE,cACfyW,KAAazW,EAAE,cACfwX,YAAaxX,EAAE,gBACfyX,KAAazX,EAAE,aACf0X,SAAa1X,EAAE,iBACf4X,WAAa5X,EAAE,mBACf2X,UAAa3X,EAAE,kBACf6X,MAAa7X,EAAE,cACfqiB,WAAariB,EAAE,oBACd,CACDgY,MAAagR,EACb/Q,SAAagR,IAGf,MAAM/J,EAAUlf,EAAE,cAClB,IAAIsX,EAAUtX,EAAE,gBAiBhB,OAdAsX,EAAUA,GAAW4H,EAAQ,CAC3B9G,WAAYpY,EAAE,mBACdqY,OAAQf,EACRgB,MAAO,cACP4G,MAAOA,EAAQ,CAACjc,QAAOmd,SAAQJ,UAAWd,GAAS,WACjDva,EAEA1D,EAAO+W,QAAUA,IACnB/W,EAAO+W,MAAQwN,GAAMvkB,EAAO+W,MAAOA,IAEjC/W,EAAOgX,WAAaA,IACtBhX,EAAOgX,SAAWuN,GAAMvkB,EAAOgX,SAAUA,IAGpCjC,GAAU,CACflW,KAAO6U,GACP1O,KAAOhE,EACPiE,MAAOwN,GACPhS,IAAO+R,GACP0D,KAAOL,EACPzV,SACAiW,WACCnB,EACL,CEhEkBiT,CAAWxpB,EAAM2G,EAAQlF,EAAOqY,OAAQgP,EAAUrP,EAAMxU,KAIpEW,EAAM0J,QACR2R,EAASxY,KJ9DE,SAASzI,EAAM2G,EAAQ4P,EAAYW,GAChD,MAAM9W,EAAI6U,GAAOjV,EAAM2G,GACjB6Z,EAASxgB,EAAKwgB,OAEpB,IAAIjf,EAAOF,EACX,MAAMI,EAAS,CACbF,MAAOA,EAAQ,CAACqV,QAASnC,IACzBpT,OAAQA,EAAS,CAACuV,QAASlC,IAC3BoC,KAAM,CAACF,QAASnC,KAGlBnT,EAAYG,EAAQ,CAClBsV,OAAkB3W,EAAE,eACpBumB,UAAkBvmB,EAAE,aACpBsZ,WAAkBtZ,EAAE,cACpBuZ,iBAAkBvZ,EAAE,oBACpB4W,YAAkB5W,EAAE,eACpBwmB,cAAkBxmB,EAAE,mBAGtB,MAAMqpB,EAAOpD,GAASrmB,EAAM,GACtB0pB,EAAOrD,GAASrmB,EAAM,GAQ5B,OANAuB,EAAMgE,EAAIlE,EAAOkE,EAAIsf,GAAIrE,EAAQiJ,EAAMhV,IACvClT,EAAM0lB,GAAK5lB,EAAO4lB,GAAKpC,GAAIrE,EAAQkJ,GAEnCnoB,EAAMiE,EAAInE,EAAOmE,EAAIuf,GAAIvE,EAAQiJ,EAAMhV,IACvClT,EAAM2lB,GAAK7lB,EAAO6lB,GAAKnC,GAAIvE,EAAQkJ,GAE5BtT,GAAU,CACflW,KAAM2U,GACNxO,KAAMlE,EACNoV,KAAML,EACNzV,UACC8U,EACL,CI2BkBoT,CAAW3pB,EAAM2G,EAAQlF,EAAO6N,OAAQ4H,IAIpDtR,EAAM2b,OACRN,EAASxY,KAAK4e,GAAUrnB,EAAM2G,EAAQlF,EAAO8f,MAAOrK,IAI/C4G,GACL9I,GAAW,CACT3O,KAAanE,EACbqV,KAAaL,EACbzV,OAAaD,EAAaooB,GAAgBxpB,EAAGJ,GAAO0oB,EAAYnU,IAChE4F,MAAa8G,EACb/F,KAAa9a,EAAE,QACf+a,YAAa/a,EAAE,eACf6a,OAAa7a,EAAE,UACfc,OACAsT,cACAlO,UAEFC,EAEJ,CAEA,SAASqjB,GAAgBxpB,EAAGJ,GAC1B,MAAMyB,EAAS,CAACF,MAAO,CAAE,EAAEF,OAAQ,CAAC,GAiBpC,OAfAC,EAAYG,EAAQ,CAClB+e,OAAcpgB,EAAE,UAChBiF,OAAcjF,EAAE,WAAa,EAC7BimB,SAActlB,GAAMf,EAAKqmB,SAAU,GACnCzD,aAAcxiB,EAAE,gBAChBypB,UAAczpB,EAAE,aAChB0pB,UAAc1pB,EAAE,aAChB4E,MAAc,CAACrE,OAAS,mBAAkBX,EAAKqD,aAC/C0mB,UAAc3pB,EAAE,aAGhB0hB,OAAc9hB,EAAK8hB,OACnBF,WAAc5hB,EAAK4hB,aAGdngB,CACT,CExGe,SAAAuoB,GAAShqB,EAAMuG,EAAO0jB,GACnC,MAAMvhB,EAAU1B,EAAAA,MAAMhH,EAAK0I,SACrBqY,EAAS/Z,EAAKA,MAAChH,EAAK+gB,QAmC1B,OAhCKkJ,GAAcvhB,EAAQzB,SAAQ7G,GAAKoI,EAAYpI,EAAGmG,KAGvDS,QAAMhH,EAAKkqB,aAAajjB,SAAQ7G,GjCjBnB,SAAS+pB,EAAM5jB,GAC5B,MAAMI,EAASJ,EAAMI,OAAOyjB,YAAc,CAAE,EACtC5jB,EAAS,CAAA,EAEf,IAAK,MAAMtF,KAAQipB,EACJ,SAATjpB,IACJsF,EAAOtF,GAAQ6R,GAAeoX,EAAKjpB,GAAOA,EAAMqF,IAIlD,IAAK,MAAMrF,KAAQyF,EACG,MAAhBH,EAAOtF,KACTsF,EAAOtF,GAAQ6R,GAAepM,EAAOzF,GAAOA,EAAMqF,IAItDA,EAAM8jB,cAAcF,EAAKjpB,KAAMsF,EACjC,CiCAuC8jB,CAAgBlqB,EAAGmG,KAGxDwa,EAAO9Z,SAAQ7G,GlCRV,SAAmBJ,EAAMuG,GAC9B,MAAMrG,EAAOF,EAAKE,MAAQ,SAErBqqB,EAAAA,iBAAiBrqB,IACpBgG,EAAAA,MAAM,4BAA8B3C,cAAYrD,IAGlDqG,EAAMikB,SAASxqB,EAAKkB,KAAM,CACxBhB,OACAoP,YAAQvK,GAEZ,CkCHsB0lB,CAAUrqB,EAAGmG,KAGjCS,QAAMhH,EAAK0Q,MAAMzJ,SAAQ7G,GAAKie,GAAUje,EAAGmG,KAG3Cwa,EAAO9Z,SAAQ7G,GAAK+O,GAAW/O,EAAGmG,MAGjC0jB,GAAgBvhB,GAASzB,SAAQ7G,GAAK0M,GAAmB1M,EAAGmG,KAG7DS,QAAMhH,EAAK0qB,MAAMzjB,SAAQ7G,GAAKwnB,GAAUxnB,EAAGmG,KAG3CS,QAAMhH,EAAKma,OAAOlT,SAAQ7G,GAAK0d,GAAU1d,EAAGmG,KAG5CS,QAAMhH,EAAKqf,SAASpY,SAAQ7G,GAAKwgB,GAAYxgB,EAAGmG,KAG5CvG,EAAKuhB,OAAO6B,GAAWpjB,EAAKuhB,MAAOhb,GAGvCA,EAAMokB,eAECpkB,CACT,CCpCA,MAAMqkB,GAAa5qB,GAAQwB,EACzB,CACED,MAAO,CACLgE,EAAG,CAACxE,MAAO,GACXyE,EAAG,CAACzE,MAAO,IAEbM,OAAQ,CACNqV,MAAO,CAAC/V,OAAQ,SAChBgW,OAAQ,CAAChW,OAAQ,YAGrBX,GAGa,SAAS6qB,GAAU7qB,EAAMuG,GACtC,MAAMI,EAASJ,EAAMI,OAGfmkB,EAAOplB,EAAIa,EAAMukB,KAAOvkB,EAAM8L,IAAIjJ,MAGlCV,EAgER,SAAwB1I,EAAM2G,GAC5B,MAAMvG,EAAIc,GAAQH,GAAMf,EAAKkB,GAAOyF,EAAOzF,IACrCwH,EAAU,CACRqiB,GAAa,aAAc3qB,EAAE,eAC7B2qB,GAAa,WAAYhrB,EAAcK,EAAE,cACzC2qB,GAAa,UAAWrqB,EAAaN,EAAE,aACvC2qB,GAAa,QAAS3qB,EAAE,UAAY,GACpC2qB,GAAa,SAAU3qB,EAAE,WAAa,IAExC4qB,EAAMtiB,EAAQyI,QAAO,CAACa,EAAGtN,KAAOsN,EAAEtN,EAAExD,MAAQwD,EAAGsN,IAAI,CAAA,GACnDhO,EAAM,CAAA,EAsBZ,OAnBAgD,EAAAA,MAAMhH,EAAK0I,SAASzB,SAAQvC,IACtB9C,iBAAeopB,EAAKtmB,EAAExD,MAExBwD,EAAI5D,EAAMA,OAACkqB,EAAItmB,EAAExD,MAAOwD,GAGxBgE,EAAQD,KAAK/D,GAEfV,EAAIU,EAAExD,MAAQwD,CAAC,IAIjBsC,EAAAA,MAAML,EAAO+B,SAASzB,SAAQvC,IACvB9C,EAAcA,eAACoC,EAAKU,EAAExD,OAAUU,EAAAA,eAAeopB,EAAKtmB,EAAExD,OAEzDwH,EAAQD,KAAK/D,EACf,IAGKgE,CACT,CAjGkBuiB,CAAejrB,EAAM2G,GACrC+B,EAAQzB,SAAQ7G,GAAKoI,EAAYpI,EAAGmG,KAGpCA,EAAM4U,YAAcnb,EAAKmb,aAAexU,EAAOwU,YAC/C5U,EAAM2kB,YAAcvkB,EAAOwF,OAC3B5F,EAAM8Y,QAAU9Y,EAAM2J,eAAevJ,EAAOka,QAAUla,EAAOka,OAAO3C,QACpE3X,EAAM4kB,OAASxkB,EAAOwkB,OAGtB,MAAM3Z,EAAQjL,EAAM8L,IAAI9E,MAGlB9L,EAAS8E,EAAM8L,IAAI3E,GAAOtH,EAC9BwkB,GAAW5qB,EAAKyB,QAASkT,GAAW3S,EACpChC,EAAKsG,MAAOC,EAAO,CAAC2L,MAAOxM,EAAI8L,OAI3BzL,EAASQ,EAAM8L,IAAIvD,GAAW,CAClCoP,OAAU3X,EAAM2J,eAAelQ,EAAKke,QACpCmB,QAAU9Y,EAAM8Y,QAChB+L,SAAU7kB,EAAMkG,UAAU,YAC1B1F,KAAU+jB,EACV5Y,MAAUxM,EAAIjE,MAEhB8E,EAAMgZ,UAAUrb,MAGhBqC,EAAMiZ,UAAU9Z,EAAIjE,GAASiE,EAAIK,GAAS,MAC1CslB,GAAUrrB,EAAMuG,EAAOmC,GACvBnC,EAAMgZ,UAAU9W,KAAK1C,GAGrB,IAAI6C,EAAKrC,EAAM8L,IAAI/E,GAAM,CAACvG,KAAM+jB,EAAM5Y,MAAOxM,EAAIK,MAOjD,OANA6C,EAAKrC,EAAM8L,IAAI3D,GAAO,CAACwD,MAAOxM,EAAIkD,MAClCA,EAAKrC,EAAM8L,IAAIzD,GAAM,CAACsD,MAAOxM,EAAIkD,MAGjCrC,EAAMoZ,QAAQ,OAAQ,IAAI5C,GAAUxW,EAAOiL,EAAOA,EAAO5I,IAElDrC,CACT,CAEA,SAASwkB,GAAa7pB,EAAMH,GAC1B,OAAOA,GAASA,EAAMJ,OAClB,CAAEO,OAAMG,OAAQN,EAAMJ,QACtB,CAAEO,OAAMH,QACd,CC/De,SAASkJ,GAAMtD,EAAQgG,GACpCzD,KAAKvC,OAASA,GAAU,GACxBuC,KAAKyD,QAAUA,GAAW,GAE1BzD,KAAKoiB,SAAW,GAChBpiB,KAAK1F,MAAQ,GACb0F,KAAKR,QAAU,GACfQ,KAAKqiB,QAAU,GACfriB,KAAK6X,OAAS,GACd7X,KAAKiD,OAAS,GACdjD,KAAKwH,KAAO,GAEZxH,KAAKsiB,QAAU,GACftiB,KAAKuiB,QAAU,GACfviB,KAAKqW,UAAY,GACjBrW,KAAKgiB,YAAc,KACnBhiB,KAAKiiB,OAAS,KAEdjiB,KAAKwiB,IAAM,EACXxiB,KAAKyiB,OAAS,EACdziB,KAAK0iB,SAAW,CAAC,GAEjB1iB,KAAK2iB,QAAU,GACf3iB,KAAK4iB,QAAU,GACf5iB,KAAK6iB,QAAU,GACf7iB,KAAK8iB,UAAY,EACnB,CAEA,SAASC,GAAS1lB,GAChB2C,KAAKvC,OAASJ,EAAMI,OACpBuC,KAAKyD,QAAUpG,EAAMoG,QACrBzD,KAAKmW,QAAU9Y,EAAM8Y,QAErBnW,KAAK1F,MAAQsE,OAAOokB,OAAO3lB,EAAM/C,OACjC0F,KAAKR,QAAUZ,OAAOokB,OAAO3lB,EAAMmC,SACnCQ,KAAKqiB,QAAUzjB,OAAOokB,OAAO3lB,EAAMglB,SACnCriB,KAAK6X,OAASjZ,OAAOokB,OAAO3lB,EAAMwa,QAClC7X,KAAKiD,OAASrE,OAAOokB,OAAO3lB,EAAM4F,QAClCjD,KAAKwH,KAAO5I,OAAOokB,OAAO3lB,EAAMmK,MAEhCxH,KAAKsiB,QAAU,GACftiB,KAAKuiB,QAAU,GACfviB,KAAKqW,UAAY,GAEjBrW,KAAKwiB,IAAM,EACXxiB,KAAKyiB,SAAWplB,EAAMqlB,SAAS,GAC/B1iB,KAAK0iB,SAAWrlB,EAAMqlB,SAEtB1iB,KAAK2iB,QAAUtlB,EAAMslB,QAAQ9F,QAC7B7c,KAAK4iB,QAAUvlB,EAAMulB,QAAQ/F,QAC7B7c,KAAK6iB,QAAUxlB,EAAMwlB,QAAQhG,QAC7B7c,KAAK8iB,UAAYzlB,EAAMylB,SACzB,CAmVA,SAASG,GAAensB,GACtB,OAAQa,EAAOA,QAACb,GAAQosB,GAAcC,IAAcrsB,EACtD,CAEA,SAASosB,GAAYplB,GACnB,MAAM2U,EAAI3U,EAAM5F,OAChB,IAAIqG,EAAO,IAEX,IAAK,IAAImU,EAAI,EAAGA,EAAED,IAAKC,EAAG,CACxB,MAAM7a,EAAQiG,EAAM4U,GACpBnU,IAASmU,EAAI,EAAI,IAAM,KAClB3b,EAAAA,SAASc,GACPA,EAAMJ,QAAUwrB,GAAeprB,GAChCwC,EAAWA,YAACxC,GACpB,CACA,OAAO0G,EAAO,GAChB,CAEA,SAAS4kB,GAAajG,GACpB,IAEItkB,EAAKf,EAFL0G,EAAO,IACPmU,EAAI,EAGR,IAAK9Z,KAAOskB,EACVrlB,EAAQqlB,EAAItkB,GACZ2F,MAAWmU,EAAI,EAAI,IAAM,IACrBrY,EAAAA,YAAYzB,GAAO,KAClB7B,EAAQA,SAACc,GACPA,EAAMJ,QAAUwrB,GAAeprB,GAChCwC,EAAAA,YAAYxC,IAEpB,OAAO0G,EAAO,GAChB,CCrbe,SAAAtE,KACb,MAAMmpB,EAAc,aAGdC,EAAe,UACfC,EAAQ,OACRC,EAAO,OACPC,EAAY,OAElB,MAAO,CAELvR,YAAa,qBAGb6G,QAAS,EAIToJ,SAAU,MAIVuB,WAAY,KAIZxgB,OAAQ,CACNhJ,SAAU,CAACypB,MAAO,CAAC,WAMrB9mB,MAAO,KAIPiB,KAAM,KACN8lB,IAAK,CACHhW,KAAM0V,GAERO,KAAM,CACJjW,KAAM0V,GAERQ,MAAO,KACPC,KAAM,CACJjW,OAAQwV,EACRvV,YA5CuB,GA8CzB4D,KAAM,CACJ7D,OAAQwV,GAEVU,KAAM,CACJpW,KAAM0V,GAER7kB,KAAM,CACJqP,OAAQyV,GAEVhT,MAAO,CACLzC,OAAQwV,GAEVW,OAAQ,CACNrW,KAAM0V,EACN9S,KAAM,IAER9B,KAAM,CACJd,KAAM2V,EACN3U,KAAMyU,EACNxU,SAAU,IAEZqV,MAAO,CACLtW,KAAM0V,EACN9S,KArEuB,GAyEzBnT,MAAO,CAEL,cAAe,CACbuQ,KAAM2V,EACN3U,KAAMyU,EACNxU,SAAU,IAGZ,cAAe,CACbjB,KAAM2V,EACN3U,KAAMyU,EACNxU,SAAU,GACVE,WAAY,QAGd,cAAe,CACbnB,KAAM2V,EACN3U,KAAMyU,EACNxU,SAAU,GACVE,WAAY,QAGd,iBAAkB,CAChBnB,KAAM2V,EACN3U,KAAMyU,EACNxU,SAAU,IAGZsV,MAAO,CACL3T,KAvGoB,GAwGpBzC,YAvGqB,EAwGrBwC,MAAO,UAET6T,OAAQ,CACN5T,KA5GoB,GA6GpBzC,YA5GqB,GA8GvBsW,OAAQ,CACN7T,KAhHoB,GAiHpBzC,YAhHqB,EAiHrBwC,MAAO,UAGT+T,KAAM,CACJ1W,KAAM,cACNE,OAAQ2V,GAEVc,KAAM,CACJ3W,KAAM,gBAKV0K,MAAO,CACLf,OAAQ,MACR+B,OAAQ,SACRld,OAAQ,EACRooB,gBAAiB,GAInB1F,KAAM,CACJ8B,UAAW,EACXC,UAAW,IACX4D,aAAc,GACdpe,QAAQ,EACRqe,YAAa,EACbC,YAAanB,EACb5D,MAAM,EACNgF,UAAW,EACXC,UAAWpB,EACX5S,QAAQ,EACRiU,WAAY,EACZ7V,WAAY,IACZI,YAAa,EACb0V,aAAc,EACdpF,OAAO,EACPqF,UAAWxB,EACXyB,WAAY,EACZC,WAAW,EACXnF,SAAU,EACVoF,UAAW,EACXxL,aAAc,GAIhBoF,SAAU,CACRkG,YAAa,IAIf9D,WAAY,CACVlqB,KAAM,YAIR2gB,OAAQ,CACNL,OAAQ,QACRwB,QAAS,EACTqM,UAAW,OACXC,cAAe,GACfC,WAAY,EACZlZ,gBAAiB,WACjBC,kBAAmB,WACnBC,eAAgB,IAChBE,kBAAmB,GACnB+Y,oBAAqB9B,EACrB+B,oBAAqB,EACrBlW,oBAAqB,EACrB6Q,WAAY,OACZC,cAAe,SACfnR,WAAY,IACZI,YAAa,EACboW,cAAc,EACdC,YAAa,GACbC,WAAY,SACZC,WAAY,IACZhW,aAAc,EACdiW,kBAAmB,IACnBxV,oBAAqB,cACrBC,sBAAuBkT,EACvBsC,WAAY,IACZC,YAAa,MACbpM,aAAc,EACd1E,OAAQ,CACN7Y,OAAQ,GACR+P,UAAW,aACX5U,KAAQ,CAAE4U,UAAW,YACrB3U,MAAQ,CAAE2U,UAAW,cAKzBpQ,MAAO,CACLiqB,SAAU,CACRvc,OAAQ,aAEVwc,QAAS,CACPxc,OAAQ,SAEVyc,QAAS,CACPzc,OAAQ,mBAEV0c,KAAM,CACJ1c,OAAQ,SAEV2c,UAAW,CACT3c,OAAQ,aACRC,OAAQ,CAAC,EAAG,IAEdua,OAAQ,CACN,SACA,SACA,cACA,QACA,UACA,iBACA,gBACA,kBAIR,CD1KAjjB,GAAM8Y,UAAYkJ,GAASlJ,UAAY,CACrCvb,MAAMxH,GACJ,OAAOgqB,GAAWhqB,EAAMkJ,KACzB,EAEDwW,OACE,OAAO,IAAIuM,GAAS/iB,KACrB,EAEDoD,aACE,OAAOpD,KAAKyiB,OAAS,CACtB,EAED7L,YAEE,OADA5W,KAAKomB,SACE,CACLnU,YAAajS,KAAKiS,YAClBoE,UAAarW,KAAKqW,UAClBiM,QAAatiB,KAAKsiB,QAClBC,QAAaviB,KAAKuiB,QAClBH,SAAapiB,KAAKoiB,SAClBJ,YAAahiB,KAAKgiB,YAClBC,OAAajiB,KAAKiiB,OAErB,EAEDhiB,KACE,OAAQD,KAAKyiB,OAASziB,KAAKyiB,OAAS,IAAM,GAAKziB,KAAKwiB,KACrD,EAEDrZ,IAAIzJ,GAQF,OAPAM,KAAKqW,UAAU9W,KAAKG,GACpBA,EAAGO,GAAKD,KAAKC,KAETP,EAAGU,OACLV,EAAGU,KAAKrC,SAAQvB,IAASA,EAAI2D,KAAOT,EAAGO,EAAE,IACzCP,EAAGU,KAAO,MAELV,CACR,EAED6S,MAAM7S,GACJ,MAAM2mB,EAAO3mB,aAAcK,EAAQvD,EAAIkD,GAAMA,EAC7C,OAAOM,KAAKmJ,IAAI7D,GAAM,CAACzN,MAAOwuB,IAC/B,EAEDtkB,UAAUN,GAGR,OAFAzB,KAAKsiB,QAAQ/iB,KAAKkC,GAClBA,EAAOxB,GAAKD,KAAKC,KACVwB,CACR,EAEDiC,UAAUvL,GAER,OADA6H,KAAKuiB,QAAQhjB,KAAKpH,GACXA,CACR,EAGDiuB,SACE,IAAIpuB,EAAMmc,EAMV,IAAKnc,KAHDgI,KAAK4hB,OAAM5hB,KAAK4hB,KAAKA,MAAO,GAGnB5hB,KAAKR,QAChBQ,KAAKR,QAAQxH,GAAMP,OAASO,EAI9B,IAAKA,KAAQgI,KAAK6X,OAChB7X,KAAK6X,OAAO7f,GAAMmC,MAAQnC,EAI5B,SAASsuB,EAAS5mB,EAAI1H,EAAMhB,GAC1B,IAAIwQ,EAAM+e,EACN7mB,IACF8H,EAAO9H,EAAG8H,OAAS9H,EAAG8H,KAAO,CAAE,GAC/B+e,EAAO/e,EAAKxP,KAAUwP,EAAKxP,GAAQ,IACnCuuB,EAAKhnB,KAAKvI,GAEd,CACA,IAAKgB,KAAQgI,KAAKwH,KAAM,CACtB2M,EAAKnU,KAAKwH,KAAKxP,GACfsuB,EAASnS,EAAG7L,MAAQtQ,EAAM,SAC1BsuB,EAASnS,EAAGP,OAAQ5b,EAAM,UAC1BsuB,EAASnS,EAAG7K,OAAQtR,EAAM,UAC1B,IAAK,MAAMsC,KAAS6Z,EAAGpE,MACrBuW,EAASnS,EAAGpE,MAAMzV,GAAQtC,EAAM,SAAWsC,EAE/C,CAEA,OAAO0F,IACR,EAIDsW,UAAU/d,EAAQsE,EAAQkP,GACxB/L,KAAK4iB,QAAQrjB,KAAK/C,EAAIwD,KAAKmJ,IAAIzD,GAAM,CAACsD,MAAOzQ,OAC7CyH,KAAK2iB,QAAQpjB,KAAK1C,GAClBmD,KAAK6iB,QAAQtjB,KAAKwM,EAASvP,EAAIwD,KAAKuS,MAAMxG,IAAW,MACrD/L,KAAK8iB,UAAUvjB,MAAM,EACtB,EAEDwX,WACE/W,KAAK4iB,QAAQ5nB,MACbgF,KAAK2iB,QAAQ3nB,MACbgF,KAAK6iB,QAAQ7nB,MACbgF,KAAK8iB,UAAU9nB,KAChB,EAED6B,SACE,OAAO9B,EAAIA,KAACiF,KAAK2iB,QAClB,EAEDpqB,SACE,OAAOwC,EAAIA,KAACiF,KAAK4iB,QAClB,EAED7W,SACE,OAAOhR,EAAIA,KAACiF,KAAK6iB,QAClB,EAEDnN,WACE,MAAM5M,EAAI9I,KAAK8iB,UACf,QAASha,EAAEA,EAAE5Q,OAAO,EACrB,EAIDmI,SAAS/F,EAAOtC,GACd,GAAIoC,EAAAA,SAASE,GAAQ,OAAO+F,EAAS/F,EAAOtC,GACvCsC,EAAM7C,QACTuF,EAAAA,MAAM,gCAAkC3C,cAAYC,IAGtD,MAAMkB,EAAIlB,EAAM7C,OAChB,IAAImR,EAAI5I,KAAK1F,MAAMkB,GAEnB,IAAKoN,EAAG,CACN,MAAMtL,EAAS,CAACtF,KAAMgI,KAAKuD,UAAU/H,IACjCxD,IAAMsF,EAAO4L,GAAKlR,GACtBgI,KAAK1F,MAAMkB,GAAKoN,EAAIpM,EAAIwD,KAAKmJ,IAAIxE,GAAMrH,IACzC,CACA,OAAOsL,CACR,EAEDnI,WAAW+lB,GACT,IAAI/uB,GAAS,EAEb,MAAMgvB,EAAQvvB,GAAK+J,GAAS/J,IACvBO,GAAS,EAAMuI,KAAKuD,UAAUrM,EAAEO,SzCrJlC,SAAgBP,GACrB,OAAOA,GAAKA,EAAE6H,IAChB,CyCoJQoU,CAAOjc,IAAMO,GAAS,EAAMuI,KAAKuT,QAAQrc,EAAE6H,OAC3C7H,EAEEmH,EAASP,EAAAA,MAAM0oB,EAAIlsB,OAAOQ,IAAI2rB,GAC9B/lB,EAAS5C,EAAKA,MAAC0oB,EAAIhX,OAAO1U,IAAI2rB,GAEpC,OAAOhvB,EACH+E,EAAIwD,KAAKmJ,IAAI7E,GAAQ,CAACjG,OAAQA,EAAQqC,OAAQA,MAC9CD,GAAWpC,EAAQqC,EACxB,EAEDwU,OAAO7W,EAAQqoB,GACb,IAAIjvB,GAAS,EAEb,MAIMkvB,EAAM3mB,KAAKR,QAGjB,OAFAnB,EAASP,EAAAA,MAAMO,GAAQvD,KALT5D,GAAK+J,GAAS/J,IACvBO,GAAS,EAAM+E,EAAImqB,EAAIzvB,EAAEO,UAC1BP,IAKGO,EACH+E,EAAIwD,KAAKmJ,IAAIvE,GAAI,CAACvG,OAAQA,EAAQqoB,KAAMA,MzC9MzC,SAAgBroB,EAAQqoB,GAC7B,MAAMlqB,EAAM,CAACoqB,KAAMvoB,GAEnB,OADIqoB,IAAMlqB,EAAIqqB,OAAQ,GACfrqB,CACT,CyC2MQ0Y,CAAO7W,EAAQqoB,EACpB,EAEDtd,QAAQvB,GACN,IAAKA,EAAM,OAAOA,EAGlB,MAAMpM,EAAIqF,GAAU+G,EAAKnI,GAAImI,EAAKvN,OAC7BwsB,EAAIjf,EAAK2H,OzC/MQ,YyCiNtB,OAAOsX,EAAErvB,OACL+E,EAAIwD,KAAKmJ,IAAI7E,GAAQ,CACnBjG,OAAQ5C,EACRiF,OAAQV,KAAKuD,UAAUujB,EAAErvB,YAE3BgJ,GAAWhF,EAAGqrB,EACnB,EAID7kB,MAAMD,EAAQhL,GACZ,MAAM4B,EAAMoJ,EAAS,IAAMhL,EAC3B,IAAKgJ,KAAKiD,OAAOrK,GAAM,CACrB,MAAMqH,EAAKD,KAAKC,KAChBD,KAAKsiB,QAAQ/iB,KAAK,CAChBU,GAAIA,EACJ+B,OAAQA,EACRhL,KAAMA,IAERgJ,KAAKiD,OAAOrK,GAAOqH,CACrB,CACA,OAAOD,KAAKiD,OAAOrK,EACpB,EAIDmuB,aAAa/uB,GACX,OAAOU,iBAAesH,KAAKR,QAASxH,EACrC,EAED2H,UAAU3H,EAAMH,GACVmI,KAAK+mB,aAAa/uB,IACpBgF,EAAAA,MAAM,0BAA4B3C,cAAYrC,IAEhD,MAAM0H,EAAK7H,aAAiBkI,EAAQlI,EAAQmI,KAAKmJ,IAAIjJ,EAASrI,IAC9D,OAAOmI,KAAKR,QAAQxH,GAAQ0H,CAC7B,EAEDmE,UAAU7L,GAIR,OAHKgI,KAAKR,QAAQxH,IAChBgF,EAAAA,MAAM,6BAA+B3C,cAAYrC,IAE5CgI,KAAKR,QAAQxH,EACrB,EAEDuL,UAAU/H,GACR,OAAIwE,KAAKR,QAAQhE,GACRgB,EAAIwD,KAAKR,QAAQhE,KACd9C,EAAcA,eAACsH,KAAKqiB,QAAS7mB,KACvCwE,KAAKqiB,QAAQ7mB,GAAKwE,KAAKmJ,IAAIjJ,EAAS,QAE/B1D,EAAIwD,KAAKqiB,QAAQ7mB,IACzB,EAEDimB,eACE,MAAMljB,EAAOK,OAAOC,KAAKmB,KAAKqiB,SAC9B,IAAK,IAAI3P,EAAE,EAAGD,EAAElU,EAAKrG,OAAQwa,EAAED,IAAKC,EAAG,CACrC,MAAMlX,EAAI+C,EAAKmU,GACT7F,EAAI7N,EAAAA,gBAAgBxD,EAAGwE,MACvBN,EAAKM,KAAKqiB,QAAQ7mB,GACxBkE,EAAGpC,OAASuP,EAAE5N,QACdS,EAAGvH,OAAS0U,EAAEnO,KAChB,CACD,EAED1C,SAASlF,GACP,OAAOA,GAAQA,EAAKW,OAASuI,KAAKuD,UAAUzM,EAAKW,QAAUX,CAC5D,EAEDkQ,eAAelQ,GACb,OAASA,GAASC,WAASD,GACvBkJ,KAAKuD,UAAUzM,EAAKW,QAAUwrB,GAAensB,IADbA,CAErC,EAEDyc,QAAQhV,EAAMvG,GACZ,MAAMsF,EAAS,CAACyB,KAAMC,EAAAA,gBAAgBT,EAAMyB,OAE5C,OADIhI,IAAMsF,EAAOyB,KAAKwB,MAAQvI,GACvBwE,EAAIwD,KAAKmJ,IAAI1E,GAAWnH,IAChC,EAEDwC,WAAW9H,EAAM6H,GACVG,KAAKoiB,UACRplB,EAAAA,MAAM,0CAA4C3C,cAAYrC,IAEhEgI,KAAKoiB,SAAS7iB,KAAK3H,SAAO,CAACH,OAAQO,GAAO6H,GAC3C,EAIDmnB,aAAahvB,EAAMiM,GACbvL,iBAAesH,KAAK6X,OAAQ7f,IAC9BgF,EAAAA,MAAM,uCAAyC3C,cAAYrC,IAE7DgI,KAAK6X,OAAO7f,GAAQgI,KAAKmJ,IAAIlF,EAC9B,EAEDqd,SAAStpB,EAAMsF,GACb0C,KAAKgnB,aAAahvB,EAAMyN,GAAMnI,GAC/B,EAED6jB,cAAcnpB,EAAMsF,GAClB0C,KAAKgnB,aAAahvB,EAAMqN,GAAW/H,GACpC,EAED4I,SAASlO,GAIP,OAHKgI,KAAK6X,OAAO7f,IACfgF,EAAAA,MAAM,4BAA8B3C,cAAYrC,IAE3CgI,KAAK6X,OAAO7f,EACpB,EAEDkC,SAASlC,GACP,OAAOwE,EAAIwD,KAAKkG,SAASlO,GAC1B,EAEDggB,UAAUhgB,GACR,OAAOgI,KAAKkG,SAASlO,GAAMsF,OAAOtG,IACnC,EAEDgc,cAAchb,GACZ,OAAOgI,KAAK9F,SAASlC,EACtB,EAEDivB,eAAejvB,GACb,OAAOgI,KAAKgY,UAAUhgB,EACvB,EAIDye,QAAQze,EAAMkvB,GAIZ,OAHIxuB,iBAAesH,KAAKwH,KAAMxP,IAC5BgF,EAAAA,MAAM,4BAA8B3C,cAAYrC,IAE1CgI,KAAKwH,KAAKxP,GAAQkvB,CAC3B,EAEDzf,QAAQzP,GAIN,OAHKgI,KAAKwH,KAAKxP,IACbgF,EAAAA,MAAM,4BAA8B3C,cAAYrC,IAE3CgI,KAAKwH,KAAKxP,EAClB,EAEDuQ,gBAAgBvQ,EAAM0X,GAIpB,OAHIhX,iBAAesH,KAAKwH,KAAMxP,IAC5BgF,EAAAA,MAAM,4BAA8B3C,cAAYrC,IAE3CgI,KAAKyW,QAAQze,EAAM6b,GAAU+F,YAAY5Z,KAAM0P,GACxD,gSElZa,SAAS5Y,EAAM2G,EAAQgG,GAMpC,OALK1M,EAAAA,SAASD,IACZkG,EAAKA,MAAC,+CAID2kB,GAAU7qB,EAAM,IAAIiK,GAD3BtD,EAAS0pB,EAAWA,YAACltB,KAAYwD,EAAQ3G,EAAK2G,QACLgG,IAAUmT,WACrD"}