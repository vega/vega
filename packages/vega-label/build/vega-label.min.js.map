{"version":3,"file":"vega-label.min.js","sources":["../src/util/markBitmaps.js","../src/util/Bitmap.js","../src/util/scaler.js","../src/util/placeAreaLabel/common.js","../src/util/placeAreaLabel/placeFloodFill.js","../src/util/placeMarkLabel.js","../src/LabelLayout.js","../src/util/placeAreaLabel/placeNaive.js","../src/util/placeAreaLabel/placeReducedSearch.js","../src/Label.js"],"sourcesContent":["import {canvas} from 'vega-canvas';\nimport {rederive} from 'vega-dataflow';\nimport {Marks} from 'vega-scenegraph';\n\n// bit mask for getting first 2 bytes of alpha value\nconst ALPHA_MASK = 0xff000000;\n\nexport function baseBitmaps($, data) {\n  const bitmap = $.bitmap();\n  // when there is no base mark but data points are to be avoided\n  (data || []).forEach(d => bitmap.set($(d.boundary[0]), $(d.boundary[3])));\n  return [bitmap, undefined];\n}\n\nexport function markBitmaps($, baseMark, avoidMarks, labelInside, isGroupArea) {\n  // create canvas\n  const width = $.width,\n        height = $.height,\n        border = labelInside || isGroupArea,\n        context = canvas(width, height).getContext('2d'),\n        baseMarkContext = canvas(width, height).getContext('2d'),\n        strokeContext = border && canvas(width, height).getContext('2d');\n\n  // render all marks to be avoided into canvas\n  avoidMarks.forEach(items => draw(context, items, false));\n  draw(baseMarkContext, baseMark, false);\n  if (border) {\n    draw(strokeContext, baseMark, true);\n  }\n\n  // get canvas buffer, create bitmaps\n  const buffer = getBuffer(context, width, height),\n        baseMarkBuffer = getBuffer(baseMarkContext, width, height),\n        strokeBuffer = border && getBuffer(strokeContext, width, height),\n        layer1 = $.bitmap(),\n        layer2 = border && $.bitmap();\n\n  // populate bitmap layers\n  let x, y, u, v, index, alpha, strokeAlpha, baseMarkAlpha;\n  for (y=0; y < height; ++y) {\n    for (x=0; x < width; ++x) {\n      index = y * width + x;\n\n      alpha = buffer[index] & ALPHA_MASK;\n      baseMarkAlpha = baseMarkBuffer[index] & ALPHA_MASK;\n      strokeAlpha = border && (strokeBuffer[index] & ALPHA_MASK);\n\n      if (alpha || strokeAlpha || baseMarkAlpha) {\n        u = $(x);\n        v = $(y);\n        if (!isGroupArea && (alpha || baseMarkAlpha)) layer1.set(u, v); // update interior bitmap\n        if (border && (alpha || strokeAlpha)) layer2.set(u, v); // update border bitmap\n      }\n    }\n  }\n\n  return [layer1, layer2];\n}\n\nfunction getBuffer(context, width, height) {\n  return new Uint32Array(context.getImageData(0, 0, width, height).data.buffer);\n}\n\nfunction draw(context, items, interior) {\n  if (!items.length) return;\n  const type = items[0].mark.marktype;\n\n  if (type === 'group') {\n    items.forEach(group => {\n      group.items.forEach(mark => draw(context, mark.items, interior));\n    });\n  } else {\n    Marks[type].draw(context, {items: interior ? items.map(prepare) : items});\n  }\n}\n\n/**\n * Prepare item before drawing into canvas (setting stroke and opacity)\n * @param {object} source item to be prepared\n * @returns prepared item\n */\nfunction prepare(source) {\n  const item = rederive(source, {});\n\n  if (\n    (item.stroke && item.strokeOpacity !== 0) ||\n    (item.fill && item.fillOpacity !== 0)\n  ) {\n    return {\n      ...item,\n      strokeOpacity: 1,\n      stroke: '#000',\n      fillOpacity: 0\n    };\n  }\n\n  return item;\n}\n","const DIV = 5,   // bit shift from x, y index to bit vector array index\n      MOD = 31,  // bit mask for index lookup within a bit vector\n      SIZE = 32, // individual bit vector size\n      RIGHT0 = new Uint32Array(SIZE + 1), // left-anchored bit vectors, full -> 0\n      RIGHT1 = new Uint32Array(SIZE + 1); // right-anchored bit vectors, 0 -> full\n\nRIGHT1[0] = 0;\nRIGHT0[0] = ~RIGHT1[0];\nfor (let i=1; i <= SIZE; ++i) {\n  RIGHT1[i] = (RIGHT1[i - 1] << 1) | 1;\n  RIGHT0[i] = ~RIGHT1[i];\n}\n\nexport default function(w, h) {\n  const array = new Uint32Array(~~((w * h + SIZE) / SIZE));\n\n  function _set(index, mask) {\n    array[index] |= mask;\n  }\n\n  function _clear(index, mask) {\n    array[index] &= mask;\n  }\n\n  return {\n    array: array,\n\n    get: (x, y) => {\n      const index = y * w + x;\n      return array[index >>> DIV] & (1 << (index & MOD));\n    },\n\n    set: (x, y) => {\n      const index = y * w + x;\n      _set(index >>> DIV, 1 << (index & MOD));\n    },\n\n    clear: (x, y) => {\n      const index = y * w + x;\n      _clear(index >>> DIV, ~(1 << (index & MOD)));\n    },\n\n    getRange: (x, y, x2, y2) => {\n      let r = y2, start, end, indexStart, indexEnd;\n      for (; r >= y; --r) {\n        start = r * w + x;\n        end = r * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n        if (indexStart === indexEnd) {\n          if (array[indexStart] & RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]) {\n            return true;\n          }\n        } else {\n          if (array[indexStart] & RIGHT0[start & MOD]) return true;\n          if (array[indexEnd] & RIGHT1[(end & MOD) + 1]) return true;\n          for (let i = indexStart + 1; i < indexEnd; ++i) {\n            if (array[i]) return true;\n          }\n        }\n      }\n      return false;\n    },\n\n    setRange: (x, y, x2, y2) => {\n      let start, end, indexStart, indexEnd, i;\n      for (; y <= y2; ++y) {\n        start = y * w + x;\n        end = y * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n        if (indexStart === indexEnd) {\n          _set(indexStart, RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]);\n        } else {\n          _set(indexStart, RIGHT0[start & MOD]);\n          _set(indexEnd, RIGHT1[(end & MOD) + 1]);\n          for (i = indexStart + 1; i < indexEnd; ++i) _set(i, 0xffffffff);\n        }\n      }\n    },\n\n    clearRange: (x, y, x2, y2) => {\n      let start, end, indexStart, indexEnd, i;\n      for (; y <= y2; ++y) {\n        start = y * w + x;\n        end = y * w + x2;\n        indexStart = start >>> DIV;\n        indexEnd = end >>> DIV;\n        if (indexStart === indexEnd) {\n          _clear(indexStart, RIGHT1[start & MOD] | RIGHT0[(end & MOD) + 1]);\n        } else {\n          _clear(indexStart, RIGHT1[start & MOD]);\n          _clear(indexEnd, RIGHT0[(end & MOD) + 1]);\n          for (i = indexStart + 1; i < indexEnd; ++i) _clear(i, 0);\n        }\n      }\n    },\n\n    outOfBounds: (x, y, x2, y2) => x < 0 || y < 0 || y2 >= h || x2 >= w\n  };\n}","import Bitmap from './Bitmap';\n\nexport default function(width, height, padding) {\n  const ratio = Math.max(1, Math.sqrt((width * height) / 1e6)),\n        w = ~~((width + 2 * padding + ratio) / ratio),\n        h = ~~((height + 2 * padding + ratio) / ratio),\n        scale = _ => ~~((_ + padding) / ratio);\n\n  scale.invert = _ => (_ * ratio) - padding;\n  scale.bitmap = () => Bitmap(w, h);\n  scale.ratio = ratio;\n  scale.padding = padding;\n  scale.width = width;\n  scale.height = height;\n\n  return scale;\n}","export function outOfBounds(x, y, textWidth, textHeight, width, height) {\n  let r = textWidth / 2;\n  return x - r < 0\n      || x + r > width\n      || y - (r = textHeight / 2) < 0\n      || y + r > height;\n}\n\nexport function collision($, x, y, textHeight, textWidth, h, bm0, bm1) {\n  const w = (textWidth * h) / (textHeight * 2),\n        x1 = $(x - w),\n        x2 = $(x + w),\n        y1 = $(y - (h = h/2)),\n        y2 = $(y + h);\n\n  return bm0.outOfBounds(x1, y1, x2, y2)\n      || bm0.getRange(x1, y1, x2, y2)\n      || (bm1 && bm1.getRange(x1, y1, x2, y2));\n}","import {textMetrics} from 'vega-scenegraph';\nimport {collision, outOfBounds} from './common';\n\n// pixel direction offsets for flood fill search\nconst X_DIR = [-1, -1, 1, 1];\nconst Y_DIR = [-1, 1, -1, 1];\n\nexport default function($, bitmaps, avoidBaseMark, markIndex) {\n  const width = $.width,\n      height = $.height,\n      bm0 = bitmaps[0], // where labels have been placed\n      bm1 = bitmaps[1], // area outlines\n      bm2 = $.bitmap(); // flood-fill visitations\n\n  // try to place a label within an input area mark\n  return function(d) {\n    const items = d.datum.datum.items[markIndex].items, // area points\n          n = items.length, // number of points\n          textHeight = d.datum.fontSize, // label width\n          textWidth = textMetrics.width(d.datum, d.datum.text), // label height\n          stack = []; // flood fill stack\n\n    let maxSize = avoidBaseMark ? textHeight : 0,\n        labelPlaced = false,\n        labelPlaced2 = false,\n        maxAreaWidth = 0,\n        x1, x2, y1, y2, x, y, _x, _y, lo, hi, mid, areaWidth;\n\n    // for each area sample point\n    for (let i=0; i<n; ++i) {\n      x1 = items[i].x;\n      y1 = items[i].y;\n      x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n      y2 = items[i].y2 === undefined ? y1 : items[i].y2;\n\n      // add scaled center point to stack\n      stack.push([$((x1 + x2) / 2), $((y1 + y2) / 2)]);\n\n      // perform flood fill, visit points\n      while (stack.length) {\n        [_x, _y] = stack.pop();\n\n        // exit if point already marked\n        if (bm0.get(_x, _y) || bm1.get(_x, _y) || bm2.get(_x, _y)) continue;\n\n        // mark point in flood fill bitmap\n        // add search points for all (in bound) directions\n        bm2.set(_x, _y);\n        for (let j=0; j<4; ++j) {\n          x = _x + X_DIR[j];\n          y = _y + Y_DIR[j];\n          if (!bm2.outOfBounds(x, y, x, y)) stack.push([x, y]);\n        }\n\n        // unscale point back to x, y space\n        x = $.invert(_x);\n        y = $.invert(_y);\n        lo = maxSize;\n        hi = height; // TODO: make this bound smaller\n\n        if (\n          !outOfBounds(x, y, textWidth, textHeight, width, height) &&\n          !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) &&\n          !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)\n        ) {\n          // if the label fits at the current sample point,\n          // perform binary search to find the largest font size that fits\n          while (hi - lo >= 1) {\n            mid = (lo + hi) / 2;\n            if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {\n              hi = mid;\n            } else {\n              lo = mid;\n            }\n          }\n          // place label if current lower bound exceeds prior max font size\n          if (lo > maxSize) {\n            d.x = x;\n            d.y = y;\n            maxSize = lo;\n            labelPlaced = true;\n          }\n        }\n      }\n\n      // place label at slice center if not placed through other means\n      // and if we're not avoiding overlap with other areas\n      if (!labelPlaced && !avoidBaseMark) {\n        // one span is zero, hence we can add\n        areaWidth = Math.abs(x2 - x1 + y2 - y1);\n        x = (x1 + x2) / 2;\n        y = (y1 + y2) / 2;\n\n        // place label if it fits and improves the max area width\n        if (\n          areaWidth >= maxAreaWidth &&\n          !outOfBounds(x, y, textWidth, textHeight, width, height) &&\n          !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)\n        ) {\n          maxAreaWidth = areaWidth;\n          d.x = x;\n          d.y = y;\n          labelPlaced2 = true;\n        }\n      }\n    }\n\n    // record current label placement information, update label bitmap\n    if (labelPlaced || labelPlaced2) {\n      x = textWidth / 2;\n      y = textHeight / 2;\n      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));\n      d.align = 'center';\n      d.baseline = 'middle';\n      return true;\n    } else {\n      return false;\n    }\n  };\n}\n","import {textMetrics} from 'vega-scenegraph';\n\nconst Aligns = ['right', 'center', 'left'],\n      Baselines = ['bottom', 'middle', 'top'];\n\nexport default function($, bitmaps, anchors, offsets) {\n  const width = $.width,\n        height = $.height,\n        bm0 = bitmaps[0],\n        bm1 = bitmaps[1],\n        n = offsets.length;\n\n  return function(d) {\n    const boundary = d.boundary,\n          textHeight = d.datum.fontSize;\n\n    // can not be placed if the mark is not visible in the graph bound\n    if (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width || boundary[3] > height) {\n      return false;\n    }\n\n    let textWidth = d.textWidth ?? 0,\n        dx, dy, isInside, sizeFactor, insideFactor,\n        x1, x2, y1, y2, xc, yc,\n        _x1, _x2, _y1, _y2;\n\n    // for each anchor and offset\n    for (let i=0; i<n; ++i) {\n      dx = (anchors[i] & 0x3) - 1;\n      dy = ((anchors[i] >>> 0x2) & 0x3) - 1;\n\n      isInside = (dx === 0 && dy === 0) || offsets[i] < 0;\n      sizeFactor = dx && dy ? Math.SQRT1_2 : 1;\n      insideFactor = offsets[i] < 0 ? -1 : 1;\n\n      x1 = boundary[1 + dx] + offsets[i] * dx * sizeFactor;\n      yc = boundary[4 + dy] + (insideFactor * textHeight * dy) / 2 + offsets[i] * dy * sizeFactor;\n      y1 = yc - textHeight / 2;\n      y2 = yc + textHeight / 2;\n\n      _x1 = $(x1);\n      _y1 = $(y1);\n      _y2 = $(y2);\n\n      if (!textWidth) {\n        // to avoid finding width of text label,\n        if (!test(_x1, _x1, _y1, _y2, bm0, bm1, x1, x1, y1, y2, boundary, isInside)) {\n          // skip this anchor/offset option if we fail to place a label with 1px width\n          continue;\n        } else {\n          // Otherwise, find the label width\n          textWidth = textMetrics.width(d.datum, d.datum.text);\n        }\n      }\n\n      xc = x1 + (insideFactor * textWidth * dx) / 2;\n      x1 = xc - textWidth / 2;\n      x2 = xc + textWidth / 2;\n\n      _x1 = $(x1);\n      _x2 = $(x2);\n\n      if (test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside)) {\n        // place label if the position is placeable\n        d.x = !dx ? xc : dx * insideFactor < 0 ? x2 : x1;\n        d.y = !dy ? yc : dy * insideFactor < 0 ? y2 : y1;\n\n        d.align = Aligns[dx * insideFactor + 1];\n        d.baseline = Baselines[dy * insideFactor + 1];\n\n        bm0.setRange(_x1, _y1, _x2, _y2);\n        return true;\n      }\n    }\n\n    return false;\n  };\n}\n\n// Test if a label with the given dimensions can be added without overlap\nfunction test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside) {\n  return !(\n    bm0.outOfBounds(_x1, _y1, _x2, _y2) ||\n    ((isInside && bm1) || bm0).getRange(_x1, _y1, _x2, _y2)\n  );\n}\n","import {textMetrics} from 'vega-scenegraph';\nimport {baseBitmaps, markBitmaps} from './util/markBitmaps';\nimport scaler from './util/scaler';\nimport placeAreaLabelNaive from './util/placeAreaLabel/placeNaive';\nimport placeAreaLabelReducedSearch from './util/placeAreaLabel/placeReducedSearch';\nimport placeAreaLabelFloodFill from './util/placeAreaLabel/placeFloodFill';\nimport placeMarkLabel from './util/placeMarkLabel';\n\n// 8-bit representation of anchors\nconst TOP    = 0x0,\n      MIDDLE = 0x4,\n      BOTTOM = 0x8,\n      LEFT   = 0x0,\n      CENTER = 0x1,\n      RIGHT  = 0x2;\n\n// Mapping from text anchor to number representation\nconst anchorCode = {\n  'top-left':     TOP + LEFT,\n  'top':          TOP + CENTER,\n  'top-right':    TOP + RIGHT,\n  'left':         MIDDLE + LEFT,\n  'middle':       MIDDLE + CENTER,\n  'right':        MIDDLE + RIGHT,\n  'bottom-left':  BOTTOM + LEFT,\n  'bottom':       BOTTOM + CENTER,\n  'bottom-right': BOTTOM + RIGHT\n};\n\nconst placeAreaLabel = {\n  'naive': placeAreaLabelNaive,\n  'reduced-search': placeAreaLabelReducedSearch,\n  'floodfill': placeAreaLabelFloodFill\n};\n\nexport default function(texts, size, compare, offset, anchor,\n  avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding, method)\n{\n  // early exit for empty data\n  if (!texts.length) return texts;\n\n  const positions = Math.max(offset.length, anchor.length),\n        offsets = getOffsets(offset, positions),\n        anchors = getAnchors(anchor, positions),\n        marktype = markType(texts[0].datum),\n        grouptype = marktype === 'group' && texts[0].datum.items[markIndex].marktype,\n        isGroupArea = grouptype === 'area',\n        boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex),\n        infPadding = padding === null || padding === Infinity,\n        isNaiveGroupArea = isGroupArea && method === 'naive';\n\n  let maxTextWidth = -1,\n      maxTextHeight = -1;\n\n  // prepare text mark data for placing\n  const data = texts.map(d => {\n    const textWidth = infPadding ? textMetrics.width(d, d.text) : undefined;\n    maxTextWidth = Math.max(maxTextWidth, textWidth);\n    maxTextHeight = Math.max(maxTextHeight, d.fontSize);\n\n    return {\n      datum: d,\n      opacity: 0,\n      x: undefined,\n      y: undefined,\n      align: undefined,\n      baseline: undefined,\n      boundary: boundary(d),\n      textWidth\n    };\n  });\n\n  padding = (padding === null || padding === Infinity)\n    ? Math.max(maxTextWidth, maxTextHeight) + Math.max(...offset)\n    : padding;\n  const $ = scaler(size[0], size[1], padding);\n\n  let bitmaps;\n  if (!isNaiveGroupArea) {\n    // sort labels in priority order, if comparator is provided\n    if (compare) {\n      data.sort((a, b) => compare(a.datum, b.datum));\n    }\n\n    // flag indicating if label can be placed inside its base mark\n    let labelInside = false;\n    for (let i=0; i < anchors.length && !labelInside; ++i) {\n      // label inside if anchor is at center\n      // label inside if offset to be inside the mark bound\n      labelInside = anchors[i] === 0x5 || offsets[i] < 0;\n    }\n\n    // extract data information from base mark when base mark is to be avoided\n    // base mark is implicitly avoided if it is a group area\n    const baseMark = ((marktype && avoidBaseMark) || isGroupArea) && texts.map(d => d.datum);\n\n    // generate bitmaps for layout calculation\n    bitmaps = avoidMarks.length || baseMark\n      ? markBitmaps($, baseMark || [], avoidMarks, labelInside, isGroupArea)\n      : baseBitmaps($, avoidBaseMark && data);\n  }\n\n  // generate label placement function\n  const place = isGroupArea\n    ? placeAreaLabel[method]($, bitmaps, avoidBaseMark, markIndex)\n    : placeMarkLabel($, bitmaps, anchors, offsets);\n\n  // place all labels\n  data.forEach(d => d.opacity = +place(d));\n\n  return data;\n}\n\nfunction getOffsets(_, count) {\n  const offsets = new Float64Array(count),\n        n = _.length;\n  for (let i=0; i<n; ++i) offsets[i] = _[i] || 0;\n  for (let i=n; i<count; ++i) offsets[i] = offsets[n - 1];\n  return offsets;\n}\n\nfunction getAnchors(_, count) {\n  const anchors = new Int8Array(count),\n        n = _.length;\n  for (let i=0; i<n; ++i) anchors[i] |= anchorCode[_[i]];\n  for (let i=n; i<count; ++i) anchors[i] = anchors[n - 1];\n  return anchors;\n}\n\nfunction markType(item) {\n  return item && item.mark && item.mark.marktype;\n}\n\n/**\n * Factory function for function for getting base mark boundary, depending\n * on mark and group type. When mark type is undefined, line or area: boundary\n * is the coordinate of each data point. When base mark is grouped line,\n * boundary is either at the start or end of the line depending on the\n * value of lineAnchor. Otherwise, use bounds of base mark.\n */\nfunction markBoundary(marktype, grouptype, lineAnchor, markIndex) {\n  const xy = d => [d.x, d.x, d.x, d.y, d.y, d.y];\n\n  if (!marktype) {\n    return xy; // no reactive geometry\n  }\n\n  else if (marktype === 'line' || marktype === 'area') {\n    return d => xy(d.datum);\n  }\n\n  else if (grouptype === 'line') {\n    return d => {\n      const items = d.datum.items[markIndex].items;\n      return xy(items.length\n        ? items[lineAnchor === 'start' ? 0 : items.length - 1]\n        : {x: NaN, y: NaN});\n    };\n  }\n\n  else {\n    return d => {\n      const b = d.datum.bounds;\n      return [b.x1, (b.x1 + b.x2) / 2, b.x2, b.y1, (b.y1 + b.y2) / 2, b.y2];\n    };\n  }\n}\n","import {textMetrics} from 'vega-scenegraph';\n\nexport default function($, bitmaps, avoidBaseMark, markIndex) {\n  const width = $.width,\n      height = $.height;\n  \n  // try to place a label within an input area mark\n  return function(d) {\n    const items = d.datum.datum.items[markIndex].items, // area points\n          n = items.length, // number of points\n          textHeight = d.datum.fontSize, // label width\n          textWidth = textMetrics.width(d.datum, d.datum.text); // label height\n\n    let maxAreaWidth = 0,\n        x1, x2, y1, y2, x, y, areaWidth;\n\n    // for each area sample point\n    for (let i=0; i<n; ++i) {\n      x1 = items[i].x;\n      y1 = items[i].y;\n      x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n      y2 = items[i].y2 === undefined ? y1 : items[i].y2;\n      x = (x1 + x2) / 2;\n      y = (y1 + y2) / 2;\n\n      areaWidth = Math.abs(x2 - x1 + y2 - y1);\n      if (areaWidth >= maxAreaWidth) {\n        maxAreaWidth = areaWidth;\n        d.x = x;\n        d.y = y;\n      }\n    }\n\n    x = textWidth / 2;\n    y = textHeight / 2;\n    x1 = d.x - x;\n    x2 = d.x + x;\n    y1 = d.y - y;\n    y2 = d.y + y;\n\n    d.align = 'center';\n    if (x1 < 0 && x2 <= width) {\n      d.align = 'left';\n    } else if (0 <= x1 && width < x2) {\n      d.align = 'right';\n    }\n\n    d.baseline = 'middle';\n    if (y1 < 0 && y2 <= height) {\n      d.baseline = 'top';\n    } else if (0 <= y1 && height < y2) {\n      d.baseline = 'bottom';\n    }\n\n    return true;\n  };\n}\n","import {textMetrics} from 'vega-scenegraph';\nimport {collision, outOfBounds} from './common';\n\nexport default function($, bitmaps, avoidBaseMark, markIndex) {\n  const width = $.width,\n      height = $.height,\n      bm0 = bitmaps[0], // where labels have been placed\n      bm1 = bitmaps[1]; // area outlines\n  \n  function tryLabel(_x, _y, maxSize, textWidth, textHeight) {\n    const x = $.invert(_x),\n          y = $.invert(_y);\n    let lo = maxSize,\n        hi = height,\n        mid;\n    if (\n      !outOfBounds(x, y, textWidth, textHeight, width, height) &&\n      !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) &&\n      !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)\n    ) {\n      // if the label fits at the current sample point,\n      // perform binary search to find the largest font size that fits\n      while (hi - lo >= 1) {\n        mid = (lo + hi) / 2;\n        if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {\n          hi = mid;\n        } else {\n          lo = mid;\n        }\n      }\n      // place label if current lower bound exceeds prior max font size\n      if (lo > maxSize) {\n        return [x, y, lo, true];\n      }\n    }\n  }\n\n  // try to place a label within an input area mark\n  return function(d) {\n    const items = d.datum.datum.items[markIndex].items, // area points\n          n = items.length, // number of points\n          textHeight = d.datum.fontSize, // label width\n          textWidth = textMetrics.width(d.datum, d.datum.text); // label height\n\n    let maxSize = avoidBaseMark ? textHeight : 0,\n        labelPlaced = false,\n        labelPlaced2 = false,\n        maxAreaWidth = 0,\n        x1, x2, y1, y2, x, y, _x, _y, _x1, _xMid, _x2, _y1, _yMid, _y2, areaWidth, result, swapTmp;\n\n    // for each area sample point\n    for (let i=0; i<n; ++i) {\n      x1 = items[i].x;\n      y1 = items[i].y;\n      x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n      y2 = items[i].y2 === undefined ? y1 : items[i].y2;\n\n      if (x1 > x2) {\n        swapTmp = x1;\n        x1 = x2;\n        x2 = swapTmp;\n      }\n\n      if (y1 > y2) {\n        swapTmp = y1;\n        y1 = y2;\n        y2 = swapTmp;\n      }\n\n      _x1 = $(x1);\n      _x2 = $(x2);\n      _xMid = ~~((_x1 + _x2) / 2);\n      _y1 = $(y1);\n      _y2 = $(y2);\n      _yMid = ~~((_y1 + _y2) / 2);\n\n      // search along the line from mid point between the 2 border to lower border\n      for (_x = _xMid; _x >= _x1; --_x) {\n        for (_y = _yMid; _y >= _y1; --_y) {\n          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);\n          if (result) {\n            [d.x, d.y, maxSize, labelPlaced] = result;\n          }\n        }\n      }\n\n      // search along the line from mid point between the 2 border to upper border\n      for (_x = _xMid; _x <= _x2; ++_x) {\n        for (_y = _yMid; _y <= _y2; ++_y) {\n          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);\n          if (result) {\n            [d.x, d.y, maxSize, labelPlaced] = result;\n          }\n        }\n      }\n\n      // place label at slice center if not placed through other means\n      // and if we're not avoiding overlap with other areas\n      if (!labelPlaced && !avoidBaseMark) {\n        // one span is zero, hence we can add\n        areaWidth = Math.abs(x2 - x1 + y2 - y1);\n        x = (x1 + x2) / 2;\n        y = (y1 + y2) / 2;\n\n        // place label if it fits and improves the max area width\n        if (\n          areaWidth >= maxAreaWidth &&\n          !outOfBounds(x, y, textWidth, textHeight, width, height) &&\n          !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)\n        ) {\n          maxAreaWidth = areaWidth;\n          d.x = x;\n          d.y = y;\n          labelPlaced2 = true;\n        }\n      }\n    }\n\n    // record current label placement information, update label bitmap\n    if (labelPlaced || labelPlaced2) {\n      x = textWidth / 2;\n      y = textHeight / 2;\n      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));\n      d.align = 'center';\n      d.baseline = 'middle';\n      return true;\n    } else {\n      return false;\n    }\n  };\n}\n","import labelLayout from './LabelLayout';\nimport {Transform} from 'vega-dataflow';\nimport {array, error, inherits, isFunction} from 'vega-util';\n\nconst Output = [\n  'x',\n  'y',\n  'opacity',\n  'align',\n  'baseline'\n];\n\nconst Anchors = [\n  'top-left',\n  'left',\n  'bottom-left',\n  'top',\n  'bottom',\n  'top-right',\n  'right',\n  'bottom-right'\n];\n\n/**\n * Compute text label layout to annotate marks.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The size of the layout, provided as a [width, height] array.\n * @param {function(*,*): number} [params.sort] - An optional\n *   comparator function for sorting label data in priority order.\n * @param {Array<string>} [params.anchor] - Label anchor points relative to the base mark bounding box.\n *   The available options are 'top-left', 'left', 'bottom-left', 'top',\n *   'bottom', 'top-right', 'right', 'bottom-right', 'middle'.\n * @param {Array<number>} [params.offset] - Label offsets (in pixels) from the base mark bounding box.\n *   This parameter is parallel to the list of anchor points.\n * @param {number | null} [params.padding=0] - The amount (in pixels) that a label may exceed the layout size.\n *   If this parameter is null, a label may exceed the layout size without any boundary.\n * @param {string} [params.lineAnchor='end'] - For group line mark labels only, indicates the anchor\n *   position for labels. One of 'start' or 'end'.\n * @param {string} [params.markIndex=0] - For group mark labels only, an index indicating\n *   which mark within the group should be labeled.\n * @param {Array<number>} [params.avoidMarks] - A list of additional mark names for which the label\n *   layout should avoid overlap.\n * @param {boolean} [params.avoidBaseMark=true] - Boolean flag indicating if labels should avoid\n *   overlap with the underlying base mark being labeled.\n * @param {string} [params.method='naive'] - For area make labels only, a method for\n *   place labels. One of 'naive', 'reduced-search', or 'floodfill'.\n * @param {Array<string>} [params.as] - The output fields written by the transform.\n *   The default is ['x', 'y', 'opacity', 'align', 'baseline'].\n */\nexport default function Label(params) {\n  Transform.call(this, null, params);\n}\n\nLabel.Definition = {\n  type: 'Label',\n  metadata: { modifies: true },\n  params: [\n    { name: 'size', type: 'number', array: true, length: 2, required: true },\n    { name: 'sort', type: 'compare' },\n    { name: 'anchor', type: 'string', array: true, default: Anchors },\n    { name: 'offset', type: 'number', array: true, default: [1] },\n    { name: 'padding', type: 'number', default: 0, null: true },\n    { name: 'lineAnchor', type: 'string', values: ['start', 'end'], default: 'end' },\n    { name: 'markIndex', type: 'number', default: 0 },\n    { name: 'avoidBaseMark', type: 'boolean', default: true },\n    { name: 'avoidMarks', type: 'data', array: true },\n    { name: 'method', type: 'string', default: 'naive'},\n    { name: 'as', type: 'string', array: true, length: Output.length, default: Output }\n  ]\n};\n\ninherits(Label, Transform, {\n  transform(_, pulse) {\n    function modp(param) {\n      const p = _[param];\n      return isFunction(p) && pulse.modified(p.fields);\n    }\n\n    const mod = _.modified();\n    if (!(mod || pulse.changed(pulse.ADD_REM) || modp('sort'))) return;\n    if (!_.size || _.size.length !== 2) {\n      error('Size parameter should be specified as a [width, height] array.');\n    }\n\n    const as = _.as || Output;\n\n    // run label layout\n    labelLayout(\n      pulse.materialize(pulse.SOURCE).source || [],\n      _.size,\n      _.sort,\n      array(_.offset == null ? 1 : _.offset),\n      array(_.anchor || Anchors),\n      _.avoidMarks || [],\n      _.avoidBaseMark !== false,\n      _.lineAnchor || 'end',\n      _.markIndex || 0,\n      _.padding === undefined ? 0 : _.padding,\n      _.method || 'naive'\n    ).forEach(l => {\n      // write layout results to data stream\n      const t = l.datum;\n      t[as[0]] = l.x;\n      t[as[1]] = l.y;\n      t[as[2]] = l.opacity;\n      t[as[3]] = l.align;\n      t[as[4]] = l.baseline;\n    });\n\n    return pulse.reflow(mod).modifies(as);\n  }\n});\n"],"names":["ALPHA_MASK","getBuffer","context","width","height","Uint32Array","getImageData","data","buffer","draw","items","interior","length","type","mark","marktype","forEach","group","Marks","map","prepare","source","item","rederive","stroke","strokeOpacity","fill","fillOpacity","DIV","MOD","SIZE","RIGHT0","RIGHT1","i","scaler","padding","ratio","Math","max","sqrt","w","h","scale","_","invert","bitmap","array","_set","index","mask","_clear","get","x","y","set","clear","getRange","x2","y2","start","end","indexStart","indexEnd","r","setRange","clearRange","outOfBounds","Bitmap","textWidth","textHeight","collision","$","bm0","bm1","x1","y1","X_DIR","Y_DIR","Aligns","Baselines","test","_x1","_x2","_y1","_y2","boundary","isInside","anchorCode","TOP","top","left","MIDDLE","middle","right","BOTTOM","bottom","placeAreaLabel","naive","bitmaps","avoidBaseMark","markIndex","d","datum","n","fontSize","textMetrics","text","areaWidth","maxAreaWidth","undefined","abs","align","baseline","tryLabel","_x","_y","maxSize","mid","lo","hi","_xMid","_yMid","result","swapTmp","labelPlaced","labelPlaced2","floodfill","bm2","stack","push","pop","j","labelLayout","texts","size","compare","offset","anchor","avoidMarks","lineAnchor","method","positions","offsets","count","Float64Array","getOffsets","anchors","Int8Array","getAnchors","grouptype","isGroupArea","xy","NaN","b","bounds","markBoundary","infPadding","Infinity","isNaiveGroupArea","maxTextWidth","maxTextHeight","opacity","sort","a","labelInside","baseMark","border","canvas","getContext","baseMarkContext","strokeContext","baseMarkBuffer","strokeBuffer","layer1","layer2","u","v","alpha","strokeAlpha","baseMarkAlpha","markBitmaps","baseBitmaps","place","dx","dy","sizeFactor","insideFactor","xc","yc","SQRT1_2","placeMarkLabel","Output","Anchors","Label","params","Transform","call","this","Definition","metadata","modifies","name","required","default","null","values","inherits","transform","pulse","mod","modified","changed","ADD_REM","param","p","isFunction","fields","modp","error","as","materialize","SOURCE","l","t","reflow"],"mappings":"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"}