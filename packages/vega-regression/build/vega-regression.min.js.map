{"version":3,"file":"vega-regression.min.js","sources":["../src/partition.js","../src/Loess.js","../src/Regression.js"],"sourcesContent":["export default function(data, groupby) {\n  var groups = [],\n      get = function(f) { return f(t); },\n      map, i, n, t, k, g;\n\n  // partition data points into stack groups\n  if (groupby == null) {\n    groups.push(data);\n  } else {\n    for (map={}, i=0, n=data.length; i<n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n      if (!g) {\n        map[k] = (g = []);\n        g.dims = k;\n        groups.push(g);\n      }\n      g.push(t);\n    }\n  }\n\n  return groups;\n}\n","import partition from './partition';\nimport {regressionLoess} from 'vega-statistics';\nimport {Transform, ingest} from 'vega-dataflow';\nimport {accessorName, inherits} from 'vega-util';\n\n/**\n * Compute locally-weighted regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {number} [params.bandwidth=0.3] - The loess bandwidth.\n */\nexport default function Loess(params) {\n  Transform.call(this, null, params);\n}\n\nLoess.Definition = {\n  'type': 'Loess',\n  'metadata': {'generates': true},\n  'params': [\n    { 'name': 'x', 'type': 'field', 'required': true },\n    { 'name': 'y', 'type': 'field', 'required': true },\n    { 'name': 'groupby', 'type': 'field', 'array': true },\n    { 'name': 'bandwidth', 'type': 'number', 'default': 0.3 },\n    { 'name': 'as', 'type': 'string', 'array': true }\n  ]\n};\n\ninherits(Loess, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n    if (!this.value || pulse.changed() || _.modified()) {\n      const source = pulse.materialize(pulse.SOURCE).source,\n            groups = partition(source, _.groupby),\n            names = (_.groupby || []).map(accessorName),\n            m = names.length,\n            as = _.as || [accessorName(_.x), accessorName(_.y)],\n            values = [];\n\n      groups.forEach(g => {\n        regressionLoess(g, _.x, _.y, _.bandwidth || 0.3).forEach(p => {\n          const t = {};\n          for (let i=0; i<m; ++i) {\n            t[names[i]] = g.dims[i];\n          }\n          t[as[0]] = p[0];\n          t[as[1]] = p[1];\n          values.push(ingest(t));\n        });\n      });\n\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n\n    return out;\n  }\n});\n","import partition from './partition';\nimport {Transform, ingest} from 'vega-dataflow';\nimport {\n  regressionConstant, regressionExp, regressionLinear, regressionLog,\n  regressionPoly, regressionPow, regressionQuad, sampleCurve\n} from 'vega-statistics';\nimport {accessorName, error, extent, hasOwnProperty, inherits} from 'vega-util';\n\nconst Methods = {\n  constant: regressionConstant,\n  linear:   regressionLinear,\n  log:      regressionLog,\n  exp:      regressionExp,\n  pow:      regressionPow,\n  quad:     regressionQuad,\n  poly:     regressionPoly\n};\n\nconst degreesOfFreedom = (method, order) =>\n  method === 'poly' ? order : method === 'quad' ? 2 : 1;\n\n/**\n * Compute regression fits for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.x - An accessor for the predictor data field.\n * @param {function(object): *} params.y - An accessor for the predicted data field.\n * @param {string} [params.method='linear'] - The regression method to apply.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {Array<number>} [params.extent] - The domain extent over which to plot the regression line.\n * @param {number} [params.order=3] - The polynomial order. Only applies to the 'poly' method.\n */\nexport default function Regression(params) {\n  Transform.call(this, null, params);\n}\n\nRegression.Definition = {\n  'type': 'Regression',\n  'metadata': {'generates': true},\n  'params': [\n    { 'name': 'x', 'type': 'field', 'required': true },\n    { 'name': 'y', 'type': 'field', 'required': true },\n    { 'name': 'groupby', 'type': 'field', 'array': true },\n    { 'name': 'method', 'type': 'string', 'default': 'linear', 'values': Object.keys(Methods) },\n    { 'name': 'order', 'type': 'number', 'default': 3 },\n    { 'name': 'extent', 'type': 'number', 'array': true, 'length': 2 },\n    { 'name': 'params', 'type': 'boolean', 'default': false },\n    { 'name': 'as', 'type': 'string', 'array': true }\n  ]\n};\n\ninherits(Regression, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n    if (!this.value || pulse.changed() || _.modified()) {\n      const source = pulse.materialize(pulse.SOURCE).source,\n            groups = partition(source, _.groupby),\n            names = (_.groupby || []).map(accessorName),\n            method = _.method || 'linear',\n            order = _.order == null ? 3 : _.order,\n            dof = degreesOfFreedom(method, order),\n            as = _.as || [accessorName(_.x), accessorName(_.y)],\n            fit = Methods[method],\n            values = [];\n\n      let domain = _.extent;\n\n      if (!hasOwnProperty(Methods, method)) {\n        error('Invalid regression method: ' + method);\n      }\n\n      if (domain != null) {\n        if (method === 'log' && domain[0] <= 0) {\n          pulse.dataflow.warn('Ignoring extent with values <= 0 for log regression.');\n          domain = null;\n        }\n      }\n\n      groups.forEach(g => {\n        const n = g.length;\n        if (n <= dof) {\n          pulse.dataflow.warn('Skipping regression with more parameters than data points.');\n          return;\n        }\n\n        const model = fit(g, _.x, _.y, order);\n\n        if (_.params) {\n          // if parameter vectors requested return those\n          values.push(ingest({\n            keys: g.dims,\n            coef: model.coef,\n            rSquared: model.rSquared\n          }));\n          return;\n        }\n\n        const dom = domain || extent(g, _.x),\n              add = p => {\n                const t = {};\n                for (let i=0; i<names.length; ++i) {\n                  t[names[i]] = g.dims[i];\n                }\n                t[as[0]] = p[0];\n                t[as[1]] = p[1];\n                values.push(ingest(t));\n              };\n\n        if (method === 'linear' || method === 'constant') {\n          // for linear or constant regression we only need the end points\n          dom.forEach(x => add([x, model.predict(x)]));\n        } else {\n          // otherwise return trend line sample points\n          sampleCurve(model.predict, dom, 25, 200).forEach(add);\n        }\n      });\n\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n\n    return out;\n  }\n});\n"],"names":["partition","data","groupby","map","i","n","t","k","g","groups","get","f","push","length","dims","Loess","params","Transform","call","this","Definition","type","metadata","generates","name","required","array","default","inherits","transform","_","pulse","out","fork","NO_SOURCE","NO_FIELDS","value","changed","modified","materialize","SOURCE","source","names","accessorName","m","as","x","y","values","forEach","regressionLoess","bandwidth","p","ingest","rem","add","Methods","constant","regressionConstant","linear","regressionLinear","log","regressionLog","exp","regressionExp","pow","regressionPow","quad","regressionQuad","poly","regressionPoly","Regression","Object","keys","method","order","dof","degreesOfFreedom","fit","domain","extent","hasOwnProperty","error","dataflow","warn","model","coef","rSquared","dom","predict","sampleCurve"],"mappings":"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"}