{"version":3,"file":"vega-crossfilter.min.js","sources":["../src/arrays.js","../src/Bitmaps.js","../src/Dimension.js","../../../node_modules/d3-array/src/ascending.js","../../../node_modules/d3-array/src/descending.js","../../../node_modules/d3-array/src/bisector.js","../../../node_modules/d3-array/src/bisect.js","../src/SortedIndex.js","../../../node_modules/d3-array/src/permute.js","../src/CrossFilter.js","../src/ResolveFilter.js","../../../node_modules/d3-array/src/number.js"],"sourcesContent":["export const array8 = n => new Uint8Array(n);\n\nexport const array16 = n => new Uint16Array(n);\n\nexport const array32 = n => new Uint32Array(n);\n","import {array16, array32, array8} from './arrays';\n\n/**\n * Maintains CrossFilter state.\n */\nexport default function Bitmaps() {\n\n  let width = 8,\n      data = [],\n      seen = array32(0),\n      curr = array(0, width),\n      prev = array(0, width);\n\n  return {\n    data: () => data,\n\n    seen: () => (seen = lengthen(seen, data.length)),\n\n    add(array) {\n      for (let i=0, j=data.length, n=array.length, t; i<n; ++i) {\n        t = array[i];\n        t._index = j++;\n        data.push(t);\n      }\n    },\n\n    remove(num, map) { // map: index -> boolean (true => remove)\n      const n = data.length,\n            copy = Array(n - num),\n            reindex = data; // reuse old data array for index map\n      let t, i, j;\n\n      // seek forward to first removal\n      for (i=0; !map[i] && i<n; ++i) {\n        copy[i] = data[i];\n        reindex[i] = i;\n      }\n\n      // condense arrays\n      for (j=i; i<n; ++i) {\n        t = data[i];\n        if (!map[i]) {\n          reindex[i] = j;\n          curr[j] = curr[i];\n          prev[j] = prev[i];\n          copy[j] = t;\n          t._index = j++;\n        } else {\n          reindex[i] = -1;\n        }\n        curr[i] = 0; // clear unused bits\n      }\n\n      data = copy;\n      return reindex;\n    },\n\n    size: () => data.length,\n\n    curr: () => curr,\n\n    prev: () => prev,\n\n    reset: k => prev[k] = curr[k],\n\n    all: () =>\n      width < 0x101 ? 0xff : width < 0x10001 ? 0xffff : 0xffffffff,\n\n    set(k, one) { curr[k] |= one; },\n\n    clear(k, one) { curr[k] &= ~one; },\n\n    resize(n, m) {\n      const k = curr.length;\n      if (n > k || m > width) {\n        width = Math.max(m, width);\n        curr = array(n, width, curr);\n        prev = array(n, width);\n      }\n    }\n  };\n}\n\nfunction lengthen(array, length, copy) {\n  if (array.length >= length) return array;\n  copy = copy || new array.constructor(length);\n  copy.set(array);\n  return copy;\n}\n\nfunction array(n, m, array) {\n  const copy = (m < 0x101 ? array8\n      : m < 0x10001 ? array16\n      : array32)(n);\n  if (array) copy.set(array);\n  return copy;\n}\n","export default function(index, i, query) {\n  const bit = (1 << i);\n\n  return {\n    one:     bit,\n    zero:    ~bit,\n    range:   query.slice(),\n    bisect:  index.bisect,\n    index:   index.index,\n    size:    index.size,\n\n    onAdd(added, curr) {\n      const dim = this,\n            range = dim.bisect(dim.range, added.value),\n            idx = added.index,\n            lo = range[0],\n            hi = range[1],\n            n1 = idx.length;\n      let i;\n\n      for (i=0;  i<lo; ++i) curr[idx[i]] |= bit;\n      for (i=hi; i<n1; ++i) curr[idx[i]] |= bit;\n      return dim;\n    }\n  };\n}\n","export default function ascending(a, b) {\n  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n","export default function descending(a, b) {\n  return a == null || b == null ? NaN\n    : b < a ? -1\n    : b > a ? 1\n    : b >= a ? 0\n    : NaN;\n}\n","import ascending from \"./ascending.js\";\nimport descending from \"./descending.js\";\n\nexport default function bisector(f) {\n  let compare1, compare2, delta;\n\n  // If an accessor is specified, promote it to a comparator. In this case we\n  // can test whether the search value is (self-) comparable. We can’t do this\n  // for a comparator (except for specific, known comparators) because we can’t\n  // tell if the comparator is symmetric, and an asymmetric comparator can’t be\n  // used to test whether a single value is comparable.\n  if (f.length !== 2) {\n    compare1 = ascending;\n    compare2 = (d, x) => ascending(f(d), x);\n    delta = (d, x) => f(d) - x;\n  } else {\n    compare1 = f === ascending || f === descending ? f : zero;\n    compare2 = f;\n    delta = f;\n  }\n\n  function left(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function right(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) <= 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function center(a, x, lo = 0, hi = a.length) {\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {left, center, right};\n}\n\nfunction zero() {\n  return 0;\n}\n","import ascending from \"./ascending.js\";\nimport bisector from \"./bisector.js\";\nimport number from \"./number.js\";\n\nconst ascendingBisect = bisector(ascending);\nexport const bisectRight = ascendingBisect.right;\nexport const bisectLeft = ascendingBisect.left;\nexport const bisectCenter = bisector(number).center;\nexport default bisectRight;\n","import {array32} from './arrays';\nimport {bisectLeft, bisectRight, permute} from 'd3-array';\n\n/**\n * Maintains a list of values, sorted by key.\n */\nexport default function SortedIndex() {\n  let index = array32(0),\n      value = [],\n      size = 0;\n\n  function insert(key, data, base) {\n    if (!data.length) return [];\n\n    const n0 = size,\n        n1 = data.length,\n        addi = array32(n1);\n    let addv = Array(n1),\n        oldv, oldi, i;\n\n    for (i=0; i<n1; ++i) {\n      addv[i] = key(data[i]);\n      addi[i] = i;\n    }\n    addv = sort(addv, addi);\n\n    if (n0) {\n      oldv = value;\n      oldi = index;\n      value = Array(n0 + n1);\n      index = array32(n0 + n1);\n      merge(base, oldv, oldi, n0, addv, addi, n1, value, index);\n    } else {\n      if (base > 0) for (i=0; i<n1; ++i) {\n        addi[i] += base;\n      }\n      value = addv;\n      index = addi;\n    }\n    size = n0 + n1;\n\n    return {index: addi, value: addv};\n  }\n\n  function remove(num, map) {\n    // map: index -> remove\n    const n = size;\n    let idx, i, j;\n\n    // seek forward to first removal\n    for (i=0; !map[index[i]] && i<n; ++i);\n\n    // condense index and value arrays\n    for (j=i; i<n; ++i) {\n      if (!map[idx=index[i]]) {\n        index[j] = idx;\n        value[j] = value[i];\n        ++j;\n      }\n    }\n\n    size = n - num;\n  }\n\n  function reindex(map) {\n    for (let i=0, n=size; i<n; ++i) {\n      index[i] = map[index[i]];\n    }\n  }\n\n  function bisect(range, array) {\n    let n;\n    if (array) {\n      n = array.length;\n    } else {\n      array = value;\n      n = size;\n    }\n    return [\n      bisectLeft(array, range[0], 0, n),\n      bisectRight(array, range[1], 0, n)\n    ];\n  }\n\n  return {\n    insert:  insert,\n    remove:  remove,\n    bisect:  bisect,\n    reindex: reindex,\n    index:   () => index,\n    size:    () => size\n  };\n}\n\nfunction sort(values, index) {\n  values.sort.call(index, (a, b) => {\n    const x = values[a],\n          y = values[b];\n    return x < y ? -1 : x > y ? 1 : 0;\n  });\n  return permute(values, index);\n}\n\nfunction merge(base, value0, index0, n0, value1, index1, n1, value, index) {\n  let i0 = 0, i1 = 0, i;\n\n  for (i=0; i0 < n0 && i1 < n1; ++i) {\n    if (value0[i0] < value1[i1]) {\n      value[i] = value0[i0];\n      index[i] = index0[i0++];\n    } else {\n      value[i] = value1[i1];\n      index[i] = index1[i1++] + base;\n    }\n  }\n\n  for (; i0 < n0; ++i0, ++i) {\n    value[i] = value0[i0];\n    index[i] = index0[i0];\n  }\n\n  for (; i1 < n1; ++i1, ++i) {\n    value[i] = value1[i1];\n    index[i] = index1[i1] + base;\n  }\n}\n","export default function permute(source, keys) {\n  return Array.from(keys, key => source[key]);\n}\n","import Bitmaps from './Bitmaps';\nimport Dimension from './Dimension';\nimport SortedIndex from './SortedIndex';\nimport {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * An indexed multi-dimensional filter.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.\n * @param {Array} params.query - An array of per-dimension range queries.\n */\nexport default function CrossFilter(params) {\n  Transform.call(this, Bitmaps(), params);\n  this._indices = null;\n  this._dims = null;\n}\n\nCrossFilter.Definition = {\n  'type': 'CrossFilter',\n  'metadata': {},\n  'params': [\n    { 'name': 'fields', 'type': 'field', 'array': true, 'required': true },\n    { 'name': 'query', 'type': 'array', 'array': true, 'required': true,\n      'content': {'type': 'number', 'array': true, 'length': 2} }\n  ]\n};\n\ninherits(CrossFilter, Transform, {\n  transform(_, pulse) {\n    if (!this._dims) {\n      return this.init(_, pulse);\n    } else {\n      var init = _.modified('fields')\n            || _.fields.some(f => pulse.modified(f.fields));\n\n      return init\n        ? this.reinit(_, pulse)\n        : this.eval(_, pulse);\n    }\n  },\n\n  init(_, pulse) {\n    const fields = _.fields,\n          query = _.query,\n          indices = this._indices = {},\n          dims = this._dims = [],\n          m = query.length;\n    let i = 0, key, index;\n\n    // instantiate indices and dimensions\n    for (; i<m; ++i) {\n      key = fields[i].fname;\n      index = indices[key] || (indices[key] = SortedIndex());\n      dims.push(Dimension(index, i, query[i]));\n    }\n\n    return this.eval(_, pulse);\n  },\n\n  reinit(_, pulse) {\n    const output = pulse.materialize().fork(),\n          fields = _.fields,\n          query = _.query,\n          indices = this._indices,\n          dims = this._dims,\n          bits = this.value,\n          curr = bits.curr(),\n          prev = bits.prev(),\n          all = bits.all(),\n          out = (output.rem = output.add),\n          mod = output.mod,\n          m = query.length,\n          adds = {};\n    let add, index, key, mods, remMap, modMap, i, n, f;\n\n    // set prev to current state\n    prev.set(curr);\n\n    // if pulse has remove tuples, process them first\n    if (pulse.rem.length) {\n      remMap = this.remove(_, pulse, output);\n    }\n\n    // if pulse has added tuples, add them to state\n    if (pulse.add.length) {\n      bits.add(pulse.add);\n    }\n\n    // if pulse has modified tuples, create an index map\n    if (pulse.mod.length) {\n      modMap = {};\n      for (mods=pulse.mod, i=0, n=mods.length; i<n; ++i) {\n        modMap[mods[i]._index] = 1;\n      }\n    }\n\n    // re-initialize indices as needed, update curr bitmap\n    for (i=0; i<m; ++i) {\n      f = fields[i];\n      if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {\n        key = f.fname;\n        if (!(add = adds[key])) {\n          indices[key] = index = SortedIndex();\n          adds[key] = add = index.insert(f, pulse.source, 0);\n        }\n        dims[i] = Dimension(index, i, query[i]).onAdd(add, curr);\n      }\n    }\n\n    // visit each tuple\n    // if filter state changed, push index to add/rem\n    // else if in mod and passes a filter, push index to mod\n    for (i=0, n=bits.data().length; i<n; ++i) {\n      if (remMap[i]) { // skip if removed tuple\n        continue;\n      } else if (prev[i] !== curr[i]) { // add if state changed\n        out.push(i);\n      } else if (modMap[i] && curr[i] !== all) { // otherwise, pass mods through\n        mod.push(i);\n      }\n    }\n\n    bits.mask = (1 << m) - 1;\n    return output;\n  },\n\n  eval(_, pulse) {\n    const output = pulse.materialize().fork(),\n          m = this._dims.length;\n    let mask = 0;\n\n    if (pulse.rem.length) {\n      this.remove(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    if (_.modified('query') && !_.modified('fields')) {\n      mask |= this.update(_, pulse, output);\n    }\n\n    if (pulse.add.length) {\n      this.insert(_, pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    if (pulse.mod.length) {\n      this.modify(pulse, output);\n      mask |= (1 << m) - 1;\n    }\n\n    this.value.mask = mask;\n    return output;\n  },\n\n  insert(_, pulse, output) {\n    const tuples = pulse.add,\n          bits = this.value,\n          dims = this._dims,\n          indices = this._indices,\n          fields = _.fields,\n          adds = {},\n          out = output.add,\n          n = bits.size() + tuples.length,\n          m = dims.length;\n    let k = bits.size(), j, key, add;\n\n    // resize bitmaps and add tuples as needed\n    bits.resize(n, m);\n    bits.add(tuples);\n\n    const curr = bits.curr(),\n          prev = bits.prev(),\n          all  = bits.all();\n\n    // add to dimensional indices\n    for (j=0; j<m; ++j) {\n      key = fields[j].fname;\n      add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));\n      dims[j].onAdd(add, curr);\n    }\n\n    // set previous filters, output if passes at least one filter\n    for (; k < n; ++k) {\n      prev[k] = all;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n\n  modify(pulse, output) {\n    const out = output.mod,\n          bits = this.value,\n          curr = bits.curr(),\n          all  = bits.all(),\n          tuples = pulse.mod;\n    let i, n, k;\n\n    for (i=0, n=tuples.length; i<n; ++i) {\n      k = tuples[i]._index;\n      if (curr[k] !== all) out.push(k);\n    }\n  },\n\n  remove(_, pulse, output) {\n    const indices = this._indices,\n          bits = this.value,\n          curr = bits.curr(),\n          prev = bits.prev(),\n          all  = bits.all(),\n          map = {},\n          out = output.rem,\n          tuples = pulse.rem;\n    let i, n, k, f;\n\n    // process tuples, output if passes at least one filter\n    for (i=0, n=tuples.length; i<n; ++i) {\n      k = tuples[i]._index;\n      map[k] = 1; // build index map\n      prev[k] = (f = curr[k]);\n      curr[k] = all;\n      if (f !== all) out.push(k);\n    }\n\n    // remove from dimensional indices\n    for (k in indices) {\n      indices[k].remove(n, map);\n    }\n\n    this.reindex(pulse, n, map);\n    return map;\n  },\n\n  // reindex filters and indices after propagation completes\n  reindex(pulse, num, map) {\n    const indices = this._indices,\n          bits = this.value;\n\n    pulse.runAfter(() => {\n      const indexMap = bits.remove(num, map);\n      for (const key in indices) indices[key].reindex(indexMap);\n    });\n  },\n\n  update(_, pulse, output) {\n    const dims = this._dims,\n          query = _.query,\n          stamp = pulse.stamp,\n          m = dims.length;\n    let mask = 0, i, q;\n\n    // survey how many queries have changed\n    output.filters = 0;\n    for (q=0; q<m; ++q) {\n      if (_.modified('query', q)) { i = q; ++mask; }\n    }\n\n    if (mask === 1) {\n      // only one query changed, use more efficient update\n      mask = dims[i].one;\n      this.incrementOne(dims[i], query[i], output.add, output.rem);\n    } else {\n      // multiple queries changed, perform full record keeping\n      for (q=0, mask=0; q<m; ++q) {\n        if (!_.modified('query', q)) continue;\n        mask |= dims[q].one;\n        this.incrementAll(dims[q], query[q], stamp, output.add);\n        output.rem = output.add; // duplicate add/rem for downstream resolve\n      }\n    }\n\n    return mask;\n  },\n\n  incrementAll(dim, query, stamp, out) {\n    const bits = this.value,\n          seen = bits.seen(),\n          curr = bits.curr(),\n          prev = bits.prev(),\n          index = dim.index(),\n          old = dim.bisect(dim.range),\n          range = dim.bisect(query),\n          lo1 = range[0],\n          hi1 = range[1],\n          lo0 = old[0],\n          hi0 = old[1],\n          one = dim.one;\n    let i, j, k;\n\n    // Fast incremental update based on previous lo index.\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    }\n\n    // Fast incremental update based on previous hi index.\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n        if (seen[k] !== stamp) {\n          prev[k] = curr[k];\n          seen[k] = stamp;\n          out.push(k);\n        }\n        curr[k] ^= one;\n      }\n    }\n\n    dim.range = query.slice();\n  },\n\n  incrementOne(dim, query, add, rem) {\n    const bits = this.value,\n          curr = bits.curr(),\n          index = dim.index(),\n          old = dim.bisect(dim.range),\n          range = dim.bisect(query),\n          lo1 = range[0],\n          hi1 = range[1],\n          lo0 = old[0],\n          hi0 = old[1],\n          one = dim.one;\n    let i, j, k;\n\n    // Fast incremental update based on previous lo index.\n    if (lo1 < lo0) {\n      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (lo1 > lo0) {\n      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    }\n\n    // Fast incremental update based on previous hi index.\n    if (hi1 > hi0) {\n      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        add.push(k);\n      }\n    } else if (hi1 < hi0) {\n      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n        k = index[i];\n        curr[k] ^= one;\n        rem.push(k);\n      }\n    }\n\n    dim.range = query.slice();\n  }\n});\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Selectively filters tuples by resolving against a filter bitmap.\n * Useful for processing the output of a cross-filter transform.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.ignore - A bit mask indicating which filters to ignore.\n * @param {object} params.filter - The per-tuple filter bitmaps. Typically this\n *   parameter value is a reference to a {@link CrossFilter} transform.\n */\nexport default function ResolveFilter(params) {\n  Transform.call(this, null, params);\n}\n\nResolveFilter.Definition = {\n  'type': 'ResolveFilter',\n  'metadata': {},\n  'params': [\n    { 'name': 'ignore', 'type': 'number', 'required': true,\n      'description': 'A bit mask indicating which filters to ignore.' },\n    { 'name': 'filter', 'type': 'object', 'required': true,\n      'description': 'Per-tuple filter bitmaps from a CrossFilter transform.' }\n  ]\n};\n\ninherits(ResolveFilter, Transform, {\n  transform(_, pulse) {\n    const ignore = ~(_.ignore || 0), // bit mask where zeros -> dims to ignore\n          bitmap = _.filter,\n          mask = bitmap.mask;\n\n    // exit early if no relevant filter changes\n    if ((mask & ignore) === 0) return pulse.StopPropagation;\n\n    const output = pulse.fork(pulse.ALL),\n          data = bitmap.data(),\n          curr = bitmap.curr(),\n          prev = bitmap.prev(),\n          pass = k => !(curr[k] & ignore) ? data[k] : null;\n\n    // propagate all mod tuples that pass the filter\n    output.filter(output.MOD, pass);\n\n    // determine add & rem tuples via filter functions\n    // for efficiency, we do *not* populate new arrays,\n    // instead we add filter functions applied downstream\n\n    if (!(mask & (mask-1))) { // only one filter changed\n      output.filter(output.ADD, pass);\n      output.filter(output.REM, k =>\n        (curr[k] & ignore) === mask ? data[k] : null);\n\n    } else { // multiple filters changed\n      output.filter(output.ADD, k => {\n        const c = curr[k] & ignore,\n              f = !c && (c ^ (prev[k] & ignore));\n        return f ? data[k] : null;\n      });\n      output.filter(output.REM, k => {\n        const c = curr[k] & ignore,\n              f = c && !(c ^ (c ^ (prev[k] & ignore)));\n        return f ? data[k] : null;\n      });\n    }\n\n    // add filter to source data in case of reflow...\n    return output.filter(output.SOURCE, t => pass(t._index));\n  }\n});\n","export default function number(x) {\n  return x === null ? NaN : +x;\n}\n\nexport function* numbers(values, valueof) {\n  if (valueof === undefined) {\n    for (let value of values) {\n      if (value != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  }\n}\n"],"names":["array8","n","Uint8Array","array16","Uint16Array","array32","Uint32Array","array","m","copy","set","Dimension","index","i","query","bit","one","zero","range","slice","bisect","size","onAdd","added","curr","dim","this","value","idx","lo","hi","n1","length","ascending","a","b","NaN","descending","bisector","f","compare1","compare2","delta","left","x","arguments","undefined","mid","d","center","right","ascendingBisect","bisectRight","bisectLeft","SortedIndex","insert","key","data","base","n0","addi","oldv","oldi","addv","Array","values","sort","call","y","source","keys","from","permute","value0","index0","value1","index1","i0","i1","merge","remove","num","map","j","reindex","CrossFilter","params","Transform","width","seen","prev","constructor","lengthen","add","t","_index","push","reset","k","all","clear","resize","Math","max","Bitmaps","_indices","_dims","ResolveFilter","Definition","type","metadata","name","required","content","inherits","transform","_","pulse","modified","fields","some","reinit","eval","init","indices","dims","fname","output","materialize","fork","bits","out","rem","mod","adds","mods","remMap","modMap","mask","update","modify","tuples","runAfter","indexMap","stamp","q","filters","incrementOne","incrementAll","old","lo1","hi1","lo0","hi0","min","description","ignore","bitmap","filter","StopPropagation","ALL","pass","MOD","ADD","c","REM","SOURCE"],"mappings":"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","x_google_ignoreList":[3,4,5,6,8,11]}