{"version":3,"file":"vega-view-transforms.min.js","sources":["../src/constants.js","../src/Bound.js","../src/Identifier.js","../src/Mark.js","../src/Overlap.js","../src/Render.js","../src/layout/util.js","../src/layout/axis.js","../src/layout/grid.js","../src/layout/legend.js","../src/ViewLayout.js","../src/layout/title.js"],"sourcesContent":["export const Top = 'top';\nexport const Left = 'left';\nexport const Right = 'right';\nexport const Bottom = 'bottom';\n\nexport const TopLeft = 'top-left';\nexport const TopRight = 'top-right';\nexport const BottomLeft = 'bottom-left';\nexport const BottomRight = 'bottom-right';\n\nexport const Start = 'start';\nexport const Middle = 'middle';\nexport const End = 'end';\n\nexport const X = 'x';\nexport const Y = 'y';\n\nexport const Group = 'group';\n\nexport const AxisRole = 'axis';\nexport const TitleRole = 'title';\nexport const FrameRole = 'frame';\nexport const ScopeRole = 'scope';\nexport const LegendRole = 'legend';\n\nexport const RowHeader = 'row-header';\nexport const RowFooter = 'row-footer';\nexport const RowTitle  = 'row-title';\nexport const ColHeader = 'column-header';\nexport const ColFooter = 'column-footer';\nexport const ColTitle  = 'column-title';\n\nexport const Padding = 'padding';\n\nexport const Symbols = 'symbol';\n\nexport const Fit  = 'fit';\nexport const FitX = 'fit-x';\nexport const FitY = 'fit-y';\nexport const Pad  = 'pad';\nexport const None = 'none';\n\nexport const All = 'all';\nexport const Each = 'each';\nexport const Flush = 'flush';\n\nexport const Column = 'column';\nexport const Row = 'row';\n","import {AxisRole, Group, LegendRole, TitleRole} from './constants';\nimport {Transform} from 'vega-dataflow';\nimport {Marks, boundClip} from 'vega-scenegraph';\nimport {inherits} from 'vega-util';\n\n/**\n * Calculate bounding boxes for scenegraph items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - The scenegraph mark instance to bound.\n */\nexport default function Bound(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Bound, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow,\n          mark = _.mark,\n          type = mark.marktype,\n          entry = Marks[type],\n          bound = entry.bound;\n\n    let markBounds = mark.bounds, rebound;\n\n    if (entry.nested) {\n      // multi-item marks have a single bounds instance\n      if (mark.items.length) view.dirty(mark.items[0]);\n      markBounds = boundItem(mark, bound);\n      mark.items.forEach(item => {\n        item.bounds.clear().union(markBounds);\n      });\n    }\n\n    else if (type === Group || _.modified()) {\n      // operator parameters modified -> re-bound all items\n      // updates group bounds in response to modified group content\n      pulse.visit(pulse.MOD, item => view.dirty(item));\n      markBounds.clear();\n      mark.items.forEach(item => markBounds.union(boundItem(item, bound)));\n\n      // force reflow for axes/legends/titles to propagate any layout changes\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n        case TitleRole:\n          pulse.reflow();\n      }\n    }\n\n    else {\n      // incrementally update bounds, re-bound mark as needed\n      rebound = pulse.changed(pulse.REM);\n\n      pulse.visit(pulse.ADD, item => {\n        markBounds.union(boundItem(item, bound));\n      });\n\n      pulse.visit(pulse.MOD, item => {\n        rebound = rebound || markBounds.alignsWith(item.bounds);\n        view.dirty(item);\n        markBounds.union(boundItem(item, bound));\n      });\n\n      if (rebound) {\n        markBounds.clear();\n        mark.items.forEach(item => markBounds.union(item.bounds));\n      }\n    }\n\n    // ensure mark bounds do not exceed any clipping region\n    boundClip(mark);\n\n    return pulse.modifies('bounds');\n  }\n});\n\nfunction boundItem(item, bound, opt) {\n  return bound(item.bounds.clear(), item, opt);\n}\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\nconst COUNTER_NAME = ':vega_identifier:';\n\n/**\n * Adds a unique identifier to all added tuples.\n * This transform creates a new signal that serves as an id counter.\n * As a result, the id counter is shared across all instances of this\n * transform, generating unique ids across multiple data streams. In\n * addition, this signal value can be included in a snapshot of the\n * dataflow state, enabling correct resumption of id allocation.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {string} params.as - The field name for the generated identifier.\n */\nexport default function Identifier(params) {\n  Transform.call(this, 0, params);\n}\n\nIdentifier.Definition = {\n  'type': 'Identifier',\n  'metadata': {'modifies': true},\n  'params': [\n    { 'name': 'as', 'type': 'string', 'required': true }\n  ]\n};\n\ninherits(Identifier, Transform, {\n  transform(_, pulse) {\n    const counter = getCounter(pulse.dataflow),\n          as = _.as;\n    let id = counter.value;\n\n    pulse.visit(pulse.ADD, t => (t[as] = t[as] || ++id));\n    counter.set(this.value = id);\n    return pulse;\n  }\n});\n\nfunction getCounter(view) {\n  return view._signals[COUNTER_NAME]\n     || (view._signals[COUNTER_NAME] = view.add(0));\n}\n","import {Group} from './constants';\nimport {Transform} from 'vega-dataflow';\nimport {GroupItem, Item} from 'vega-scenegraph';\nimport {inherits} from 'vega-util';\n\n/**\n * Bind scenegraph items to a scenegraph mark instance.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.markdef - The mark definition for creating the mark.\n *   This is an object of legal scenegraph mark properties which *must* include\n *   the 'marktype' property.\n */\nexport default function Mark(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Mark, Transform, {\n  transform(_, pulse) {\n    let mark = this.value;\n\n    // acquire mark on first invocation, bind context and group\n    if (!mark) {\n      mark = pulse.dataflow.scenegraph().mark(_.markdef, lookup(_), _.index);\n      mark.group.context = _.context;\n      if (!_.context.group) _.context.group = mark.group;\n      mark.source = this.source; // point to upstream collector\n      mark.clip = _.clip;\n      mark.interactive = _.interactive;\n      this.value = mark;\n    }\n\n    // initialize entering items\n    const Init = mark.marktype === Group ? GroupItem : Item;\n    pulse.visit(pulse.ADD, item => Init.call(item, mark));\n\n    // update clipping and/or interactive status\n    if (_.modified('clip') || _.modified('interactive')) {\n      mark.clip = _.clip;\n      mark.interactive = !!_.interactive;\n      mark.zdirty = true; // force scenegraph re-eval\n      pulse.reflow();\n    }\n\n    // bind items array to scenegraph mark\n    mark.items = pulse.source;\n    return pulse;\n  }\n});\n\nfunction lookup(_) {\n  const g = _.groups, p = _.parent;\n  return g && g.size === 1 ? g.get(Object.keys(g.object)[0])\n    : g && p ? g.lookup(p)\n    : null;\n}\n","import {Bottom, Top} from './constants';\nimport {Transform} from 'vega-dataflow';\nimport {Bounds} from 'vega-scenegraph';\nimport {inherits, peek} from 'vega-util';\n\n/**\n * Analyze items for overlap, changing opacity to hide items with\n * overlapping bounding boxes. This transform will preserve at least\n * two items (e.g., first and last) even if overlap persists.\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator\n *   function for sorting items.\n * @param {object} [params.method] - The overlap removal method to apply.\n *   One of 'parity' (default, hide every other item until there is no\n *   more overlap) or 'greedy' (sequentially scan and hide and items that\n *   overlap with the last visible item).\n * @param {object} [params.boundScale] - A scale whose range should be used\n *   to bound the items. Items exceeding the bounds of the scale range\n *   will be treated as overlapping. If null or undefined, no bounds check\n *   will be applied.\n * @param {object} [params.boundOrient] - The orientation of the scale\n *   (top, bottom, left, or right) used to bound items. This parameter is\n *   ignored if boundScale is null or undefined.\n * @param {object} [params.boundTolerance] - The tolerance in pixels for\n *   bound inclusion testing (default 1). This specifies by how many pixels\n *   an item's bounds may exceed the scale range bounds and not be culled.\n * @constructor\n */\nexport default function Overlap(params) {\n  Transform.call(this, null, params);\n}\n\nconst methods = {\n  parity: items =>\n    items.filter((item, i) => i % 2 ? (item.opacity = 0) : 1),\n  greedy: (items, sep) => {\n    let a;\n    return items.filter((b, i) =>\n      (!i || !intersect(a.bounds, b.bounds, sep))\n        ? (a = b, 1)\n        : (b.opacity = 0)\n    );\n  }\n};\n\n// compute bounding box intersection\n// including padding pixels of separation\nconst intersect = (a, b, sep) =>\n  sep > Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2);\n\nconst hasOverlap = (items, pad) => {\n  for (var i=1, n=items.length, a=items[0].bounds, b; i<n; a=b, ++i) {\n    if (intersect(a, b = items[i].bounds, pad)) return true;\n  }\n};\n\nconst hasBounds = item => {\n  const b = item.bounds;\n  return b.width() > 1 && b.height() > 1;\n};\n\nconst boundTest = (scale, orient, tolerance) => {\n  var range = scale.range(),\n      b = new Bounds();\n\n  if (orient === Top || orient === Bottom) {\n    b.set(range[0], -Infinity, range[1], +Infinity);\n  } else {\n    b.set(-Infinity, range[0], +Infinity, range[1]);\n  }\n  b.expand(tolerance || 1);\n\n  return item => b.encloses(item.bounds);\n};\n\n// reset all items to be fully opaque\nconst reset = source => {\n  source.forEach(item => item.opacity = 1);\n  return source;\n};\n\n// add all tuples to mod, fork pulse if parameters were modified\n// fork prevents cross-stream tuple pollution (e.g., pulse from scale)\nconst reflow = (pulse, _) =>\n  pulse.reflow(_.modified()).modifies('opacity');\n\ninherits(Overlap, Transform, {\n  transform(_, pulse) {\n    const reduce = methods[_.method] || methods.parity,\n          sep = _.separation || 0;\n\n    let source = pulse.materialize(pulse.SOURCE).source,\n        items, test;\n\n    if (!source || !source.length) return;\n\n    if (!_.method) {\n      // early exit if method is falsy\n      if (_.modified('method')) {\n        reset(source);\n        pulse = reflow(pulse, _);\n      }\n      return pulse;\n    }\n\n    // skip labels with no content\n    source = source.filter(hasBounds);\n\n    // early exit, nothing to do\n    if (!source.length) return;\n\n    if (_.sort) {\n      source = source.slice().sort(_.sort);\n    }\n\n    items = reset(source);\n    pulse = reflow(pulse, _);\n\n    if (items.length >= 3 && hasOverlap(items, sep)) {\n      do {\n        items = reduce(items, sep);\n      } while (items.length >= 3 && hasOverlap(items, sep));\n\n      if (items.length < 3 && !peek(source).opacity) {\n        if (items.length > 1) peek(items).opacity = 0;\n        peek(source).opacity = 1;\n      }\n    }\n\n    if (_.boundScale && _.boundTolerance >= 0) {\n      test = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);\n      source.forEach(item => {\n        if (!test(item)) item.opacity = 0;\n      });\n    }\n\n    // re-calculate mark bounds\n    const bounds = items[0].mark.bounds.clear();\n    source.forEach(item => {\n      if (item.opacity) bounds.union(item.bounds);\n    });\n\n    return pulse;\n  }\n});\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Queue modified scenegraph items for rendering.\n * @constructor\n */\nexport default function Render(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Render, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow;\n\n    pulse.visit(pulse.ALL, item => view.dirty(item));\n\n    // set z-index dirty flag as needed\n    if (pulse.fields && pulse.fields['zindex']) {\n      const item = pulse.source && pulse.source[0];\n      if (item) item.mark.zdirty = true;\n    }\n  }\n});\n","import {Bounds} from 'vega-scenegraph';\n\nexport const tempBounds = new Bounds();\n\nexport function set(item, property, value) {\n  return item[property] === value ? 0\n    : (item[property] = value, 1);\n}","import {Bottom, Left, Right, Top} from '../constants';\nimport {set, tempBounds} from './util';\nimport {boundStroke, multiLineOffset} from 'vega-scenegraph';\n\nexport function isYAxis(mark) {\n  var orient = mark.items[0].orient;\n  return orient === Left || orient === Right;\n}\n\nfunction axisIndices(datum) {\n  let index = +datum.grid;\n  return [\n    datum.ticks  ? index++ : -1, // ticks index\n    datum.labels ? index++ : -1, // labels index\n    index + (+datum.domain)      // title index\n  ];\n}\n\nexport function axisLayout(view, axis, width, height) {  \n  var item = axis.items[0],\n      datum = item.datum,\n      delta = item.translate != null ? item.translate : 0.5,\n      orient = item.orient,\n      indices = axisIndices(datum),\n      range = item.range,\n      offset = item.offset,\n      position = item.position,\n      minExtent = item.minExtent,\n      maxExtent = item.maxExtent,\n      title = datum.title && item.items[indices[2]].items[0],\n      titlePadding = item.titlePadding,\n      bounds = item.bounds,\n      dl = title && multiLineOffset(title),\n      x = 0, y = 0, i, s;\n\n  tempBounds.clear().union(bounds);\n  bounds.clear();\n  if ((i=indices[0]) > -1) bounds.union(item.items[i].bounds);\n  if ((i=indices[1]) > -1) bounds.union(item.items[i].bounds);\n\n  // position axis group and title\n  switch (orient) {\n    case Top:\n      x = position || 0;\n      y = -offset;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.y1));\n      bounds.add(0, -s).add(range, 0);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 0, -1, bounds);\n      break;\n    case Left:\n      x = -offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.x1));\n      bounds.add(-s, 0).add(0, range);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, -1, bounds);\n      break;\n    case Right:\n      x = width + offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.x2));\n      bounds.add(0, 0).add(s, range);\n      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, 1, bounds);\n      break;\n    case Bottom:\n      x = position || 0;\n      y = height + offset;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.y2));\n      bounds.add(0, 0).add(range, s);\n      if (title) axisTitleLayout(view, title, s, titlePadding, 0, 0, 1, bounds);\n      break;\n    default:\n      x = item.x;\n      y = item.y;\n  }\n\n  // update bounds\n  boundStroke(bounds.translate(x, y), item);\n\n  if (set(item, 'x', x + delta) | set(item, 'y', y + delta)) {\n    item.bounds = tempBounds;\n    view.dirty(item);\n    item.bounds = bounds;\n    view.dirty(item);\n  }\n\n  return item.mark.bounds.clear().union(bounds);\n}\n\nfunction axisTitleLayout(view, title, offset, pad, dl, isYAxis, sign, bounds) {\n  const b = title.bounds;\n\n  if (title.auto) {\n    const v = sign * (offset + dl + pad);\n    let dx = 0, dy = 0;\n\n    view.dirty(title);\n    isYAxis\n      ? dx = (title.x || 0) - (title.x = v)\n      : dy = (title.y || 0) - (title.y = v);\n    title.mark.bounds.clear().union(b.translate(-dx, -dy));\n    view.dirty(title);\n  }\n\n  bounds.union(b);\n}\n","import {\n  All, AxisRole, ColFooter, ColHeader, ColTitle, Column, Each, End, Flush,\n  Group, LegendRole, Middle, Row,\n  RowFooter, RowHeader, RowTitle,\n  TitleRole, X, Y\n} from '../constants';\nimport {tempBounds} from './util';\nimport {Bounds} from 'vega-scenegraph';\nimport {isObject} from 'vega-util';\n\n// aggregation functions for grid margin determination\nconst min = (a, b) => Math.floor(Math.min(a, b));\nconst max = (a, b) => Math.ceil(Math.max(a, b));\n\nfunction gridLayoutGroups(group) {\n  var groups = group.items,\n      n = groups.length,\n      i = 0, mark, items;\n\n  const views = {\n    marks:      [],\n    rowheaders: [],\n    rowfooters: [],\n    colheaders: [],\n    colfooters: [],\n    rowtitle: null,\n    coltitle: null\n  };\n\n  // layout axes, gather legends, collect bounds\n  for (; i<n; ++i) {\n    mark = groups[i];\n    items = mark.items;\n    if (mark.marktype === Group) {\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n        case TitleRole:\n          break;\n        case RowHeader: views.rowheaders.push(...items); break;\n        case RowFooter: views.rowfooters.push(...items); break;\n        case ColHeader: views.colheaders.push(...items); break;\n        case ColFooter: views.colfooters.push(...items); break;\n        case RowTitle:  views.rowtitle = items[0]; break;\n        case ColTitle:  views.coltitle = items[0]; break;\n        default:        views.marks.push(...items);\n      }\n    }\n  }\n\n  return views;\n}\n\nfunction bboxFlush(item) {\n  return new Bounds().set(0, 0, item.width || 0, item.height || 0);\n}\n\nfunction bboxFull(item) {\n  const b = item.bounds.clone();\n  return b.empty()\n    ? b.set(0, 0, 0, 0)\n    : b.translate(-(item.x || 0), -(item.y || 0));\n}\n\nfunction get(opt, key, d) {\n  const v = isObject(opt) ? opt[key] : opt;\n  return v != null ? v : (d !== undefined ? d : 0);\n}\n\nfunction offsetValue(v) {\n  return v < 0 ? Math.ceil(-v) : 0;\n}\n\nexport function gridLayout(view, groups, opt) {\n  var dirty = !opt.nodirty,\n      bbox = opt.bounds === Flush ? bboxFlush : bboxFull,\n      bounds = tempBounds.set(0, 0, 0, 0),\n      alignCol = get(opt.align, Column),\n      alignRow = get(opt.align, Row),\n      padCol = get(opt.padding, Column),\n      padRow = get(opt.padding, Row),\n      ncols = opt.columns || groups.length,\n      nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\n      n = groups.length,\n      xOffset = Array(n), xExtent = Array(ncols), xMax = 0,\n      yOffset = Array(n), yExtent = Array(nrows), yMax = 0,\n      dx = Array(n), dy = Array(n), boxes = Array(n),\n      m, i, c, r, b, g, px, py, x, y, offset;\n\n  for (i=0; i<ncols; ++i) xExtent[i] = 0;\n  for (i=0; i<nrows; ++i) yExtent[i] = 0;\n\n  // determine offsets for each group\n  for (i=0; i<n; ++i) {\n    g = groups[i];\n    b = boxes[i] = bbox(g);\n    g.x = g.x || 0; dx[i] = 0;\n    g.y = g.y || 0; dy[i] = 0;\n    c = i % ncols;\n    r = ~~(i / ncols);\n    xMax = Math.max(xMax, px = Math.ceil(b.x2));\n    yMax = Math.max(yMax, py = Math.ceil(b.y2));\n    xExtent[c] = Math.max(xExtent[c], px);\n    yExtent[r] = Math.max(yExtent[r], py);\n    xOffset[i] = padCol + offsetValue(b.x1);\n    yOffset[i] = padRow + offsetValue(b.y1);\n    if (dirty) view.dirty(groups[i]);\n  }\n\n  // set initial alignment offsets\n  for (i=0; i<n; ++i) {\n    if (i % ncols === 0) xOffset[i] = 0;\n    if (i < ncols) yOffset[i] = 0;\n  }\n\n  // enforce column alignment constraints\n  if (alignCol === Each) {\n    for (c=1; c<ncols; ++c) {\n      for (offset=0, i=c; i<n; i += ncols) {\n        if (offset < xOffset[i]) offset = xOffset[i];\n      }\n      for (i=c; i<n; i += ncols) {\n        xOffset[i] = offset + xExtent[c-1];\n      }\n    }\n  } else if (alignCol === All) {\n    for (offset=0, i=0; i<n; ++i) {\n      if (i % ncols && offset < xOffset[i]) offset = xOffset[i];\n    }\n    for (i=0; i<n; ++i) {\n      if (i % ncols) xOffset[i] = offset + xMax;\n    }\n  } else {\n    for (alignCol=false, c=1; c<ncols; ++c) {\n      for (i=c; i<n; i += ncols) {\n        xOffset[i] += xExtent[c-1];\n      }\n    }\n  }\n\n  // enforce row alignment constraints\n  if (alignRow === Each) {\n    for (r=1; r<nrows; ++r) {\n      for (offset=0, i=r*ncols, m=i+ncols; i<m; ++i) {\n        if (offset < yOffset[i]) offset = yOffset[i];\n      }\n      for (i=r*ncols; i<m; ++i) {\n        yOffset[i] = offset + yExtent[r-1];\n      }\n    }\n  } else if (alignRow === All) {\n    for (offset=0, i=ncols; i<n; ++i) {\n      if (offset < yOffset[i]) offset = yOffset[i];\n    }\n    for (i=ncols; i<n; ++i) {\n      yOffset[i] = offset + yMax;\n    }\n  } else {\n    for (alignRow=false, r=1; r<nrows; ++r) {\n      for (i=r*ncols, m=i+ncols; i<m; ++i) {\n        yOffset[i] += yExtent[r-1];\n      }\n    }\n  }\n\n  // perform horizontal grid layout\n  for (x=0, i=0; i<n; ++i) {\n    x = xOffset[i] + (i % ncols ? x : 0);\n    dx[i] += x - groups[i].x;\n  }\n\n  // perform vertical grid layout\n  for (c=0; c<ncols; ++c) {\n    for (y=0, i=c; i<n; i += ncols) {\n      y += yOffset[i];\n      dy[i] += y - groups[i].y;\n    }\n  }\n\n  // perform horizontal centering\n  if (alignCol && get(opt.center, Column) && nrows > 1) {\n    for (i=0; i<n; ++i) {\n      b = alignCol === All ? xMax : xExtent[i % ncols];\n      x = b - boxes[i].x2 - groups[i].x - dx[i];\n      if (x > 0) dx[i] += x / 2;\n    }\n  }\n\n  // perform vertical centering\n  if (alignRow && get(opt.center, Row) && ncols !== 1) {\n    for (i=0; i<n; ++i) {\n      b = alignRow === All ? yMax : yExtent[~~(i / ncols)];\n      y = b - boxes[i].y2 - groups[i].y - dy[i];\n      if (y > 0) dy[i] += y / 2;\n    }\n  }\n\n  // position grid relative to anchor\n  for (i=0; i<n; ++i) {\n    bounds.union(boxes[i].translate(dx[i], dy[i]));\n  }\n  x = get(opt.anchor, X);\n  y = get(opt.anchor, Y);\n  switch (get(opt.anchor, Column)) {\n    case End:    x -= bounds.width(); break;\n    case Middle: x -= bounds.width() / 2;\n  }\n  switch (get(opt.anchor, Row)) {\n    case End:    y -= bounds.height(); break;\n    case Middle: y -= bounds.height() / 2;\n  }\n  x = Math.round(x);\n  y = Math.round(y);\n\n  // update mark positions, bounds, dirty\n  bounds.clear();\n  for (i=0; i<n; ++i) {\n    groups[i].mark.bounds.clear();\n  }\n  for (i=0; i<n; ++i) {\n    g = groups[i];\n    g.x += (dx[i] += x);\n    g.y += (dy[i] += y);\n    bounds.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));\n    if (dirty) view.dirty(g);\n  }\n\n  return bounds;\n}\n\nexport function trellisLayout(view, group, opt) {\n  var views = gridLayoutGroups(group),\n      groups = views.marks,\n      bbox = opt.bounds === Flush ? boundFlush : boundFull,\n      off = opt.offset,\n      ncols = opt.columns || groups.length,\n      nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),\n      cells = nrows * ncols,\n      x, y, x2, y2, anchor, band, offset;\n\n  // -- initial grid layout\n  const bounds = gridLayout(view, groups, opt);\n  if (bounds.empty()) bounds.set(0, 0, 0, 0); // empty grid\n\n  // -- layout grid headers and footers --\n\n  // perform row header layout\n  if (views.rowheaders) {\n    band = get(opt.headerBand, Row, null);\n    x = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get(off, 'rowHeader'), min, 0, bbox, 'x1', 0, ncols, 1, band);\n  }\n\n  // perform column header layout\n  if (views.colheaders) {\n    band = get(opt.headerBand, Column, null);\n    y = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get(off, 'columnHeader'), min, 1, bbox, 'y1', 0, 1, ncols, band);\n  }\n\n  // perform row footer layout\n  if (views.rowfooters) {\n    band = get(opt.footerBand, Row, null);\n    x2 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows,  get(off, 'rowFooter'), max, 0, bbox, 'x2', ncols-1, ncols, 1, band);\n  }\n\n  // perform column footer layout\n  if (views.colfooters) {\n    band = get(opt.footerBand, Column, null);\n    y2 = layoutHeaders(view, views.colfooters, groups, ncols, ncols,  get(off, 'columnFooter'), max, 1, bbox, 'y2', cells-ncols, 1, ncols, band);\n  }\n\n  // perform row title layout\n  if (views.rowtitle) {\n    anchor = get(opt.titleAnchor, Row);\n    offset = get(off, 'rowTitle');\n    offset = anchor === End ? x2 + offset : x - offset;\n    band = get(opt.titleBand, Row, 0.5);\n    layoutTitle(view, views.rowtitle, offset, 0, bounds, band);\n  }\n\n  // perform column title layout\n  if (views.coltitle) {\n    anchor = get(opt.titleAnchor, Column);\n    offset = get(off, 'columnTitle');\n    offset = anchor === End ? y2 + offset : y - offset;\n    band = get(opt.titleBand, Column, 0.5);\n    layoutTitle(view, views.coltitle, offset, 1, bounds, band);\n  }\n}\n\nfunction boundFlush(item, field) {\n  return field === 'x1' ? (item.x || 0)\n    : field === 'y1' ? (item.y || 0)\n    : field === 'x2' ? (item.x || 0) + (item.width || 0)\n    : field === 'y2' ? (item.y || 0) + (item.height || 0)\n    : undefined;\n}\n\nfunction boundFull(item, field) {\n  return item.bounds[field];\n}\n\nfunction layoutHeaders(view, headers, groups, ncols, limit, offset, agg, isX, bound, bf, start, stride, back, band) {\n  var n = groups.length,\n      init = 0,\n      edge = 0,\n      i, j, k, m, b, h, g, x, y;\n\n  // if no groups, early exit and return 0\n  if (!n) return init;\n\n  // compute margin\n  for (i=start; i<n; i+=stride) {\n    if (groups[i]) init = agg(init, bound(groups[i], bf));\n  }\n\n  // if no headers, return margin calculation\n  if (!headers.length) return init;\n\n  // check if number of headers exceeds number of rows or columns\n  if (headers.length > limit) {\n    view.warn('Grid headers exceed limit: ' + limit);\n    headers = headers.slice(0, limit);\n  }\n\n  // apply offset\n  init += offset;\n\n  // clear mark bounds for all headers\n  for (j=0, m=headers.length; j<m; ++j) {\n    view.dirty(headers[j]);\n    headers[j].mark.bounds.clear();\n  }\n\n  // layout each header\n  for (i=start, j=0, m=headers.length; j<m; ++j, i+=stride) {\n    h = headers[j];\n    b = h.mark.bounds;\n\n    // search for nearest group to align to\n    // necessary if table has empty cells\n    for (k=i; k >= 0 && (g = groups[k]) == null; k-=back);\n\n    // assign coordinates and update bounds\n    if (isX) {\n      x = band == null ? g.x : Math.round(g.bounds.x1 + band * g.bounds.width());\n      y = init;\n    } else {\n      x = init;\n      y = band == null ? g.y : Math.round(g.bounds.y1 + band * g.bounds.height());\n    }\n    b.union(h.bounds.translate(x - (h.x || 0), y - (h.y || 0)));\n    h.x = x;\n    h.y = y;\n    view.dirty(h);\n\n    // update current edge of layout bounds\n    edge = agg(edge, b[bf]);\n  }\n\n  return edge;\n}\n\nfunction layoutTitle(view, g, offset, isX, bounds, band) {\n  if (!g) return;\n  view.dirty(g);\n\n  // compute title coordinates\n  var x = offset, y = offset;\n  isX\n    ? (x = Math.round(bounds.x1 + band * bounds.width()))\n    : (y = Math.round(bounds.y1 + band * bounds.height()));\n\n  // assign coordinates and update bounds\n  g.bounds.translate(x - (g.x || 0), y - (g.y || 0));\n  g.mark.bounds.clear().union(g.bounds);\n  g.x = x;\n  g.y = y;\n\n  // queue title for redraw\n  view.dirty(g);\n}\n","import {\n  Bottom, BottomLeft, BottomRight, Each, End, Flush, Left, Middle,\n  None, Right, Start, Symbols, Top,\n  TopLeft, TopRight\n} from '../constants';\nimport {boundStroke, multiLineOffset} from 'vega-scenegraph';\n\n// utility for looking up legend layout configuration\nfunction lookup(config, orient) {\n  const opt = config[orient] || {};\n  return (key, d) => opt[key] != null ? opt[key]\n    : config[key] != null ? config[key]\n    : d;\n}\n\n// if legends specify offset directly, use the maximum specified value\nfunction offsets(legends, value) {\n  let max = -Infinity;\n  legends.forEach(item => {\n    if (item.offset != null) max = Math.max(max, item.offset);\n  });\n  return max > -Infinity ? max : value;\n}\n\nexport function legendParams(g, orient, config, xb, yb, w, h) {\n  const _ = lookup(config, orient),\n        offset = offsets(g, _('offset', 0)),\n        anchor = _('anchor', Start),\n        mult = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;\n\n  const p = {\n    align:   Each,\n    bounds:  _('bounds', Flush),\n    columns: _('direction') === 'vertical' ? 1 : g.length,\n    padding: _('margin', 8),\n    center:  _('center'),\n    nodirty: true\n  };\n\n  switch (orient) {\n    case Left:\n      p.anchor = {\n        x: Math.floor(xb.x1) - offset, column: End,\n        y: mult * (h || xb.height() + 2 * xb.y1), row: anchor\n      };\n      break;\n    case Right:\n      p.anchor = {\n        x: Math.ceil(xb.x2) + offset,\n        y: mult * (h || xb.height() + 2 * xb.y1), row: anchor\n      };\n      break;\n    case Top:\n      p.anchor = {\n        y: Math.floor(yb.y1) - offset, row: End,\n        x: mult * (w || yb.width() + 2 * yb.x1), column: anchor\n      };\n      break;\n    case Bottom:\n      p.anchor = {\n        y: Math.ceil(yb.y2) + offset,\n        x: mult * (w || yb.width() + 2 * yb.x1), column: anchor\n      };\n      break;\n    case TopLeft:\n      p.anchor = {x: offset, y: offset};\n      break;\n    case TopRight:\n      p.anchor = {x: w - offset, y: offset, column: End};\n      break;\n    case BottomLeft:\n      p.anchor = {x: offset, y: h - offset, row: End};\n      break;\n    case BottomRight:\n      p.anchor = {x: w - offset, y: h - offset, column: End, row: End};\n      break;\n  }\n\n  return p;\n}\n\nexport function legendLayout(view, legend) {\n  var item = legend.items[0],\n      datum = item.datum,\n      orient = item.orient,\n      bounds = item.bounds,\n      x = item.x, y = item.y, w, h;\n\n  // cache current bounds for later comparison\n  item._bounds\n    ? item._bounds.clear().union(bounds)\n    : item._bounds = bounds.clone();\n  bounds.clear();\n\n  // adjust legend to accommodate padding and title\n  legendGroupLayout(view, item, item.items[0].items[0]);\n\n  // aggregate bounds to determine size, and include origin\n  bounds = legendBounds(item, bounds);\n  w = 2 * item.padding;\n  h = 2 * item.padding;\n  if (!bounds.empty()) {\n    w = Math.ceil(bounds.width() + w);\n    h = Math.ceil(bounds.height() + h);\n  }\n\n  if (datum.type === Symbols) {\n    legendEntryLayout(item.items[0].items[0].items[0].items);\n  }\n\n  if (orient !== None) {\n    item.x = x = 0;\n    item.y = y = 0;\n  }\n  item.width = w;\n  item.height = h;\n  boundStroke(bounds.set(x, y, x + w, y + h), item);\n  item.mark.bounds.clear().union(bounds);\n\n  return item;\n}\n\nfunction legendBounds(item, b) {\n  // aggregate item bounds\n  item.items.forEach(_ => b.union(_.bounds));\n\n  // anchor to legend origin\n  b.x1 = item.padding;\n  b.y1 = item.padding;\n\n  return b;\n}\n\nfunction legendGroupLayout(view, item, entry) {\n  var pad = item.padding,\n      ex = pad - entry.x,\n      ey = pad - entry.y;\n\n  if (!item.datum.title) {\n    if (ex || ey) translate(view, entry, ex, ey);\n  } else {\n    var title = item.items[1].items[0],\n        anchor = title.anchor,\n        tpad = item.titlePadding || 0,\n        tx = pad - title.x,\n        ty = pad - title.y;\n\n    switch (title.orient) {\n      case Left:\n        ex += Math.ceil(title.bounds.width()) + tpad;\n        break;\n      case Right:\n      case Bottom:\n        break;\n      default:\n        ey += title.bounds.height() + tpad;\n    }\n    if (ex || ey) translate(view, entry, ex, ey);\n\n    switch (title.orient) {\n      case Left:\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n      case Right:\n        tx += legendTitleOffset(item, entry, title, End, 0, 0) + tpad;\n        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);\n        break;\n      case Bottom:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n        ty += legendTitleOffset(item, entry, title, End, -1, 0, 1) + tpad;\n        break;\n      default:\n        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);\n    }\n    if (tx || ty) translate(view, title, tx, ty);\n\n    // translate legend if title pushes into negative coordinates\n    if ((tx = Math.round(title.bounds.x1 - pad)) < 0) {\n      translate(view, entry, -tx, 0);\n      translate(view, title, -tx, 0);\n    }\n  }\n}\n\nfunction legendTitleOffset(item, entry, title, anchor, y, lr, noBar) {\n  const grad = item.datum.type !== 'symbol',\n        vgrad = title.datum.vgrad,\n        e = grad && (lr || !vgrad) && !noBar ? entry.items[0] : entry,\n        s = e.bounds[y ? 'y2' : 'x2'] - item.padding,\n        u = vgrad && lr ? s : 0,\n        v = vgrad && lr ? 0 : s,\n        o = y <= 0 ? 0 : multiLineOffset(title);\n\n  return Math.round(anchor === Start ? u\n    : anchor === End ? (v - o)\n    : 0.5 * (s - o));\n}\n\nfunction translate(view, item, dx, dy) {\n  item.x += dx;\n  item.y += dy;\n  item.bounds.translate(dx, dy);\n  item.mark.bounds.translate(dx, dy);\n  view.dirty(item);\n}\n\nfunction legendEntryLayout(entries) {\n  // get max widths for each column\n  const widths = entries.reduce((w, g) => {\n    w[g.column] = Math.max(g.bounds.x2 - g.x, w[g.column] || 0);\n    return w;\n  }, {});\n\n  // set dimensions of legend entry groups\n  entries.forEach(g => {\n    g.width  = widths[g.column];\n    g.height = g.bounds.y2 - g.y;\n  });\n}\n","import {\n  AxisRole, Bottom, ColFooter, ColHeader, ColTitle,\n  Fit, FitX, FitY, FrameRole, Left, LegendRole,\n  None, Pad, Padding, Right,\n  RowFooter, RowHeader, RowTitle, ScopeRole, TitleRole, Top\n} from './constants';\n\nimport {axisLayout, isYAxis} from './layout/axis';\nimport {gridLayout, trellisLayout} from './layout/grid';\nimport {legendLayout, legendParams} from './layout/legend';\nimport {titleLayout} from './layout/title';\n\nimport {Transform} from 'vega-dataflow';\nimport {Bounds} from 'vega-scenegraph';\nimport {inherits} from 'vega-util';\n\n/**\n * Layout view elements such as axes and legends.\n * Also performs size adjustments.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - Scenegraph mark of groups to layout.\n */\nexport default function ViewLayout(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(ViewLayout, Transform, {\n  transform(_, pulse) {\n    const view = pulse.dataflow;\n    _.mark.items.forEach(group => {\n      if (_.layout) trellisLayout(view, group, _.layout);\n      layoutGroup(view, group, _);\n    });\n    return shouldReflow(_.mark.group) ? pulse.reflow() : pulse;\n  }\n});\n\nfunction shouldReflow(group) {\n  // We typically should reflow if layout is invoked (#2568), as child items\n  // may have resized and reflow ensures group bounds are re-calculated.\n  // However, legend entries have a special exception to avoid instability.\n  // For example, if a selected legend symbol gains a stroke on hover,\n  // we don't want to re-position subsequent elements in the legend.\n  return group && group.mark.role !== 'legend-entry';\n}\n\nfunction layoutGroup(view, group, _) {\n  var items = group.items,\n      width = Math.max(0, group.width || 0),\n      height = Math.max(0, group.height || 0),\n      viewBounds = new Bounds().set(0, 0, width, height),\n      xBounds = viewBounds.clone(),\n      yBounds = viewBounds.clone(),\n      legends = [], title,\n      mark, orient, b, i, n;\n\n  // layout axes, gather legends, collect bounds\n  for (i=0, n=items.length; i<n; ++i) {\n    mark = items[i];\n    switch (mark.role) {\n      case AxisRole:\n        b = isYAxis(mark) ? xBounds : yBounds;\n        b.union(axisLayout(view, mark, width, height));\n        break;\n      case TitleRole:\n        title = mark;\n        break;\n      case LegendRole:\n        legends.push(legendLayout(view, mark));\n        break;\n      case FrameRole:\n      case ScopeRole:\n      case RowHeader:\n      case RowFooter:\n      case RowTitle:\n      case ColHeader:\n      case ColFooter:\n      case ColTitle:\n        xBounds.union(mark.bounds);\n        yBounds.union(mark.bounds);\n        break;\n      default:\n        viewBounds.union(mark.bounds);\n    }\n  }\n\n  // layout legends, adjust viewBounds\n  if (legends.length) {\n    // group legends by orient\n    const l = {};\n    legends.forEach(item => {\n      orient = item.orient || Right;\n      if (orient !== None) (l[orient] || (l[orient] = [])).push(item);\n    });\n\n    // perform grid layout for each orient group\n    for (const orient in l) {\n      const g = l[orient];\n      gridLayout(view, g, legendParams(\n        g, orient, _.legends, xBounds, yBounds, width, height\n      ));\n    }\n\n    // update view bounds\n    legends.forEach(item => {\n      const b = item.bounds;\n\n      if (!b.equals(item._bounds)) {\n        item.bounds = item._bounds;\n        view.dirty(item); // dirty previous location\n        item.bounds = b;\n        view.dirty(item);\n      }\n\n      if (_.autosize && (_.autosize.type === Fit  || \n                         _.autosize.type === FitX || \n                         _.autosize.type === FitY )) {\n        // For autosize fit, incorporate the orthogonal dimension only.\n        // Legends that overrun the chart area will then be clipped;\n        // otherwise the chart area gets reduced to nothing!\n        switch(item.orient) {\n          case Left:\n          case Right:\n            viewBounds.add(b.x1, 0).add(b.x2, 0);\n            break;\n          case Top:\n          case Bottom:\n            viewBounds.add(0, b.y1).add(0, b.y2);\n        }\n      } else {\n        viewBounds.union(b);\n      }\n    });\n  }\n\n  // combine bounding boxes\n  viewBounds.union(xBounds).union(yBounds);\n\n  // layout title, adjust bounds\n  if (title) {\n    viewBounds.union(titleLayout(view, title, width, height, viewBounds));\n  }\n\n  // override aggregated view bounds if content is clipped\n  if (group.clip) {\n    viewBounds.set(0, 0, group.width || 0, group.height || 0);\n  }\n\n  // perform size adjustment\n  viewSizeLayout(view, group, viewBounds, _);\n}\n\nfunction viewSizeLayout(view, group, viewBounds, _) {\n  const auto = _.autosize || {},\n        type = auto.type;\n\n  if (view._autosize < 1 || !type) return;\n\n  let viewWidth = view._width,\n      viewHeight = view._height,\n      width  = Math.max(0, group.width || 0),\n      left   = Math.max(0, Math.ceil(-viewBounds.x1)),\n      height = Math.max(0, group.height || 0),\n      top    = Math.max(0, Math.ceil(-viewBounds.y1));\n\n  const right  = Math.max(0, Math.ceil(viewBounds.x2 - width)),\n        bottom = Math.max(0, Math.ceil(viewBounds.y2 - height));\n\n  if (auto.contains === Padding) {\n    const padding = view.padding();\n    viewWidth -= padding.left + padding.right;\n    viewHeight -= padding.top + padding.bottom;\n  }\n\n  if (type === None) {\n    left = 0;\n    top = 0;\n    width = viewWidth;\n    height = viewHeight;\n  }\n\n  else if (type === Fit) {\n    width = Math.max(0, viewWidth - left - right);\n    height = Math.max(0, viewHeight - top - bottom);\n  }\n\n  else if (type === FitX) {\n    width = Math.max(0, viewWidth - left - right);\n    viewHeight = height + top + bottom;\n  }\n\n  else if (type === FitY) {\n    viewWidth = width + left + right;\n    height = Math.max(0, viewHeight - top - bottom);\n  }\n\n  else if (type === Pad) {\n    viewWidth = width + left + right;\n    viewHeight = height + top + bottom;\n  }\n\n  view._resizeView(\n    viewWidth, viewHeight,\n    width, height,\n    [left, top],\n    auto.resize\n  );\n}\n","import {Bottom, End, Group, Left, Right, Start, Top} from '../constants';\nimport {set, tempBounds} from './util';\n\nexport function titleLayout(view, mark, width, height, viewBounds) {\n  var group = mark.items[0],\n      frame = group.frame,\n      orient = group.orient,\n      anchor = group.anchor,\n      offset = group.offset,\n      padding = group.padding,\n      title = group.items[0].items[0],\n      subtitle = group.items[1] && group.items[1].items[0],\n      end = (orient === Left || orient === Right) ? height : width,\n      start = 0, x = 0, y = 0, sx = 0, sy = 0, pos;\n\n  if (frame !== Group) {\n    orient === Left ? (start = viewBounds.y2, end = viewBounds.y1)\n      : orient === Right ? (start = viewBounds.y1, end = viewBounds.y2)\n      : (start = viewBounds.x1, end = viewBounds.x2);\n  } else if (orient === Left) {\n    start = height, end = 0;\n  }\n\n  pos = (anchor === Start) ? start\n    : (anchor === End) ? end\n    : (start + end) / 2;\n\n  if (subtitle && subtitle.text) {\n    // position subtitle\n    switch (orient) {\n      case Top:\n      case Bottom:\n        sy = title.bounds.height() + padding;\n        break;\n      case Left:\n        sx = title.bounds.width() + padding;\n        break;\n      case Right:\n        sx = -title.bounds.width() - padding;\n        break;\n    }\n\n    tempBounds.clear().union(subtitle.bounds);\n    tempBounds.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));\n    if (set(subtitle, 'x', sx) | set(subtitle, 'y', sy)) {\n      view.dirty(subtitle);\n      subtitle.bounds.clear().union(tempBounds);\n      subtitle.mark.bounds.clear().union(tempBounds);\n      view.dirty(subtitle);\n    }\n\n    tempBounds.clear().union(subtitle.bounds);\n  } else {\n    tempBounds.clear();\n  }\n  tempBounds.union(title.bounds);\n\n  // position title group\n  switch (orient) {\n    case Top:\n      x = pos;\n      y = viewBounds.y1 - tempBounds.height() - offset;\n      break;\n    case Left:\n      x = viewBounds.x1 - tempBounds.width() - offset;\n      y = pos;\n      break;\n    case Right:\n      x = viewBounds.x2 + tempBounds.width() + offset;\n      y = pos;\n      break;\n    case Bottom:\n      x = pos;\n      y = viewBounds.y2 + offset;\n      break;\n    default:\n      x = group.x;\n      y = group.y;\n  }\n\n  if (set(group, 'x', x) | set(group, 'y', y)) {\n    tempBounds.translate(x, y);\n    view.dirty(group);\n    group.bounds.clear().union(tempBounds);\n    mark.bounds.clear().union(tempBounds);\n    view.dirty(group);\n  }\n  return group.bounds;\n}\n"],"names":["Top","Left","Right","Bottom","TopLeft","TopRight","BottomLeft","BottomRight","Start","Middle","End","X","Y","Group","AxisRole","TitleRole","FrameRole","ScopeRole","LegendRole","RowHeader","RowFooter","RowTitle","ColHeader","ColFooter","ColTitle","Padding","Symbols","Fit","FitX","FitY","Pad","None","All","Each","Flush","Column","Row","Bound","params","Transform","call","this","boundItem","item","bound","opt","bounds","clear","inherits","transform","_","pulse","view","dataflow","mark","type","marktype","entry","Marks","rebound","markBounds","nested","items","length","dirty","forEach","union","modified","visit","MOD","role","reflow","changed","REM","ADD","alignsWith","boundClip","modifies","COUNTER_NAME","Identifier","Mark","Overlap","Definition","metadata","name","required","counter","_signals","add","as","id","value","t","set","scenegraph","markdef","g","groups","p","parent","size","get","Object","keys","object","lookup","index","group","context","source","clip","interactive","Init","GroupItem","Item","zdirty","methods","parity","filter","i","opacity","greedy","sep","a","b","intersect","Math","max","x1","x2","y1","y2","hasOverlap","pad","n","hasBounds","width","height","reset","Render","reduce","method","separation","test","materialize","SOURCE","sort","slice","peek","boundTest","scale","orient","tolerance","range","boundScale","boundTolerance","boundOrient","Bounds","expand","encloses","ALL","fields","tempBounds","property","isYAxis","axisLayout","axis","s","datum","delta","translate","indices","grid","ticks","labels","domain","axisIndices","offset","position","minExtent","maxExtent","title","titlePadding","dl","multiLineOffset","x","y","min","axisTitleLayout","boundStroke","sign","auto","v","dx","dy","floor","ceil","bboxFlush","bboxFull","clone","empty","key","d","isObject","undefined","offsetValue","gridLayout","m","c","r","px","py","nodirty","bbox","alignCol","align","alignRow","padCol","padding","padRow","ncols","columns","nrows","xOffset","Array","xExtent","xMax","yOffset","yExtent","yMax","boxes","center","anchor","round","trellisLayout","band","views","marks","rowheaders","rowfooters","colheaders","colfooters","rowtitle","coltitle","push","gridLayoutGroups","boundFlush","boundFull","off","cells","headerBand","layoutHeaders","footerBand","titleAnchor","titleBand","layoutTitle","field","headers","limit","agg","isX","bf","start","stride","back","j","k","h","init","edge","warn","legendParams","config","xb","yb","w","legends","offsets","mult","column","row","legendLayout","legend","_bounds","ex","ey","tpad","tx","ty","legendTitleOffset","legendGroupLayout","legendBounds","entries","widths","legendEntryLayout","lr","noBar","grad","vgrad","u","o","ViewLayout","layout","viewBounds","xBounds","yBounds","l","equals","autosize","pos","frame","subtitle","end","sx","sy","text","titleLayout","_autosize","viewWidth","_width","viewHeight","_height","left","top","right","bottom","contains","_resizeView","resize","viewSizeLayout","layoutGroup"],"mappings":"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"}